#![feature(prelude_import)]
#[prelude_import]
use std::prelude::rust_2021::*;
#[macro_use]
extern crate std;
mod core {
    pub mod crypto {
        pub mod blake3 {
            pub fn blake3_20(message: &[u8]) -> [u8; 20] {
                let mut hasher = blake3::Hasher::new();
                hasher.update(message);
                let mut result = [0u8; 20];
                hasher.finalize_xof().fill(&mut result);
                result
            }
        }
        pub mod ed25519 {}
        pub mod eip712 {
            use ethers::contract::{Eip712, EthAbiType};
            use ethers::types::{Address, Bytes, U256};
            use serde::{Deserialize, Deserializer};
            fn deserialize_u256_from_i64<'de, D>(
                deserializer: D,
            ) -> Result<U256, D::Error>
            where
                D: Deserializer<'de>,
            {
                i64::deserialize(deserializer).map(U256::from)
            }
            #[eip712(
                name = "Farcaster Verify Ethereum Address",
                version = "2.0.0",
                salt = "0xf2d857f4a3edcb9b78b4d503bfe733db1e3f6cdc2b7971ee739626c97e86a558"
            )]
            #[allow(non_snake_case)]
            pub struct EIP712VerificationClaim {
                pub fid: U256,
                pub address: Address,
                pub blockHash: Bytes,
                pub network: u8,
            }
            #[automatically_derived]
            #[allow(non_snake_case)]
            impl ::core::clone::Clone for EIP712VerificationClaim {
                #[inline]
                fn clone(&self) -> EIP712VerificationClaim {
                    EIP712VerificationClaim {
                        fid: ::core::clone::Clone::clone(&self.fid),
                        address: ::core::clone::Clone::clone(&self.address),
                        blockHash: ::core::clone::Clone::clone(&self.blockHash),
                        network: ::core::clone::Clone::clone(&self.network),
                    }
                }
            }
            #[automatically_derived]
            #[allow(non_snake_case)]
            impl ::core::fmt::Debug for EIP712VerificationClaim {
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    ::core::fmt::Formatter::debug_struct_field4_finish(
                        f,
                        "EIP712VerificationClaim",
                        "fid",
                        &self.fid,
                        "address",
                        &self.address,
                        "blockHash",
                        &self.blockHash,
                        "network",
                        &&self.network,
                    )
                }
            }
            #[doc(hidden)]
            #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
            const _: () = {
                #[allow(unused_extern_crates, clippy::useless_attribute)]
                extern crate serde as _serde;
                #[automatically_derived]
                impl<'de> _serde::Deserialize<'de> for EIP712VerificationClaim {
                    fn deserialize<__D>(
                        __deserializer: __D,
                    ) -> _serde::__private::Result<Self, __D::Error>
                    where
                        __D: _serde::Deserializer<'de>,
                    {
                        #[allow(non_camel_case_types)]
                        #[doc(hidden)]
                        enum __Field {
                            __field0,
                            __field1,
                            __field2,
                            __field3,
                            __ignore,
                        }
                        #[doc(hidden)]
                        struct __FieldVisitor;
                        impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                            type Value = __Field;
                            fn expecting(
                                &self,
                                __formatter: &mut _serde::__private::Formatter,
                            ) -> _serde::__private::fmt::Result {
                                _serde::__private::Formatter::write_str(
                                    __formatter,
                                    "field identifier",
                                )
                            }
                            fn visit_u64<__E>(
                                self,
                                __value: u64,
                            ) -> _serde::__private::Result<Self::Value, __E>
                            where
                                __E: _serde::de::Error,
                            {
                                match __value {
                                    0u64 => _serde::__private::Ok(__Field::__field0),
                                    1u64 => _serde::__private::Ok(__Field::__field1),
                                    2u64 => _serde::__private::Ok(__Field::__field2),
                                    3u64 => _serde::__private::Ok(__Field::__field3),
                                    _ => _serde::__private::Ok(__Field::__ignore),
                                }
                            }
                            fn visit_str<__E>(
                                self,
                                __value: &str,
                            ) -> _serde::__private::Result<Self::Value, __E>
                            where
                                __E: _serde::de::Error,
                            {
                                match __value {
                                    "fid" => _serde::__private::Ok(__Field::__field0),
                                    "address" => _serde::__private::Ok(__Field::__field1),
                                    "blockHash" => _serde::__private::Ok(__Field::__field2),
                                    "network" => _serde::__private::Ok(__Field::__field3),
                                    _ => _serde::__private::Ok(__Field::__ignore),
                                }
                            }
                            fn visit_bytes<__E>(
                                self,
                                __value: &[u8],
                            ) -> _serde::__private::Result<Self::Value, __E>
                            where
                                __E: _serde::de::Error,
                            {
                                match __value {
                                    b"fid" => _serde::__private::Ok(__Field::__field0),
                                    b"address" => _serde::__private::Ok(__Field::__field1),
                                    b"blockHash" => _serde::__private::Ok(__Field::__field2),
                                    b"network" => _serde::__private::Ok(__Field::__field3),
                                    _ => _serde::__private::Ok(__Field::__ignore),
                                }
                            }
                        }
                        impl<'de> _serde::Deserialize<'de> for __Field {
                            #[inline]
                            fn deserialize<__D>(
                                __deserializer: __D,
                            ) -> _serde::__private::Result<Self, __D::Error>
                            where
                                __D: _serde::Deserializer<'de>,
                            {
                                _serde::Deserializer::deserialize_identifier(
                                    __deserializer,
                                    __FieldVisitor,
                                )
                            }
                        }
                        #[doc(hidden)]
                        struct __Visitor<'de> {
                            marker: _serde::__private::PhantomData<
                                EIP712VerificationClaim,
                            >,
                            lifetime: _serde::__private::PhantomData<&'de ()>,
                        }
                        impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                            type Value = EIP712VerificationClaim;
                            fn expecting(
                                &self,
                                __formatter: &mut _serde::__private::Formatter,
                            ) -> _serde::__private::fmt::Result {
                                _serde::__private::Formatter::write_str(
                                    __formatter,
                                    "struct EIP712VerificationClaim",
                                )
                            }
                            #[inline]
                            fn visit_seq<__A>(
                                self,
                                mut __seq: __A,
                            ) -> _serde::__private::Result<Self::Value, __A::Error>
                            where
                                __A: _serde::de::SeqAccess<'de>,
                            {
                                let __field0 = match _serde::de::SeqAccess::next_element::<
                                    U256,
                                >(&mut __seq)? {
                                    _serde::__private::Some(__value) => __value,
                                    _serde::__private::None => {
                                        return _serde::__private::Err(
                                            _serde::de::Error::invalid_length(
                                                0usize,
                                                &"struct EIP712VerificationClaim with 4 elements",
                                            ),
                                        );
                                    }
                                };
                                let __field1 = match _serde::de::SeqAccess::next_element::<
                                    Address,
                                >(&mut __seq)? {
                                    _serde::__private::Some(__value) => __value,
                                    _serde::__private::None => {
                                        return _serde::__private::Err(
                                            _serde::de::Error::invalid_length(
                                                1usize,
                                                &"struct EIP712VerificationClaim with 4 elements",
                                            ),
                                        );
                                    }
                                };
                                let __field2 = match _serde::de::SeqAccess::next_element::<
                                    Bytes,
                                >(&mut __seq)? {
                                    _serde::__private::Some(__value) => __value,
                                    _serde::__private::None => {
                                        return _serde::__private::Err(
                                            _serde::de::Error::invalid_length(
                                                2usize,
                                                &"struct EIP712VerificationClaim with 4 elements",
                                            ),
                                        );
                                    }
                                };
                                let __field3 = match _serde::de::SeqAccess::next_element::<
                                    u8,
                                >(&mut __seq)? {
                                    _serde::__private::Some(__value) => __value,
                                    _serde::__private::None => {
                                        return _serde::__private::Err(
                                            _serde::de::Error::invalid_length(
                                                3usize,
                                                &"struct EIP712VerificationClaim with 4 elements",
                                            ),
                                        );
                                    }
                                };
                                _serde::__private::Ok(EIP712VerificationClaim {
                                    fid: __field0,
                                    address: __field1,
                                    blockHash: __field2,
                                    network: __field3,
                                })
                            }
                            #[inline]
                            fn visit_map<__A>(
                                self,
                                mut __map: __A,
                            ) -> _serde::__private::Result<Self::Value, __A::Error>
                            where
                                __A: _serde::de::MapAccess<'de>,
                            {
                                let mut __field0: _serde::__private::Option<U256> = _serde::__private::None;
                                let mut __field1: _serde::__private::Option<Address> = _serde::__private::None;
                                let mut __field2: _serde::__private::Option<Bytes> = _serde::__private::None;
                                let mut __field3: _serde::__private::Option<u8> = _serde::__private::None;
                                while let _serde::__private::Some(__key)
                                    = _serde::de::MapAccess::next_key::<__Field>(&mut __map)? {
                                    match __key {
                                        __Field::__field0 => {
                                            if _serde::__private::Option::is_some(&__field0) {
                                                return _serde::__private::Err(
                                                    <__A::Error as _serde::de::Error>::duplicate_field("fid"),
                                                );
                                            }
                                            __field0 = _serde::__private::Some(
                                                _serde::de::MapAccess::next_value::<U256>(&mut __map)?,
                                            );
                                        }
                                        __Field::__field1 => {
                                            if _serde::__private::Option::is_some(&__field1) {
                                                return _serde::__private::Err(
                                                    <__A::Error as _serde::de::Error>::duplicate_field(
                                                        "address",
                                                    ),
                                                );
                                            }
                                            __field1 = _serde::__private::Some(
                                                _serde::de::MapAccess::next_value::<Address>(&mut __map)?,
                                            );
                                        }
                                        __Field::__field2 => {
                                            if _serde::__private::Option::is_some(&__field2) {
                                                return _serde::__private::Err(
                                                    <__A::Error as _serde::de::Error>::duplicate_field(
                                                        "blockHash",
                                                    ),
                                                );
                                            }
                                            __field2 = _serde::__private::Some(
                                                _serde::de::MapAccess::next_value::<Bytes>(&mut __map)?,
                                            );
                                        }
                                        __Field::__field3 => {
                                            if _serde::__private::Option::is_some(&__field3) {
                                                return _serde::__private::Err(
                                                    <__A::Error as _serde::de::Error>::duplicate_field(
                                                        "network",
                                                    ),
                                                );
                                            }
                                            __field3 = _serde::__private::Some(
                                                _serde::de::MapAccess::next_value::<u8>(&mut __map)?,
                                            );
                                        }
                                        _ => {
                                            let _ = _serde::de::MapAccess::next_value::<
                                                _serde::de::IgnoredAny,
                                            >(&mut __map)?;
                                        }
                                    }
                                }
                                let __field0 = match __field0 {
                                    _serde::__private::Some(__field0) => __field0,
                                    _serde::__private::None => {
                                        _serde::__private::de::missing_field("fid")?
                                    }
                                };
                                let __field1 = match __field1 {
                                    _serde::__private::Some(__field1) => __field1,
                                    _serde::__private::None => {
                                        _serde::__private::de::missing_field("address")?
                                    }
                                };
                                let __field2 = match __field2 {
                                    _serde::__private::Some(__field2) => __field2,
                                    _serde::__private::None => {
                                        _serde::__private::de::missing_field("blockHash")?
                                    }
                                };
                                let __field3 = match __field3 {
                                    _serde::__private::Some(__field3) => __field3,
                                    _serde::__private::None => {
                                        _serde::__private::de::missing_field("network")?
                                    }
                                };
                                _serde::__private::Ok(EIP712VerificationClaim {
                                    fid: __field0,
                                    address: __field1,
                                    blockHash: __field2,
                                    network: __field3,
                                })
                            }
                        }
                        #[doc(hidden)]
                        const FIELDS: &'static [&'static str] = &[
                            "fid",
                            "address",
                            "blockHash",
                            "network",
                        ];
                        _serde::Deserializer::deserialize_struct(
                            __deserializer,
                            "EIP712VerificationClaim",
                            FIELDS,
                            __Visitor {
                                marker: _serde::__private::PhantomData::<
                                    EIP712VerificationClaim,
                                >,
                                lifetime: _serde::__private::PhantomData,
                            },
                        )
                    }
                }
            };
            impl ::ethers::core::types::transaction::eip712::Eip712
            for EIP712VerificationClaim {
                type Error = ::ethers::core::types::transaction::eip712::Eip712Error;
                #[inline]
                fn type_hash() -> ::core::result::Result<[u8; 32], Self::Error> {
                    Ok([
                        96u8,
                        208u8,
                        123u8,
                        17u8,
                        181u8,
                        236u8,
                        229u8,
                        34u8,
                        109u8,
                        253u8,
                        164u8,
                        173u8,
                        217u8,
                        213u8,
                        27u8,
                        81u8,
                        183u8,
                        56u8,
                        4u8,
                        238u8,
                        49u8,
                        200u8,
                        113u8,
                        91u8,
                        98u8,
                        136u8,
                        157u8,
                        50u8,
                        11u8,
                        184u8,
                        68u8,
                        88u8,
                    ])
                }
                #[inline]
                fn domain_separator(
                    &self,
                ) -> ::core::result::Result<[u8; 32], Self::Error> {
                    Ok([
                        162u8,
                        122u8,
                        6u8,
                        14u8,
                        167u8,
                        169u8,
                        252u8,
                        173u8,
                        188u8,
                        17u8,
                        133u8,
                        157u8,
                        198u8,
                        226u8,
                        120u8,
                        126u8,
                        233u8,
                        163u8,
                        179u8,
                        1u8,
                        74u8,
                        81u8,
                        113u8,
                        59u8,
                        53u8,
                        147u8,
                        85u8,
                        76u8,
                        115u8,
                        37u8,
                        118u8,
                        53u8,
                    ])
                }
                fn domain(
                    &self,
                ) -> ::core::result::Result<
                    ::ethers::core::types::transaction::eip712::EIP712Domain,
                    Self::Error,
                > {
                    ::ethers::core::utils::__serde_json::from_str(
                            "{\"name\":\"Farcaster Verify Ethereum Address\",\"version\":\"2.0.0\",\"salt\":[149,140,54,235,57,218,127,158,177,218,156,20,9,149,29,196,136,196,35,243,52,195,26,220,229,91,57,150,82,153,25,46]}",
                        )
                        .map_err(::core::convert::Into::into)
                }
                fn struct_hash(&self) -> ::core::result::Result<[u8; 32], Self::Error> {
                    let mut items = <[_]>::into_vec(
                        #[rustc_box]
                        ::alloc::boxed::Box::new([
                            ::ethers::core::abi::Token::Uint(
                                ::ethers::core::types::U256::from(&Self::type_hash()?[..]),
                            ),
                        ]),
                    );
                    if let ::ethers::core::abi::Token::Tuple(tokens)
                        = ::ethers::core::abi::Tokenizable::into_token(
                            ::core::clone::Clone::clone(self),
                        ) {
                        items.reserve(tokens.len());
                        for token in tokens {
                            match &token {
                                ::ethers::core::abi::Token::Tuple(t) => {
                                    return Err(Self::Error::NestedEip712StructNotImplemented);
                                }
                                _ => {
                                    items
                                        .push(
                                            ::ethers::core::types::transaction::eip712::encode_eip712_type(
                                                token,
                                            ),
                                        );
                                }
                            }
                        }
                    }
                    let struct_hash = ::ethers::core::utils::keccak256(
                        ::ethers::core::abi::encode(&items),
                    );
                    Ok(struct_hash)
                }
            }
            impl ::ethers::core::abi::AbiType for EIP712VerificationClaim {
                fn param_type() -> ::ethers::core::abi::ParamType {
                    ::ethers::core::abi::ParamType::Tuple(
                        <[_]>::into_vec(
                            #[rustc_box]
                            ::alloc::boxed::Box::new([
                                <U256 as ::ethers::core::abi::AbiType>::param_type(),
                                <Address as ::ethers::core::abi::AbiType>::param_type(),
                                <Bytes as ::ethers::core::abi::AbiType>::param_type(),
                                <u8 as ::ethers::core::abi::AbiType>::param_type(),
                            ]),
                        ),
                    )
                }
            }
            impl ::ethers::core::abi::AbiArrayType for EIP712VerificationClaim {}
            impl ::ethers::core::abi::Tokenizable for EIP712VerificationClaim
            where
                U256: ::ethers::core::abi::Tokenize,
                Address: ::ethers::core::abi::Tokenize,
                Bytes: ::ethers::core::abi::Tokenize,
                u8: ::ethers::core::abi::Tokenize,
            {
                fn from_token(
                    token: ::ethers::core::abi::Token,
                ) -> ::core::result::Result<
                    Self,
                    ::ethers::core::abi::InvalidOutputType,
                > {
                    if let ::ethers::core::abi::Token::Tuple(tokens) = token {
                        if tokens.len() != 4usize {
                            return Err(
                                ::ethers::core::abi::InvalidOutputType({
                                    let res = ::alloc::fmt::format(
                                        format_args!(
                                            "Expected 4 tokens, got {0}: {1:?}",
                                            tokens.len(),
                                            tokens,
                                        ),
                                    );
                                    res
                                }),
                            );
                        }
                        let mut iter = tokens.into_iter();
                        Ok(Self {
                            fid: ::ethers::core::abi::Tokenizable::from_token(
                                iter
                                    .next()
                                    .expect(
                                        "The iter is guaranteed to be something due to the size check",
                                    ),
                            )?,
                            address: ::ethers::core::abi::Tokenizable::from_token(
                                iter
                                    .next()
                                    .expect(
                                        "The iter is guaranteed to be something due to the size check",
                                    ),
                            )?,
                            blockHash: ::ethers::core::abi::Tokenizable::from_token(
                                iter
                                    .next()
                                    .expect(
                                        "The iter is guaranteed to be something due to the size check",
                                    ),
                            )?,
                            network: ::ethers::core::abi::Tokenizable::from_token(
                                iter
                                    .next()
                                    .expect(
                                        "The iter is guaranteed to be something due to the size check",
                                    ),
                            )?,
                        })
                    } else {
                        Err(
                            ::ethers::core::abi::InvalidOutputType({
                                let res = ::alloc::fmt::format(
                                    format_args!("Expected Tuple, got {0:?}", token),
                                );
                                res
                            }),
                        )
                    }
                }
                fn into_token(self) -> ::ethers::core::abi::Token {
                    ::ethers::core::abi::Token::Tuple(
                        <[_]>::into_vec(
                            #[rustc_box]
                            ::alloc::boxed::Box::new([
                                self.fid.into_token(),
                                self.address.into_token(),
                                self.blockHash.into_token(),
                                self.network.into_token(),
                            ]),
                        ),
                    )
                }
            }
            impl ::ethers::core::abi::TokenizableItem for EIP712VerificationClaim
            where
                U256: ::ethers::core::abi::Tokenize,
                Address: ::ethers::core::abi::Tokenize,
                Bytes: ::ethers::core::abi::Tokenize,
                u8: ::ethers::core::abi::Tokenize,
            {}
            #[eip712(
                name = "Farcaster Verify Ethereum Address",
                version = "2.0.0",
                salt = "0xf2d857f4a3edcb9b78b4d503bfe733db1e3f6cdc2b7971ee739626c97e86a558"
            )]
            pub struct EIP712MessageData {
                pub hash: Bytes,
            }
            #[automatically_derived]
            impl ::core::clone::Clone for EIP712MessageData {
                #[inline]
                fn clone(&self) -> EIP712MessageData {
                    EIP712MessageData {
                        hash: ::core::clone::Clone::clone(&self.hash),
                    }
                }
            }
            #[automatically_derived]
            impl ::core::fmt::Debug for EIP712MessageData {
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    ::core::fmt::Formatter::debug_struct_field1_finish(
                        f,
                        "EIP712MessageData",
                        "hash",
                        &&self.hash,
                    )
                }
            }
            #[doc(hidden)]
            #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
            const _: () = {
                #[allow(unused_extern_crates, clippy::useless_attribute)]
                extern crate serde as _serde;
                #[automatically_derived]
                impl<'de> _serde::Deserialize<'de> for EIP712MessageData {
                    fn deserialize<__D>(
                        __deserializer: __D,
                    ) -> _serde::__private::Result<Self, __D::Error>
                    where
                        __D: _serde::Deserializer<'de>,
                    {
                        #[allow(non_camel_case_types)]
                        #[doc(hidden)]
                        enum __Field {
                            __field0,
                            __ignore,
                        }
                        #[doc(hidden)]
                        struct __FieldVisitor;
                        impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                            type Value = __Field;
                            fn expecting(
                                &self,
                                __formatter: &mut _serde::__private::Formatter,
                            ) -> _serde::__private::fmt::Result {
                                _serde::__private::Formatter::write_str(
                                    __formatter,
                                    "field identifier",
                                )
                            }
                            fn visit_u64<__E>(
                                self,
                                __value: u64,
                            ) -> _serde::__private::Result<Self::Value, __E>
                            where
                                __E: _serde::de::Error,
                            {
                                match __value {
                                    0u64 => _serde::__private::Ok(__Field::__field0),
                                    _ => _serde::__private::Ok(__Field::__ignore),
                                }
                            }
                            fn visit_str<__E>(
                                self,
                                __value: &str,
                            ) -> _serde::__private::Result<Self::Value, __E>
                            where
                                __E: _serde::de::Error,
                            {
                                match __value {
                                    "hash" => _serde::__private::Ok(__Field::__field0),
                                    _ => _serde::__private::Ok(__Field::__ignore),
                                }
                            }
                            fn visit_bytes<__E>(
                                self,
                                __value: &[u8],
                            ) -> _serde::__private::Result<Self::Value, __E>
                            where
                                __E: _serde::de::Error,
                            {
                                match __value {
                                    b"hash" => _serde::__private::Ok(__Field::__field0),
                                    _ => _serde::__private::Ok(__Field::__ignore),
                                }
                            }
                        }
                        impl<'de> _serde::Deserialize<'de> for __Field {
                            #[inline]
                            fn deserialize<__D>(
                                __deserializer: __D,
                            ) -> _serde::__private::Result<Self, __D::Error>
                            where
                                __D: _serde::Deserializer<'de>,
                            {
                                _serde::Deserializer::deserialize_identifier(
                                    __deserializer,
                                    __FieldVisitor,
                                )
                            }
                        }
                        #[doc(hidden)]
                        struct __Visitor<'de> {
                            marker: _serde::__private::PhantomData<EIP712MessageData>,
                            lifetime: _serde::__private::PhantomData<&'de ()>,
                        }
                        impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                            type Value = EIP712MessageData;
                            fn expecting(
                                &self,
                                __formatter: &mut _serde::__private::Formatter,
                            ) -> _serde::__private::fmt::Result {
                                _serde::__private::Formatter::write_str(
                                    __formatter,
                                    "struct EIP712MessageData",
                                )
                            }
                            #[inline]
                            fn visit_seq<__A>(
                                self,
                                mut __seq: __A,
                            ) -> _serde::__private::Result<Self::Value, __A::Error>
                            where
                                __A: _serde::de::SeqAccess<'de>,
                            {
                                let __field0 = match _serde::de::SeqAccess::next_element::<
                                    Bytes,
                                >(&mut __seq)? {
                                    _serde::__private::Some(__value) => __value,
                                    _serde::__private::None => {
                                        return _serde::__private::Err(
                                            _serde::de::Error::invalid_length(
                                                0usize,
                                                &"struct EIP712MessageData with 1 element",
                                            ),
                                        );
                                    }
                                };
                                _serde::__private::Ok(EIP712MessageData {
                                    hash: __field0,
                                })
                            }
                            #[inline]
                            fn visit_map<__A>(
                                self,
                                mut __map: __A,
                            ) -> _serde::__private::Result<Self::Value, __A::Error>
                            where
                                __A: _serde::de::MapAccess<'de>,
                            {
                                let mut __field0: _serde::__private::Option<Bytes> = _serde::__private::None;
                                while let _serde::__private::Some(__key)
                                    = _serde::de::MapAccess::next_key::<__Field>(&mut __map)? {
                                    match __key {
                                        __Field::__field0 => {
                                            if _serde::__private::Option::is_some(&__field0) {
                                                return _serde::__private::Err(
                                                    <__A::Error as _serde::de::Error>::duplicate_field("hash"),
                                                );
                                            }
                                            __field0 = _serde::__private::Some(
                                                _serde::de::MapAccess::next_value::<Bytes>(&mut __map)?,
                                            );
                                        }
                                        _ => {
                                            let _ = _serde::de::MapAccess::next_value::<
                                                _serde::de::IgnoredAny,
                                            >(&mut __map)?;
                                        }
                                    }
                                }
                                let __field0 = match __field0 {
                                    _serde::__private::Some(__field0) => __field0,
                                    _serde::__private::None => {
                                        _serde::__private::de::missing_field("hash")?
                                    }
                                };
                                _serde::__private::Ok(EIP712MessageData {
                                    hash: __field0,
                                })
                            }
                        }
                        #[doc(hidden)]
                        const FIELDS: &'static [&'static str] = &["hash"];
                        _serde::Deserializer::deserialize_struct(
                            __deserializer,
                            "EIP712MessageData",
                            FIELDS,
                            __Visitor {
                                marker: _serde::__private::PhantomData::<EIP712MessageData>,
                                lifetime: _serde::__private::PhantomData,
                            },
                        )
                    }
                }
            };
            impl ::ethers::core::types::transaction::eip712::Eip712
            for EIP712MessageData {
                type Error = ::ethers::core::types::transaction::eip712::Eip712Error;
                #[inline]
                fn type_hash() -> ::core::result::Result<[u8; 32], Self::Error> {
                    Ok([
                        239u8,
                        98u8,
                        38u8,
                        167u8,
                        33u8,
                        59u8,
                        93u8,
                        55u8,
                        194u8,
                        204u8,
                        124u8,
                        159u8,
                        122u8,
                        212u8,
                        105u8,
                        29u8,
                        17u8,
                        206u8,
                        20u8,
                        97u8,
                        134u8,
                        121u8,
                        196u8,
                        176u8,
                        244u8,
                        219u8,
                        225u8,
                        79u8,
                        227u8,
                        30u8,
                        224u8,
                        204u8,
                    ])
                }
                #[inline]
                fn domain_separator(
                    &self,
                ) -> ::core::result::Result<[u8; 32], Self::Error> {
                    Ok([
                        162u8,
                        122u8,
                        6u8,
                        14u8,
                        167u8,
                        169u8,
                        252u8,
                        173u8,
                        188u8,
                        17u8,
                        133u8,
                        157u8,
                        198u8,
                        226u8,
                        120u8,
                        126u8,
                        233u8,
                        163u8,
                        179u8,
                        1u8,
                        74u8,
                        81u8,
                        113u8,
                        59u8,
                        53u8,
                        147u8,
                        85u8,
                        76u8,
                        115u8,
                        37u8,
                        118u8,
                        53u8,
                    ])
                }
                fn domain(
                    &self,
                ) -> ::core::result::Result<
                    ::ethers::core::types::transaction::eip712::EIP712Domain,
                    Self::Error,
                > {
                    ::ethers::core::utils::__serde_json::from_str(
                            "{\"name\":\"Farcaster Verify Ethereum Address\",\"version\":\"2.0.0\",\"salt\":[149,140,54,235,57,218,127,158,177,218,156,20,9,149,29,196,136,196,35,243,52,195,26,220,229,91,57,150,82,153,25,46]}",
                        )
                        .map_err(::core::convert::Into::into)
                }
                fn struct_hash(&self) -> ::core::result::Result<[u8; 32], Self::Error> {
                    let mut items = <[_]>::into_vec(
                        #[rustc_box]
                        ::alloc::boxed::Box::new([
                            ::ethers::core::abi::Token::Uint(
                                ::ethers::core::types::U256::from(&Self::type_hash()?[..]),
                            ),
                        ]),
                    );
                    if let ::ethers::core::abi::Token::Tuple(tokens)
                        = ::ethers::core::abi::Tokenizable::into_token(
                            ::core::clone::Clone::clone(self),
                        ) {
                        items.reserve(tokens.len());
                        for token in tokens {
                            match &token {
                                ::ethers::core::abi::Token::Tuple(t) => {
                                    return Err(Self::Error::NestedEip712StructNotImplemented);
                                }
                                _ => {
                                    items
                                        .push(
                                            ::ethers::core::types::transaction::eip712::encode_eip712_type(
                                                token,
                                            ),
                                        );
                                }
                            }
                        }
                    }
                    let struct_hash = ::ethers::core::utils::keccak256(
                        ::ethers::core::abi::encode(&items),
                    );
                    Ok(struct_hash)
                }
            }
            impl ::ethers::core::abi::AbiType for EIP712MessageData {
                fn param_type() -> ::ethers::core::abi::ParamType {
                    ::ethers::core::abi::ParamType::Tuple(
                        <[_]>::into_vec(
                            #[rustc_box]
                            ::alloc::boxed::Box::new([
                                <Bytes as ::ethers::core::abi::AbiType>::param_type(),
                            ]),
                        ),
                    )
                }
            }
            impl ::ethers::core::abi::AbiArrayType for EIP712MessageData {}
            impl ::ethers::core::abi::Tokenizable for EIP712MessageData
            where
                Bytes: ::ethers::core::abi::Tokenize,
            {
                fn from_token(
                    token: ::ethers::core::abi::Token,
                ) -> ::core::result::Result<
                    Self,
                    ::ethers::core::abi::InvalidOutputType,
                > {
                    if let ::ethers::core::abi::Token::Tuple(tokens) = token {
                        if tokens.len() != 1usize {
                            return Err(
                                ::ethers::core::abi::InvalidOutputType({
                                    let res = ::alloc::fmt::format(
                                        format_args!(
                                            "Expected 1 tokens, got {0}: {1:?}",
                                            tokens.len(),
                                            tokens,
                                        ),
                                    );
                                    res
                                }),
                            );
                        }
                        let mut iter = tokens.into_iter();
                        Ok(Self {
                            hash: ::ethers::core::abi::Tokenizable::from_token(
                                iter
                                    .next()
                                    .expect(
                                        "The iter is guaranteed to be something due to the size check",
                                    ),
                            )?,
                        })
                    } else {
                        Err(
                            ::ethers::core::abi::InvalidOutputType({
                                let res = ::alloc::fmt::format(
                                    format_args!("Expected Tuple, got {0:?}", token),
                                );
                                res
                            }),
                        )
                    }
                }
                fn into_token(self) -> ::ethers::core::abi::Token {
                    ::ethers::core::abi::Token::Tuple(
                        <[_]>::into_vec(
                            #[rustc_box]
                            ::alloc::boxed::Box::new([self.hash.into_token()]),
                        ),
                    )
                }
            }
            impl ::ethers::core::abi::TokenizableItem for EIP712MessageData
            where
                Bytes: ::ethers::core::abi::Tokenize,
            {}
            #[eip712(
                name = "Farcaster name verification",
                version = "1",
                chain_id = 1,
                verifying_contract = "0xe3be01d99baa8db9905b33a3ca391238234b79d1"
            )]
            pub struct EIP712UsernameProof {
                pub name: String,
                #[serde(deserialize_with = "deserialize_u256_from_i64")]
                pub timestamp: U256,
                pub owner: Address,
            }
            #[automatically_derived]
            impl ::core::clone::Clone for EIP712UsernameProof {
                #[inline]
                fn clone(&self) -> EIP712UsernameProof {
                    EIP712UsernameProof {
                        name: ::core::clone::Clone::clone(&self.name),
                        timestamp: ::core::clone::Clone::clone(&self.timestamp),
                        owner: ::core::clone::Clone::clone(&self.owner),
                    }
                }
            }
            #[automatically_derived]
            impl ::core::fmt::Debug for EIP712UsernameProof {
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    ::core::fmt::Formatter::debug_struct_field3_finish(
                        f,
                        "EIP712UsernameProof",
                        "name",
                        &self.name,
                        "timestamp",
                        &self.timestamp,
                        "owner",
                        &&self.owner,
                    )
                }
            }
            #[doc(hidden)]
            #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
            const _: () = {
                #[allow(unused_extern_crates, clippy::useless_attribute)]
                extern crate serde as _serde;
                #[automatically_derived]
                impl<'de> _serde::Deserialize<'de> for EIP712UsernameProof {
                    fn deserialize<__D>(
                        __deserializer: __D,
                    ) -> _serde::__private::Result<Self, __D::Error>
                    where
                        __D: _serde::Deserializer<'de>,
                    {
                        #[allow(non_camel_case_types)]
                        #[doc(hidden)]
                        enum __Field {
                            __field0,
                            __field1,
                            __field2,
                            __ignore,
                        }
                        #[doc(hidden)]
                        struct __FieldVisitor;
                        impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                            type Value = __Field;
                            fn expecting(
                                &self,
                                __formatter: &mut _serde::__private::Formatter,
                            ) -> _serde::__private::fmt::Result {
                                _serde::__private::Formatter::write_str(
                                    __formatter,
                                    "field identifier",
                                )
                            }
                            fn visit_u64<__E>(
                                self,
                                __value: u64,
                            ) -> _serde::__private::Result<Self::Value, __E>
                            where
                                __E: _serde::de::Error,
                            {
                                match __value {
                                    0u64 => _serde::__private::Ok(__Field::__field0),
                                    1u64 => _serde::__private::Ok(__Field::__field1),
                                    2u64 => _serde::__private::Ok(__Field::__field2),
                                    _ => _serde::__private::Ok(__Field::__ignore),
                                }
                            }
                            fn visit_str<__E>(
                                self,
                                __value: &str,
                            ) -> _serde::__private::Result<Self::Value, __E>
                            where
                                __E: _serde::de::Error,
                            {
                                match __value {
                                    "name" => _serde::__private::Ok(__Field::__field0),
                                    "timestamp" => _serde::__private::Ok(__Field::__field1),
                                    "owner" => _serde::__private::Ok(__Field::__field2),
                                    _ => _serde::__private::Ok(__Field::__ignore),
                                }
                            }
                            fn visit_bytes<__E>(
                                self,
                                __value: &[u8],
                            ) -> _serde::__private::Result<Self::Value, __E>
                            where
                                __E: _serde::de::Error,
                            {
                                match __value {
                                    b"name" => _serde::__private::Ok(__Field::__field0),
                                    b"timestamp" => _serde::__private::Ok(__Field::__field1),
                                    b"owner" => _serde::__private::Ok(__Field::__field2),
                                    _ => _serde::__private::Ok(__Field::__ignore),
                                }
                            }
                        }
                        impl<'de> _serde::Deserialize<'de> for __Field {
                            #[inline]
                            fn deserialize<__D>(
                                __deserializer: __D,
                            ) -> _serde::__private::Result<Self, __D::Error>
                            where
                                __D: _serde::Deserializer<'de>,
                            {
                                _serde::Deserializer::deserialize_identifier(
                                    __deserializer,
                                    __FieldVisitor,
                                )
                            }
                        }
                        #[doc(hidden)]
                        struct __Visitor<'de> {
                            marker: _serde::__private::PhantomData<EIP712UsernameProof>,
                            lifetime: _serde::__private::PhantomData<&'de ()>,
                        }
                        impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                            type Value = EIP712UsernameProof;
                            fn expecting(
                                &self,
                                __formatter: &mut _serde::__private::Formatter,
                            ) -> _serde::__private::fmt::Result {
                                _serde::__private::Formatter::write_str(
                                    __formatter,
                                    "struct EIP712UsernameProof",
                                )
                            }
                            #[inline]
                            fn visit_seq<__A>(
                                self,
                                mut __seq: __A,
                            ) -> _serde::__private::Result<Self::Value, __A::Error>
                            where
                                __A: _serde::de::SeqAccess<'de>,
                            {
                                let __field0 = match _serde::de::SeqAccess::next_element::<
                                    String,
                                >(&mut __seq)? {
                                    _serde::__private::Some(__value) => __value,
                                    _serde::__private::None => {
                                        return _serde::__private::Err(
                                            _serde::de::Error::invalid_length(
                                                0usize,
                                                &"struct EIP712UsernameProof with 3 elements",
                                            ),
                                        );
                                    }
                                };
                                let __field1 = match {
                                    #[doc(hidden)]
                                    struct __DeserializeWith<'de> {
                                        value: U256,
                                        phantom: _serde::__private::PhantomData<
                                            EIP712UsernameProof,
                                        >,
                                        lifetime: _serde::__private::PhantomData<&'de ()>,
                                    }
                                    impl<'de> _serde::Deserialize<'de>
                                    for __DeserializeWith<'de> {
                                        fn deserialize<__D>(
                                            __deserializer: __D,
                                        ) -> _serde::__private::Result<Self, __D::Error>
                                        where
                                            __D: _serde::Deserializer<'de>,
                                        {
                                            _serde::__private::Ok(__DeserializeWith {
                                                value: deserialize_u256_from_i64(__deserializer)?,
                                                phantom: _serde::__private::PhantomData,
                                                lifetime: _serde::__private::PhantomData,
                                            })
                                        }
                                    }
                                    _serde::__private::Option::map(
                                        _serde::de::SeqAccess::next_element::<
                                            __DeserializeWith<'de>,
                                        >(&mut __seq)?,
                                        |__wrap| __wrap.value,
                                    )
                                } {
                                    _serde::__private::Some(__value) => __value,
                                    _serde::__private::None => {
                                        return _serde::__private::Err(
                                            _serde::de::Error::invalid_length(
                                                1usize,
                                                &"struct EIP712UsernameProof with 3 elements",
                                            ),
                                        );
                                    }
                                };
                                let __field2 = match _serde::de::SeqAccess::next_element::<
                                    Address,
                                >(&mut __seq)? {
                                    _serde::__private::Some(__value) => __value,
                                    _serde::__private::None => {
                                        return _serde::__private::Err(
                                            _serde::de::Error::invalid_length(
                                                2usize,
                                                &"struct EIP712UsernameProof with 3 elements",
                                            ),
                                        );
                                    }
                                };
                                _serde::__private::Ok(EIP712UsernameProof {
                                    name: __field0,
                                    timestamp: __field1,
                                    owner: __field2,
                                })
                            }
                            #[inline]
                            fn visit_map<__A>(
                                self,
                                mut __map: __A,
                            ) -> _serde::__private::Result<Self::Value, __A::Error>
                            where
                                __A: _serde::de::MapAccess<'de>,
                            {
                                let mut __field0: _serde::__private::Option<String> = _serde::__private::None;
                                let mut __field1: _serde::__private::Option<U256> = _serde::__private::None;
                                let mut __field2: _serde::__private::Option<Address> = _serde::__private::None;
                                while let _serde::__private::Some(__key)
                                    = _serde::de::MapAccess::next_key::<__Field>(&mut __map)? {
                                    match __key {
                                        __Field::__field0 => {
                                            if _serde::__private::Option::is_some(&__field0) {
                                                return _serde::__private::Err(
                                                    <__A::Error as _serde::de::Error>::duplicate_field("name"),
                                                );
                                            }
                                            __field0 = _serde::__private::Some(
                                                _serde::de::MapAccess::next_value::<String>(&mut __map)?,
                                            );
                                        }
                                        __Field::__field1 => {
                                            if _serde::__private::Option::is_some(&__field1) {
                                                return _serde::__private::Err(
                                                    <__A::Error as _serde::de::Error>::duplicate_field(
                                                        "timestamp",
                                                    ),
                                                );
                                            }
                                            __field1 = _serde::__private::Some({
                                                #[doc(hidden)]
                                                struct __DeserializeWith<'de> {
                                                    value: U256,
                                                    phantom: _serde::__private::PhantomData<
                                                        EIP712UsernameProof,
                                                    >,
                                                    lifetime: _serde::__private::PhantomData<&'de ()>,
                                                }
                                                impl<'de> _serde::Deserialize<'de>
                                                for __DeserializeWith<'de> {
                                                    fn deserialize<__D>(
                                                        __deserializer: __D,
                                                    ) -> _serde::__private::Result<Self, __D::Error>
                                                    where
                                                        __D: _serde::Deserializer<'de>,
                                                    {
                                                        _serde::__private::Ok(__DeserializeWith {
                                                            value: deserialize_u256_from_i64(__deserializer)?,
                                                            phantom: _serde::__private::PhantomData,
                                                            lifetime: _serde::__private::PhantomData,
                                                        })
                                                    }
                                                }
                                                match _serde::de::MapAccess::next_value::<
                                                    __DeserializeWith<'de>,
                                                >(&mut __map) {
                                                    _serde::__private::Ok(__wrapper) => __wrapper.value,
                                                    _serde::__private::Err(__err) => {
                                                        return _serde::__private::Err(__err);
                                                    }
                                                }
                                            });
                                        }
                                        __Field::__field2 => {
                                            if _serde::__private::Option::is_some(&__field2) {
                                                return _serde::__private::Err(
                                                    <__A::Error as _serde::de::Error>::duplicate_field("owner"),
                                                );
                                            }
                                            __field2 = _serde::__private::Some(
                                                _serde::de::MapAccess::next_value::<Address>(&mut __map)?,
                                            );
                                        }
                                        _ => {
                                            let _ = _serde::de::MapAccess::next_value::<
                                                _serde::de::IgnoredAny,
                                            >(&mut __map)?;
                                        }
                                    }
                                }
                                let __field0 = match __field0 {
                                    _serde::__private::Some(__field0) => __field0,
                                    _serde::__private::None => {
                                        _serde::__private::de::missing_field("name")?
                                    }
                                };
                                let __field1 = match __field1 {
                                    _serde::__private::Some(__field1) => __field1,
                                    _serde::__private::None => {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::missing_field(
                                                "timestamp",
                                            ),
                                        );
                                    }
                                };
                                let __field2 = match __field2 {
                                    _serde::__private::Some(__field2) => __field2,
                                    _serde::__private::None => {
                                        _serde::__private::de::missing_field("owner")?
                                    }
                                };
                                _serde::__private::Ok(EIP712UsernameProof {
                                    name: __field0,
                                    timestamp: __field1,
                                    owner: __field2,
                                })
                            }
                        }
                        #[doc(hidden)]
                        const FIELDS: &'static [&'static str] = &[
                            "name",
                            "timestamp",
                            "owner",
                        ];
                        _serde::Deserializer::deserialize_struct(
                            __deserializer,
                            "EIP712UsernameProof",
                            FIELDS,
                            __Visitor {
                                marker: _serde::__private::PhantomData::<
                                    EIP712UsernameProof,
                                >,
                                lifetime: _serde::__private::PhantomData,
                            },
                        )
                    }
                }
            };
            impl ::ethers::core::types::transaction::eip712::Eip712
            for EIP712UsernameProof {
                type Error = ::ethers::core::types::transaction::eip712::Eip712Error;
                #[inline]
                fn type_hash() -> ::core::result::Result<[u8; 32], Self::Error> {
                    Ok([
                        42u8,
                        26u8,
                        217u8,
                        224u8,
                        14u8,
                        217u8,
                        160u8,
                        38u8,
                        128u8,
                        212u8,
                        109u8,
                        64u8,
                        74u8,
                        154u8,
                        96u8,
                        42u8,
                        228u8,
                        186u8,
                        190u8,
                        41u8,
                        125u8,
                        60u8,
                        196u8,
                        254u8,
                        61u8,
                        145u8,
                        86u8,
                        80u8,
                        9u8,
                        75u8,
                        67u8,
                        40u8,
                    ])
                }
                #[inline]
                fn domain_separator(
                    &self,
                ) -> ::core::result::Result<[u8; 32], Self::Error> {
                    Ok([
                        230u8,
                        125u8,
                        1u8,
                        117u8,
                        195u8,
                        252u8,
                        37u8,
                        77u8,
                        250u8,
                        198u8,
                        124u8,
                        173u8,
                        21u8,
                        173u8,
                        39u8,
                        6u8,
                        33u8,
                        220u8,
                        218u8,
                        49u8,
                        82u8,
                        249u8,
                        187u8,
                        15u8,
                        109u8,
                        245u8,
                        187u8,
                        143u8,
                        14u8,
                        200u8,
                        78u8,
                        113u8,
                    ])
                }
                fn domain(
                    &self,
                ) -> ::core::result::Result<
                    ::ethers::core::types::transaction::eip712::EIP712Domain,
                    Self::Error,
                > {
                    ::ethers::core::utils::__serde_json::from_str(
                            "{\"name\":\"Farcaster name verification\",\"version\":\"1\",\"chainId\":\"0x1\",\"verifyingContract\":\"0xe3be01d99baa8db9905b33a3ca391238234b79d1\"}",
                        )
                        .map_err(::core::convert::Into::into)
                }
                fn struct_hash(&self) -> ::core::result::Result<[u8; 32], Self::Error> {
                    let mut items = <[_]>::into_vec(
                        #[rustc_box]
                        ::alloc::boxed::Box::new([
                            ::ethers::core::abi::Token::Uint(
                                ::ethers::core::types::U256::from(&Self::type_hash()?[..]),
                            ),
                        ]),
                    );
                    if let ::ethers::core::abi::Token::Tuple(tokens)
                        = ::ethers::core::abi::Tokenizable::into_token(
                            ::core::clone::Clone::clone(self),
                        ) {
                        items.reserve(tokens.len());
                        for token in tokens {
                            match &token {
                                ::ethers::core::abi::Token::Tuple(t) => {
                                    return Err(Self::Error::NestedEip712StructNotImplemented);
                                }
                                _ => {
                                    items
                                        .push(
                                            ::ethers::core::types::transaction::eip712::encode_eip712_type(
                                                token,
                                            ),
                                        );
                                }
                            }
                        }
                    }
                    let struct_hash = ::ethers::core::utils::keccak256(
                        ::ethers::core::abi::encode(&items),
                    );
                    Ok(struct_hash)
                }
            }
            impl ::ethers::core::abi::AbiType for EIP712UsernameProof {
                fn param_type() -> ::ethers::core::abi::ParamType {
                    ::ethers::core::abi::ParamType::Tuple(
                        <[_]>::into_vec(
                            #[rustc_box]
                            ::alloc::boxed::Box::new([
                                <String as ::ethers::core::abi::AbiType>::param_type(),
                                <U256 as ::ethers::core::abi::AbiType>::param_type(),
                                <Address as ::ethers::core::abi::AbiType>::param_type(),
                            ]),
                        ),
                    )
                }
            }
            impl ::ethers::core::abi::AbiArrayType for EIP712UsernameProof {}
            impl ::ethers::core::abi::Tokenizable for EIP712UsernameProof
            where
                String: ::ethers::core::abi::Tokenize,
                U256: ::ethers::core::abi::Tokenize,
                Address: ::ethers::core::abi::Tokenize,
            {
                fn from_token(
                    token: ::ethers::core::abi::Token,
                ) -> ::core::result::Result<
                    Self,
                    ::ethers::core::abi::InvalidOutputType,
                > {
                    if let ::ethers::core::abi::Token::Tuple(tokens) = token {
                        if tokens.len() != 3usize {
                            return Err(
                                ::ethers::core::abi::InvalidOutputType({
                                    let res = ::alloc::fmt::format(
                                        format_args!(
                                            "Expected 3 tokens, got {0}: {1:?}",
                                            tokens.len(),
                                            tokens,
                                        ),
                                    );
                                    res
                                }),
                            );
                        }
                        let mut iter = tokens.into_iter();
                        Ok(Self {
                            name: ::ethers::core::abi::Tokenizable::from_token(
                                iter
                                    .next()
                                    .expect(
                                        "The iter is guaranteed to be something due to the size check",
                                    ),
                            )?,
                            timestamp: ::ethers::core::abi::Tokenizable::from_token(
                                iter
                                    .next()
                                    .expect(
                                        "The iter is guaranteed to be something due to the size check",
                                    ),
                            )?,
                            owner: ::ethers::core::abi::Tokenizable::from_token(
                                iter
                                    .next()
                                    .expect(
                                        "The iter is guaranteed to be something due to the size check",
                                    ),
                            )?,
                        })
                    } else {
                        Err(
                            ::ethers::core::abi::InvalidOutputType({
                                let res = ::alloc::fmt::format(
                                    format_args!("Expected Tuple, got {0:?}", token),
                                );
                                res
                            }),
                        )
                    }
                }
                fn into_token(self) -> ::ethers::core::abi::Token {
                    ::ethers::core::abi::Token::Tuple(
                        <[_]>::into_vec(
                            #[rustc_box]
                            ::alloc::boxed::Box::new([
                                self.name.into_token(),
                                self.timestamp.into_token(),
                                self.owner.into_token(),
                            ]),
                        ),
                    )
                }
            }
            impl ::ethers::core::abi::TokenizableItem for EIP712UsernameProof
            where
                String: ::ethers::core::abi::Tokenize,
                U256: ::ethers::core::abi::Tokenize,
                Address: ::ethers::core::abi::Tokenize,
            {}
        }
    }
    pub mod errors {
        use thiserror::Error;
        pub enum BadRequestType {
            Generic,
            ParseFailure,
            InvalidParam,
            ValidationFailure,
            Duplicate,
            Conflict,
            Prunable,
        }
        #[automatically_derived]
        impl ::core::fmt::Debug for BadRequestType {
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                ::core::fmt::Formatter::write_str(
                    f,
                    match self {
                        BadRequestType::Generic => "Generic",
                        BadRequestType::ParseFailure => "ParseFailure",
                        BadRequestType::InvalidParam => "InvalidParam",
                        BadRequestType::ValidationFailure => "ValidationFailure",
                        BadRequestType::Duplicate => "Duplicate",
                        BadRequestType::Conflict => "Conflict",
                        BadRequestType::Prunable => "Prunable",
                    },
                )
            }
        }
        pub enum UnavailableType {
            Generic,
            NetworkFailure,
            StorageFailure,
        }
        #[automatically_derived]
        impl ::core::fmt::Debug for UnavailableType {
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                ::core::fmt::Formatter::write_str(
                    f,
                    match self {
                        UnavailableType::Generic => "Generic",
                        UnavailableType::NetworkFailure => "NetworkFailure",
                        UnavailableType::StorageFailure => "StorageFailure",
                    },
                )
            }
        }
        pub enum HubError {
            #[error("the request did not have valid authentication credentials {0:#?}")]
            Unauthenticated(String),
            #[error(
                "the authenticated request did not have the authority to perform this action {0:#?}"
            )]
            Unauthorized(String),
            #[error(
                "the request cannot be completed as constructed, do not retry (Type: {0:?}, Message: {1:#?})"
            )]
            BadRequest(BadRequestType, String),
            #[error("the requested resource could not be found {0:#?}")]
            NotFound(String),
            #[error(
                "the request could not be completed because the operation is not executable {0:#?}"
            )]
            NotImplemented(String),
            #[error(
                "the request could not be completed, it may or may not be safe to retry {0:?} {1:#?}"
            )]
            Unavailable(UnavailableType, String),
            #[error("an unknown error was encountered {0:#?}")]
            Unknown(String),
        }
        #[allow(unused_qualifications)]
        impl std::error::Error for HubError {}
        #[allow(unused_qualifications)]
        impl std::fmt::Display for HubError {
            fn fmt(&self, __formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                #[allow(unused_variables, deprecated, clippy::used_underscore_binding)]
                match self {
                    HubError::Unauthenticated(_0) => {
                        __formatter
                            .write_fmt(
                                format_args!(
                                    "the request did not have valid authentication credentials {0:#?}",
                                    _0,
                                ),
                            )
                    }
                    HubError::Unauthorized(_0) => {
                        __formatter
                            .write_fmt(
                                format_args!(
                                    "the authenticated request did not have the authority to perform this action {0:#?}",
                                    _0,
                                ),
                            )
                    }
                    HubError::BadRequest(_0, _1) => {
                        __formatter
                            .write_fmt(
                                format_args!(
                                    "the request cannot be completed as constructed, do not retry (Type: {0:?}, Message: {1:#?})",
                                    _0,
                                    _1,
                                ),
                            )
                    }
                    HubError::NotFound(_0) => {
                        __formatter
                            .write_fmt(
                                format_args!(
                                    "the requested resource could not be found {0:#?}",
                                    _0,
                                ),
                            )
                    }
                    HubError::NotImplemented(_0) => {
                        __formatter
                            .write_fmt(
                                format_args!(
                                    "the request could not be completed because the operation is not executable {0:#?}",
                                    _0,
                                ),
                            )
                    }
                    HubError::Unavailable(_0, _1) => {
                        __formatter
                            .write_fmt(
                                format_args!(
                                    "the request could not be completed, it may or may not be safe to retry {0:?} {1:#?}",
                                    _0,
                                    _1,
                                ),
                            )
                    }
                    HubError::Unknown(_0) => {
                        __formatter
                            .write_fmt(
                                format_args!("an unknown error was encountered {0:#?}", _0),
                            )
                    }
                }
            }
        }
        #[automatically_derived]
        impl ::core::fmt::Debug for HubError {
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                match self {
                    HubError::Unauthenticated(__self_0) => {
                        ::core::fmt::Formatter::debug_tuple_field1_finish(
                            f,
                            "Unauthenticated",
                            &__self_0,
                        )
                    }
                    HubError::Unauthorized(__self_0) => {
                        ::core::fmt::Formatter::debug_tuple_field1_finish(
                            f,
                            "Unauthorized",
                            &__self_0,
                        )
                    }
                    HubError::BadRequest(__self_0, __self_1) => {
                        ::core::fmt::Formatter::debug_tuple_field2_finish(
                            f,
                            "BadRequest",
                            __self_0,
                            &__self_1,
                        )
                    }
                    HubError::NotFound(__self_0) => {
                        ::core::fmt::Formatter::debug_tuple_field1_finish(
                            f,
                            "NotFound",
                            &__self_0,
                        )
                    }
                    HubError::NotImplemented(__self_0) => {
                        ::core::fmt::Formatter::debug_tuple_field1_finish(
                            f,
                            "NotImplemented",
                            &__self_0,
                        )
                    }
                    HubError::Unavailable(__self_0, __self_1) => {
                        ::core::fmt::Formatter::debug_tuple_field2_finish(
                            f,
                            "Unavailable",
                            __self_0,
                            &__self_1,
                        )
                    }
                    HubError::Unknown(__self_0) => {
                        ::core::fmt::Formatter::debug_tuple_field1_finish(
                            f,
                            "Unknown",
                            &__self_0,
                        )
                    }
                }
            }
        }
    }
    pub mod protobufs {
        pub mod generated {
            #[allow(clippy::derive_partial_eq_without_eq)]
            pub struct UserNameProof {
                #[prost(uint64, tag = "1")]
                pub timestamp: u64,
                #[prost(bytes = "vec", tag = "2")]
                pub name: ::prost::alloc::vec::Vec<u8>,
                #[prost(bytes = "vec", tag = "3")]
                pub owner: ::prost::alloc::vec::Vec<u8>,
                #[prost(bytes = "vec", tag = "4")]
                pub signature: ::prost::alloc::vec::Vec<u8>,
                #[prost(uint64, tag = "5")]
                pub fid: u64,
                #[prost(enumeration = "UserNameType", tag = "6")]
                pub r#type: i32,
            }
            #[automatically_derived]
            #[allow(clippy::derive_partial_eq_without_eq)]
            impl ::core::clone::Clone for UserNameProof {
                #[inline]
                fn clone(&self) -> UserNameProof {
                    UserNameProof {
                        timestamp: ::core::clone::Clone::clone(&self.timestamp),
                        name: ::core::clone::Clone::clone(&self.name),
                        owner: ::core::clone::Clone::clone(&self.owner),
                        signature: ::core::clone::Clone::clone(&self.signature),
                        fid: ::core::clone::Clone::clone(&self.fid),
                        r#type: ::core::clone::Clone::clone(&self.r#type),
                    }
                }
            }
            #[allow(clippy::derive_partial_eq_without_eq)]
            #[automatically_derived]
            impl ::core::marker::StructuralPartialEq for UserNameProof {}
            #[automatically_derived]
            #[allow(clippy::derive_partial_eq_without_eq)]
            impl ::core::cmp::PartialEq for UserNameProof {
                #[inline]
                fn eq(&self, other: &UserNameProof) -> bool {
                    self.timestamp == other.timestamp && self.name == other.name
                        && self.owner == other.owner && self.signature == other.signature
                        && self.fid == other.fid && self.r#type == other.r#type
                }
            }
            impl ::prost::Message for UserNameProof {
                #[allow(unused_variables)]
                fn encode_raw<B>(&self, buf: &mut B)
                where
                    B: ::prost::bytes::BufMut,
                {
                    if self.timestamp != 0u64 {
                        ::prost::encoding::uint64::encode(1u32, &self.timestamp, buf);
                    }
                    if self.name != b"" as &[u8] {
                        ::prost::encoding::bytes::encode(2u32, &self.name, buf);
                    }
                    if self.owner != b"" as &[u8] {
                        ::prost::encoding::bytes::encode(3u32, &self.owner, buf);
                    }
                    if self.signature != b"" as &[u8] {
                        ::prost::encoding::bytes::encode(4u32, &self.signature, buf);
                    }
                    if self.fid != 0u64 {
                        ::prost::encoding::uint64::encode(5u32, &self.fid, buf);
                    }
                    if self.r#type != UserNameType::default() as i32 {
                        ::prost::encoding::int32::encode(6u32, &self.r#type, buf);
                    }
                }
                #[allow(unused_variables)]
                fn merge_field<B>(
                    &mut self,
                    tag: u32,
                    wire_type: ::prost::encoding::WireType,
                    buf: &mut B,
                    ctx: ::prost::encoding::DecodeContext,
                ) -> ::core::result::Result<(), ::prost::DecodeError>
                where
                    B: ::prost::bytes::Buf,
                {
                    const STRUCT_NAME: &'static str = "UserNameProof";
                    match tag {
                        1u32 => {
                            let mut value = &mut self.timestamp;
                            ::prost::encoding::uint64::merge(wire_type, value, buf, ctx)
                                .map_err(|mut error| {
                                    error.push(STRUCT_NAME, "timestamp");
                                    error
                                })
                        }
                        2u32 => {
                            let mut value = &mut self.name;
                            ::prost::encoding::bytes::merge(wire_type, value, buf, ctx)
                                .map_err(|mut error| {
                                    error.push(STRUCT_NAME, "name");
                                    error
                                })
                        }
                        3u32 => {
                            let mut value = &mut self.owner;
                            ::prost::encoding::bytes::merge(wire_type, value, buf, ctx)
                                .map_err(|mut error| {
                                    error.push(STRUCT_NAME, "owner");
                                    error
                                })
                        }
                        4u32 => {
                            let mut value = &mut self.signature;
                            ::prost::encoding::bytes::merge(wire_type, value, buf, ctx)
                                .map_err(|mut error| {
                                    error.push(STRUCT_NAME, "signature");
                                    error
                                })
                        }
                        5u32 => {
                            let mut value = &mut self.fid;
                            ::prost::encoding::uint64::merge(wire_type, value, buf, ctx)
                                .map_err(|mut error| {
                                    error.push(STRUCT_NAME, "fid");
                                    error
                                })
                        }
                        6u32 => {
                            let mut value = &mut self.r#type;
                            ::prost::encoding::int32::merge(wire_type, value, buf, ctx)
                                .map_err(|mut error| {
                                    error.push(STRUCT_NAME, "r#type");
                                    error
                                })
                        }
                        _ => ::prost::encoding::skip_field(wire_type, tag, buf, ctx),
                    }
                }
                #[inline]
                fn encoded_len(&self) -> usize {
                    0
                        + if self.timestamp != 0u64 {
                            ::prost::encoding::uint64::encoded_len(1u32, &self.timestamp)
                        } else {
                            0
                        }
                        + if self.name != b"" as &[u8] {
                            ::prost::encoding::bytes::encoded_len(2u32, &self.name)
                        } else {
                            0
                        }
                        + if self.owner != b"" as &[u8] {
                            ::prost::encoding::bytes::encoded_len(3u32, &self.owner)
                        } else {
                            0
                        }
                        + if self.signature != b"" as &[u8] {
                            ::prost::encoding::bytes::encoded_len(4u32, &self.signature)
                        } else {
                            0
                        }
                        + if self.fid != 0u64 {
                            ::prost::encoding::uint64::encoded_len(5u32, &self.fid)
                        } else {
                            0
                        }
                        + if self.r#type != UserNameType::default() as i32 {
                            ::prost::encoding::int32::encoded_len(6u32, &self.r#type)
                        } else {
                            0
                        }
                }
                fn clear(&mut self) {
                    self.timestamp = 0u64;
                    self.name.clear();
                    self.owner.clear();
                    self.signature.clear();
                    self.fid = 0u64;
                    self.r#type = UserNameType::default() as i32;
                }
            }
            impl ::core::default::Default for UserNameProof {
                fn default() -> Self {
                    UserNameProof {
                        timestamp: 0u64,
                        name: ::core::default::Default::default(),
                        owner: ::core::default::Default::default(),
                        signature: ::core::default::Default::default(),
                        fid: 0u64,
                        r#type: UserNameType::default() as i32,
                    }
                }
            }
            impl ::core::fmt::Debug for UserNameProof {
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    let mut builder = f.debug_struct("UserNameProof");
                    let builder = {
                        let wrapper = {
                            fn ScalarWrapper<T>(v: T) -> T {
                                v
                            }
                            ScalarWrapper(&self.timestamp)
                        };
                        builder.field("timestamp", &wrapper)
                    };
                    let builder = {
                        let wrapper = {
                            fn ScalarWrapper<T>(v: T) -> T {
                                v
                            }
                            ScalarWrapper(&self.name)
                        };
                        builder.field("name", &wrapper)
                    };
                    let builder = {
                        let wrapper = {
                            fn ScalarWrapper<T>(v: T) -> T {
                                v
                            }
                            ScalarWrapper(&self.owner)
                        };
                        builder.field("owner", &wrapper)
                    };
                    let builder = {
                        let wrapper = {
                            fn ScalarWrapper<T>(v: T) -> T {
                                v
                            }
                            ScalarWrapper(&self.signature)
                        };
                        builder.field("signature", &wrapper)
                    };
                    let builder = {
                        let wrapper = {
                            fn ScalarWrapper<T>(v: T) -> T {
                                v
                            }
                            ScalarWrapper(&self.fid)
                        };
                        builder.field("fid", &wrapper)
                    };
                    let builder = {
                        let wrapper = {
                            struct ScalarWrapper<'a>(&'a i32);
                            impl<'a> ::core::fmt::Debug for ScalarWrapper<'a> {
                                fn fmt(
                                    &self,
                                    f: &mut ::core::fmt::Formatter,
                                ) -> ::core::fmt::Result {
                                    match UserNameType::from_i32(*self.0) {
                                        None => ::core::fmt::Debug::fmt(&self.0, f),
                                        Some(en) => ::core::fmt::Debug::fmt(&en, f),
                                    }
                                }
                            }
                            ScalarWrapper(&self.r#type)
                        };
                        builder.field("r#type", &wrapper)
                    };
                    builder.finish()
                }
            }
            #[allow(dead_code)]
            impl UserNameProof {
                ///Returns the enum value of `type`, or the default if the field is set to an invalid enum value.
                pub fn r#type(&self) -> UserNameType {
                    UserNameType::from_i32(self.r#type)
                        .unwrap_or(UserNameType::default())
                }
                ///Sets `type` to the provided enum value.
                pub fn set_type(&mut self, value: UserNameType) {
                    self.r#type = value as i32;
                }
            }
            #[repr(i32)]
            pub enum UserNameType {
                UsernameTypeNone = 0,
                UsernameTypeFname = 1,
                UsernameTypeEnsL1 = 2,
            }
            #[automatically_derived]
            impl ::core::clone::Clone for UserNameType {
                #[inline]
                fn clone(&self) -> UserNameType {
                    *self
                }
            }
            #[automatically_derived]
            impl ::core::marker::Copy for UserNameType {}
            #[automatically_derived]
            impl ::core::fmt::Debug for UserNameType {
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    ::core::fmt::Formatter::write_str(
                        f,
                        match self {
                            UserNameType::UsernameTypeNone => "UsernameTypeNone",
                            UserNameType::UsernameTypeFname => "UsernameTypeFname",
                            UserNameType::UsernameTypeEnsL1 => "UsernameTypeEnsL1",
                        },
                    )
                }
            }
            #[automatically_derived]
            impl ::core::marker::StructuralPartialEq for UserNameType {}
            #[automatically_derived]
            impl ::core::cmp::PartialEq for UserNameType {
                #[inline]
                fn eq(&self, other: &UserNameType) -> bool {
                    let __self_tag = ::core::intrinsics::discriminant_value(self);
                    let __arg1_tag = ::core::intrinsics::discriminant_value(other);
                    __self_tag == __arg1_tag
                }
            }
            #[automatically_derived]
            impl ::core::marker::StructuralEq for UserNameType {}
            #[automatically_derived]
            impl ::core::cmp::Eq for UserNameType {
                #[inline]
                #[doc(hidden)]
                #[no_coverage]
                fn assert_receiver_is_total_eq(&self) -> () {}
            }
            #[automatically_derived]
            impl ::core::hash::Hash for UserNameType {
                fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {
                    let __self_tag = ::core::intrinsics::discriminant_value(self);
                    ::core::hash::Hash::hash(&__self_tag, state)
                }
            }
            #[automatically_derived]
            impl ::core::cmp::PartialOrd for UserNameType {
                #[inline]
                fn partial_cmp(
                    &self,
                    other: &UserNameType,
                ) -> ::core::option::Option<::core::cmp::Ordering> {
                    let __self_tag = ::core::intrinsics::discriminant_value(self);
                    let __arg1_tag = ::core::intrinsics::discriminant_value(other);
                    ::core::cmp::PartialOrd::partial_cmp(&__self_tag, &__arg1_tag)
                }
            }
            #[automatically_derived]
            impl ::core::cmp::Ord for UserNameType {
                #[inline]
                fn cmp(&self, other: &UserNameType) -> ::core::cmp::Ordering {
                    let __self_tag = ::core::intrinsics::discriminant_value(self);
                    let __arg1_tag = ::core::intrinsics::discriminant_value(other);
                    ::core::cmp::Ord::cmp(&__self_tag, &__arg1_tag)
                }
            }
            impl UserNameType {
                ///Returns `true` if `value` is a variant of `UserNameType`.
                pub fn is_valid(value: i32) -> bool {
                    match value {
                        0 => true,
                        1 => true,
                        2 => true,
                        _ => false,
                    }
                }
                ///Converts an `i32` to a `UserNameType`, or `None` if `value` is not a valid variant.
                pub fn from_i32(value: i32) -> ::core::option::Option<UserNameType> {
                    match value {
                        0 => ::core::option::Option::Some(UserNameType::UsernameTypeNone),
                        1 => {
                            ::core::option::Option::Some(UserNameType::UsernameTypeFname)
                        }
                        2 => {
                            ::core::option::Option::Some(UserNameType::UsernameTypeEnsL1)
                        }
                        _ => ::core::option::Option::None,
                    }
                }
            }
            impl ::core::default::Default for UserNameType {
                fn default() -> UserNameType {
                    UserNameType::UsernameTypeNone
                }
            }
            impl ::core::convert::From<UserNameType> for i32 {
                fn from(value: UserNameType) -> i32 {
                    value as i32
                }
            }
            impl UserNameType {
                /// String value of the enum field names used in the ProtoBuf definition.
                ///
                /// The values are not transformed in any way and thus are considered stable
                /// (if the ProtoBuf definition does not change) and safe for programmatic use.
                pub fn as_str_name(&self) -> &'static str {
                    match self {
                        UserNameType::UsernameTypeNone => "USERNAME_TYPE_NONE",
                        UserNameType::UsernameTypeFname => "USERNAME_TYPE_FNAME",
                        UserNameType::UsernameTypeEnsL1 => "USERNAME_TYPE_ENS_L1",
                    }
                }
                /// Creates an enum from field names used in the ProtoBuf definition.
                pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
                    match value {
                        "USERNAME_TYPE_NONE" => Some(Self::UsernameTypeNone),
                        "USERNAME_TYPE_FNAME" => Some(Self::UsernameTypeFname),
                        "USERNAME_TYPE_ENS_L1" => Some(Self::UsernameTypeEnsL1),
                        _ => None,
                    }
                }
            }
            /// *
            /// A Message is a delta operation on the Farcaster network. The message protobuf is an envelope
            /// that wraps a MessageData object and contains a hash and signature which can verify its authenticity.
            #[allow(clippy::derive_partial_eq_without_eq)]
            pub struct Message {
                /// Contents of the message
                #[prost(message, optional, tag = "1")]
                pub data: ::core::option::Option<MessageData>,
                /// Hash digest of data
                #[prost(bytes = "vec", tag = "2")]
                pub hash: ::prost::alloc::vec::Vec<u8>,
                /// Hash scheme that produced the hash digest
                #[prost(enumeration = "HashScheme", tag = "3")]
                pub hash_scheme: i32,
                /// Signature of the hash digest
                #[prost(bytes = "vec", tag = "4")]
                pub signature: ::prost::alloc::vec::Vec<u8>,
                /// Signature scheme that produced the signature
                #[prost(enumeration = "SignatureScheme", tag = "5")]
                pub signature_scheme: i32,
                /// Public key or address of the key pair that produced the signature
                #[prost(bytes = "vec", tag = "6")]
                pub signer: ::prost::alloc::vec::Vec<u8>,
            }
            #[automatically_derived]
            #[allow(clippy::derive_partial_eq_without_eq)]
            impl ::core::clone::Clone for Message {
                #[inline]
                fn clone(&self) -> Message {
                    Message {
                        data: ::core::clone::Clone::clone(&self.data),
                        hash: ::core::clone::Clone::clone(&self.hash),
                        hash_scheme: ::core::clone::Clone::clone(&self.hash_scheme),
                        signature: ::core::clone::Clone::clone(&self.signature),
                        signature_scheme: ::core::clone::Clone::clone(
                            &self.signature_scheme,
                        ),
                        signer: ::core::clone::Clone::clone(&self.signer),
                    }
                }
            }
            #[allow(clippy::derive_partial_eq_without_eq)]
            #[automatically_derived]
            impl ::core::marker::StructuralPartialEq for Message {}
            #[automatically_derived]
            #[allow(clippy::derive_partial_eq_without_eq)]
            impl ::core::cmp::PartialEq for Message {
                #[inline]
                fn eq(&self, other: &Message) -> bool {
                    self.data == other.data && self.hash == other.hash
                        && self.hash_scheme == other.hash_scheme
                        && self.signature == other.signature
                        && self.signature_scheme == other.signature_scheme
                        && self.signer == other.signer
                }
            }
            impl ::prost::Message for Message {
                #[allow(unused_variables)]
                fn encode_raw<B>(&self, buf: &mut B)
                where
                    B: ::prost::bytes::BufMut,
                {
                    if let Some(ref msg) = self.data {
                        ::prost::encoding::message::encode(1u32, msg, buf);
                    }
                    if self.hash != b"" as &[u8] {
                        ::prost::encoding::bytes::encode(2u32, &self.hash, buf);
                    }
                    if self.hash_scheme != HashScheme::default() as i32 {
                        ::prost::encoding::int32::encode(3u32, &self.hash_scheme, buf);
                    }
                    if self.signature != b"" as &[u8] {
                        ::prost::encoding::bytes::encode(4u32, &self.signature, buf);
                    }
                    if self.signature_scheme != SignatureScheme::default() as i32 {
                        ::prost::encoding::int32::encode(
                            5u32,
                            &self.signature_scheme,
                            buf,
                        );
                    }
                    if self.signer != b"" as &[u8] {
                        ::prost::encoding::bytes::encode(6u32, &self.signer, buf);
                    }
                }
                #[allow(unused_variables)]
                fn merge_field<B>(
                    &mut self,
                    tag: u32,
                    wire_type: ::prost::encoding::WireType,
                    buf: &mut B,
                    ctx: ::prost::encoding::DecodeContext,
                ) -> ::core::result::Result<(), ::prost::DecodeError>
                where
                    B: ::prost::bytes::Buf,
                {
                    const STRUCT_NAME: &'static str = "Message";
                    match tag {
                        1u32 => {
                            let mut value = &mut self.data;
                            ::prost::encoding::message::merge(
                                    wire_type,
                                    value.get_or_insert_with(::core::default::Default::default),
                                    buf,
                                    ctx,
                                )
                                .map_err(|mut error| {
                                    error.push(STRUCT_NAME, "data");
                                    error
                                })
                        }
                        2u32 => {
                            let mut value = &mut self.hash;
                            ::prost::encoding::bytes::merge(wire_type, value, buf, ctx)
                                .map_err(|mut error| {
                                    error.push(STRUCT_NAME, "hash");
                                    error
                                })
                        }
                        3u32 => {
                            let mut value = &mut self.hash_scheme;
                            ::prost::encoding::int32::merge(wire_type, value, buf, ctx)
                                .map_err(|mut error| {
                                    error.push(STRUCT_NAME, "hash_scheme");
                                    error
                                })
                        }
                        4u32 => {
                            let mut value = &mut self.signature;
                            ::prost::encoding::bytes::merge(wire_type, value, buf, ctx)
                                .map_err(|mut error| {
                                    error.push(STRUCT_NAME, "signature");
                                    error
                                })
                        }
                        5u32 => {
                            let mut value = &mut self.signature_scheme;
                            ::prost::encoding::int32::merge(wire_type, value, buf, ctx)
                                .map_err(|mut error| {
                                    error.push(STRUCT_NAME, "signature_scheme");
                                    error
                                })
                        }
                        6u32 => {
                            let mut value = &mut self.signer;
                            ::prost::encoding::bytes::merge(wire_type, value, buf, ctx)
                                .map_err(|mut error| {
                                    error.push(STRUCT_NAME, "signer");
                                    error
                                })
                        }
                        _ => ::prost::encoding::skip_field(wire_type, tag, buf, ctx),
                    }
                }
                #[inline]
                fn encoded_len(&self) -> usize {
                    0
                        + self
                            .data
                            .as_ref()
                            .map_or(
                                0,
                                |msg| ::prost::encoding::message::encoded_len(1u32, msg),
                            )
                        + if self.hash != b"" as &[u8] {
                            ::prost::encoding::bytes::encoded_len(2u32, &self.hash)
                        } else {
                            0
                        }
                        + if self.hash_scheme != HashScheme::default() as i32 {
                            ::prost::encoding::int32::encoded_len(
                                3u32,
                                &self.hash_scheme,
                            )
                        } else {
                            0
                        }
                        + if self.signature != b"" as &[u8] {
                            ::prost::encoding::bytes::encoded_len(4u32, &self.signature)
                        } else {
                            0
                        }
                        + if self.signature_scheme != SignatureScheme::default() as i32 {
                            ::prost::encoding::int32::encoded_len(
                                5u32,
                                &self.signature_scheme,
                            )
                        } else {
                            0
                        }
                        + if self.signer != b"" as &[u8] {
                            ::prost::encoding::bytes::encoded_len(6u32, &self.signer)
                        } else {
                            0
                        }
                }
                fn clear(&mut self) {
                    self.data = ::core::option::Option::None;
                    self.hash.clear();
                    self.hash_scheme = HashScheme::default() as i32;
                    self.signature.clear();
                    self.signature_scheme = SignatureScheme::default() as i32;
                    self.signer.clear();
                }
            }
            impl ::core::default::Default for Message {
                fn default() -> Self {
                    Message {
                        data: ::core::default::Default::default(),
                        hash: ::core::default::Default::default(),
                        hash_scheme: HashScheme::default() as i32,
                        signature: ::core::default::Default::default(),
                        signature_scheme: SignatureScheme::default() as i32,
                        signer: ::core::default::Default::default(),
                    }
                }
            }
            impl ::core::fmt::Debug for Message {
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    let mut builder = f.debug_struct("Message");
                    let builder = {
                        let wrapper = &self.data;
                        builder.field("data", &wrapper)
                    };
                    let builder = {
                        let wrapper = {
                            fn ScalarWrapper<T>(v: T) -> T {
                                v
                            }
                            ScalarWrapper(&self.hash)
                        };
                        builder.field("hash", &wrapper)
                    };
                    let builder = {
                        let wrapper = {
                            struct ScalarWrapper<'a>(&'a i32);
                            impl<'a> ::core::fmt::Debug for ScalarWrapper<'a> {
                                fn fmt(
                                    &self,
                                    f: &mut ::core::fmt::Formatter,
                                ) -> ::core::fmt::Result {
                                    match HashScheme::from_i32(*self.0) {
                                        None => ::core::fmt::Debug::fmt(&self.0, f),
                                        Some(en) => ::core::fmt::Debug::fmt(&en, f),
                                    }
                                }
                            }
                            ScalarWrapper(&self.hash_scheme)
                        };
                        builder.field("hash_scheme", &wrapper)
                    };
                    let builder = {
                        let wrapper = {
                            fn ScalarWrapper<T>(v: T) -> T {
                                v
                            }
                            ScalarWrapper(&self.signature)
                        };
                        builder.field("signature", &wrapper)
                    };
                    let builder = {
                        let wrapper = {
                            struct ScalarWrapper<'a>(&'a i32);
                            impl<'a> ::core::fmt::Debug for ScalarWrapper<'a> {
                                fn fmt(
                                    &self,
                                    f: &mut ::core::fmt::Formatter,
                                ) -> ::core::fmt::Result {
                                    match SignatureScheme::from_i32(*self.0) {
                                        None => ::core::fmt::Debug::fmt(&self.0, f),
                                        Some(en) => ::core::fmt::Debug::fmt(&en, f),
                                    }
                                }
                            }
                            ScalarWrapper(&self.signature_scheme)
                        };
                        builder.field("signature_scheme", &wrapper)
                    };
                    let builder = {
                        let wrapper = {
                            fn ScalarWrapper<T>(v: T) -> T {
                                v
                            }
                            ScalarWrapper(&self.signer)
                        };
                        builder.field("signer", &wrapper)
                    };
                    builder.finish()
                }
            }
            #[allow(dead_code)]
            impl Message {
                ///Returns the enum value of `hash_scheme`, or the default if the field is set to an invalid enum value.
                pub fn hash_scheme(&self) -> HashScheme {
                    HashScheme::from_i32(self.hash_scheme)
                        .unwrap_or(HashScheme::default())
                }
                ///Sets `hash_scheme` to the provided enum value.
                pub fn set_hash_scheme(&mut self, value: HashScheme) {
                    self.hash_scheme = value as i32;
                }
                ///Returns the enum value of `signature_scheme`, or the default if the field is set to an invalid enum value.
                pub fn signature_scheme(&self) -> SignatureScheme {
                    SignatureScheme::from_i32(self.signature_scheme)
                        .unwrap_or(SignatureScheme::default())
                }
                ///Sets `signature_scheme` to the provided enum value.
                pub fn set_signature_scheme(&mut self, value: SignatureScheme) {
                    self.signature_scheme = value as i32;
                }
            }
            /// *
            /// A MessageData object contains properties common to all messages and wraps a body object which
            /// contains properties specific to the MessageType.
            #[allow(clippy::derive_partial_eq_without_eq)]
            pub struct MessageData {
                /// Type of message contained in the body
                #[prost(enumeration = "MessageType", tag = "1")]
                pub r#type: i32,
                /// Farcaster ID of the user producing the message
                #[prost(uint64, tag = "2")]
                pub fid: u64,
                /// Farcaster epoch timestamp in seconds
                #[prost(uint32, tag = "3")]
                pub timestamp: u32,
                /// Farcaster network the message is intended for
                #[prost(enumeration = "FarcasterNetwork", tag = "4")]
                pub network: i32,
                #[prost(
                    oneof = "message_data::Body",
                    tags = "5, 6, 7, 9, 10, 11, 12, 13, 14, 15"
                )]
                pub body: ::core::option::Option<message_data::Body>,
            }
            #[automatically_derived]
            #[allow(clippy::derive_partial_eq_without_eq)]
            impl ::core::clone::Clone for MessageData {
                #[inline]
                fn clone(&self) -> MessageData {
                    MessageData {
                        r#type: ::core::clone::Clone::clone(&self.r#type),
                        fid: ::core::clone::Clone::clone(&self.fid),
                        timestamp: ::core::clone::Clone::clone(&self.timestamp),
                        network: ::core::clone::Clone::clone(&self.network),
                        body: ::core::clone::Clone::clone(&self.body),
                    }
                }
            }
            #[allow(clippy::derive_partial_eq_without_eq)]
            #[automatically_derived]
            impl ::core::marker::StructuralPartialEq for MessageData {}
            #[automatically_derived]
            #[allow(clippy::derive_partial_eq_without_eq)]
            impl ::core::cmp::PartialEq for MessageData {
                #[inline]
                fn eq(&self, other: &MessageData) -> bool {
                    self.r#type == other.r#type && self.fid == other.fid
                        && self.timestamp == other.timestamp
                        && self.network == other.network && self.body == other.body
                }
            }
            impl ::prost::Message for MessageData {
                #[allow(unused_variables)]
                fn encode_raw<B>(&self, buf: &mut B)
                where
                    B: ::prost::bytes::BufMut,
                {
                    if self.r#type != MessageType::default() as i32 {
                        ::prost::encoding::int32::encode(1u32, &self.r#type, buf);
                    }
                    if self.fid != 0u64 {
                        ::prost::encoding::uint64::encode(2u32, &self.fid, buf);
                    }
                    if self.timestamp != 0u32 {
                        ::prost::encoding::uint32::encode(3u32, &self.timestamp, buf);
                    }
                    if self.network != FarcasterNetwork::default() as i32 {
                        ::prost::encoding::int32::encode(4u32, &self.network, buf);
                    }
                    if let Some(ref oneof) = self.body {
                        oneof.encode(buf)
                    }
                }
                #[allow(unused_variables)]
                fn merge_field<B>(
                    &mut self,
                    tag: u32,
                    wire_type: ::prost::encoding::WireType,
                    buf: &mut B,
                    ctx: ::prost::encoding::DecodeContext,
                ) -> ::core::result::Result<(), ::prost::DecodeError>
                where
                    B: ::prost::bytes::Buf,
                {
                    const STRUCT_NAME: &'static str = "MessageData";
                    match tag {
                        1u32 => {
                            let mut value = &mut self.r#type;
                            ::prost::encoding::int32::merge(wire_type, value, buf, ctx)
                                .map_err(|mut error| {
                                    error.push(STRUCT_NAME, "r#type");
                                    error
                                })
                        }
                        2u32 => {
                            let mut value = &mut self.fid;
                            ::prost::encoding::uint64::merge(wire_type, value, buf, ctx)
                                .map_err(|mut error| {
                                    error.push(STRUCT_NAME, "fid");
                                    error
                                })
                        }
                        3u32 => {
                            let mut value = &mut self.timestamp;
                            ::prost::encoding::uint32::merge(wire_type, value, buf, ctx)
                                .map_err(|mut error| {
                                    error.push(STRUCT_NAME, "timestamp");
                                    error
                                })
                        }
                        4u32 => {
                            let mut value = &mut self.network;
                            ::prost::encoding::int32::merge(wire_type, value, buf, ctx)
                                .map_err(|mut error| {
                                    error.push(STRUCT_NAME, "network");
                                    error
                                })
                        }
                        5u32 | 6u32 | 7u32 | 9u32 | 10u32 | 11u32 | 12u32 | 13u32 | 14u32
                        | 15u32 => {
                            let mut value = &mut self.body;
                            message_data::Body::merge(value, tag, wire_type, buf, ctx)
                                .map_err(|mut error| {
                                    error.push(STRUCT_NAME, "body");
                                    error
                                })
                        }
                        _ => ::prost::encoding::skip_field(wire_type, tag, buf, ctx),
                    }
                }
                #[inline]
                fn encoded_len(&self) -> usize {
                    0
                        + if self.r#type != MessageType::default() as i32 {
                            ::prost::encoding::int32::encoded_len(1u32, &self.r#type)
                        } else {
                            0
                        }
                        + if self.fid != 0u64 {
                            ::prost::encoding::uint64::encoded_len(2u32, &self.fid)
                        } else {
                            0
                        }
                        + if self.timestamp != 0u32 {
                            ::prost::encoding::uint32::encoded_len(3u32, &self.timestamp)
                        } else {
                            0
                        }
                        + if self.network != FarcasterNetwork::default() as i32 {
                            ::prost::encoding::int32::encoded_len(4u32, &self.network)
                        } else {
                            0
                        } + self.body.as_ref().map_or(0, message_data::Body::encoded_len)
                }
                fn clear(&mut self) {
                    self.r#type = MessageType::default() as i32;
                    self.fid = 0u64;
                    self.timestamp = 0u32;
                    self.network = FarcasterNetwork::default() as i32;
                    self.body = ::core::option::Option::None;
                }
            }
            impl ::core::default::Default for MessageData {
                fn default() -> Self {
                    MessageData {
                        r#type: MessageType::default() as i32,
                        fid: 0u64,
                        timestamp: 0u32,
                        network: FarcasterNetwork::default() as i32,
                        body: ::core::default::Default::default(),
                    }
                }
            }
            impl ::core::fmt::Debug for MessageData {
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    let mut builder = f.debug_struct("MessageData");
                    let builder = {
                        let wrapper = {
                            struct ScalarWrapper<'a>(&'a i32);
                            impl<'a> ::core::fmt::Debug for ScalarWrapper<'a> {
                                fn fmt(
                                    &self,
                                    f: &mut ::core::fmt::Formatter,
                                ) -> ::core::fmt::Result {
                                    match MessageType::from_i32(*self.0) {
                                        None => ::core::fmt::Debug::fmt(&self.0, f),
                                        Some(en) => ::core::fmt::Debug::fmt(&en, f),
                                    }
                                }
                            }
                            ScalarWrapper(&self.r#type)
                        };
                        builder.field("r#type", &wrapper)
                    };
                    let builder = {
                        let wrapper = {
                            fn ScalarWrapper<T>(v: T) -> T {
                                v
                            }
                            ScalarWrapper(&self.fid)
                        };
                        builder.field("fid", &wrapper)
                    };
                    let builder = {
                        let wrapper = {
                            fn ScalarWrapper<T>(v: T) -> T {
                                v
                            }
                            ScalarWrapper(&self.timestamp)
                        };
                        builder.field("timestamp", &wrapper)
                    };
                    let builder = {
                        let wrapper = {
                            struct ScalarWrapper<'a>(&'a i32);
                            impl<'a> ::core::fmt::Debug for ScalarWrapper<'a> {
                                fn fmt(
                                    &self,
                                    f: &mut ::core::fmt::Formatter,
                                ) -> ::core::fmt::Result {
                                    match FarcasterNetwork::from_i32(*self.0) {
                                        None => ::core::fmt::Debug::fmt(&self.0, f),
                                        Some(en) => ::core::fmt::Debug::fmt(&en, f),
                                    }
                                }
                            }
                            ScalarWrapper(&self.network)
                        };
                        builder.field("network", &wrapper)
                    };
                    let builder = {
                        let wrapper = &self.body;
                        builder.field("body", &wrapper)
                    };
                    builder.finish()
                }
            }
            #[allow(dead_code)]
            impl MessageData {
                ///Returns the enum value of `type`, or the default if the field is set to an invalid enum value.
                pub fn r#type(&self) -> MessageType {
                    MessageType::from_i32(self.r#type).unwrap_or(MessageType::default())
                }
                ///Sets `type` to the provided enum value.
                pub fn set_type(&mut self, value: MessageType) {
                    self.r#type = value as i32;
                }
                ///Returns the enum value of `network`, or the default if the field is set to an invalid enum value.
                pub fn network(&self) -> FarcasterNetwork {
                    FarcasterNetwork::from_i32(self.network)
                        .unwrap_or(FarcasterNetwork::default())
                }
                ///Sets `network` to the provided enum value.
                pub fn set_network(&mut self, value: FarcasterNetwork) {
                    self.network = value as i32;
                }
            }
            /// Nested message and enum types in `MessageData`.
            pub mod message_data {
                #[allow(clippy::derive_partial_eq_without_eq)]
                pub enum Body {
                    #[prost(message, tag = "5")]
                    CastAddBody(super::CastAddBody),
                    #[prost(message, tag = "6")]
                    CastRemoveBody(super::CastRemoveBody),
                    #[prost(message, tag = "7")]
                    ReactionBody(super::ReactionBody),
                    #[prost(message, tag = "9")]
                    VerificationAddEthAddressBody(super::VerificationAddEthAddressBody),
                    #[prost(message, tag = "10")]
                    VerificationRemoveBody(super::VerificationRemoveBody),
                    #[prost(message, tag = "11")]
                    SignerAddBody(super::SignerAddBody),
                    #[prost(message, tag = "12")]
                    UserDataBody(super::UserDataBody),
                    #[prost(message, tag = "13")]
                    SignerRemoveBody(super::SignerRemoveBody),
                    #[prost(message, tag = "14")]
                    LinkBody(super::LinkBody),
                    #[prost(message, tag = "15")]
                    UsernameProofBody(super::UserNameProof),
                }
                #[automatically_derived]
                #[allow(clippy::derive_partial_eq_without_eq)]
                impl ::core::clone::Clone for Body {
                    #[inline]
                    fn clone(&self) -> Body {
                        match self {
                            Body::CastAddBody(__self_0) => {
                                Body::CastAddBody(::core::clone::Clone::clone(__self_0))
                            }
                            Body::CastRemoveBody(__self_0) => {
                                Body::CastRemoveBody(::core::clone::Clone::clone(__self_0))
                            }
                            Body::ReactionBody(__self_0) => {
                                Body::ReactionBody(::core::clone::Clone::clone(__self_0))
                            }
                            Body::VerificationAddEthAddressBody(__self_0) => {
                                Body::VerificationAddEthAddressBody(
                                    ::core::clone::Clone::clone(__self_0),
                                )
                            }
                            Body::VerificationRemoveBody(__self_0) => {
                                Body::VerificationRemoveBody(
                                    ::core::clone::Clone::clone(__self_0),
                                )
                            }
                            Body::SignerAddBody(__self_0) => {
                                Body::SignerAddBody(::core::clone::Clone::clone(__self_0))
                            }
                            Body::UserDataBody(__self_0) => {
                                Body::UserDataBody(::core::clone::Clone::clone(__self_0))
                            }
                            Body::SignerRemoveBody(__self_0) => {
                                Body::SignerRemoveBody(
                                    ::core::clone::Clone::clone(__self_0),
                                )
                            }
                            Body::LinkBody(__self_0) => {
                                Body::LinkBody(::core::clone::Clone::clone(__self_0))
                            }
                            Body::UsernameProofBody(__self_0) => {
                                Body::UsernameProofBody(
                                    ::core::clone::Clone::clone(__self_0),
                                )
                            }
                        }
                    }
                }
                #[allow(clippy::derive_partial_eq_without_eq)]
                #[automatically_derived]
                impl ::core::marker::StructuralPartialEq for Body {}
                #[automatically_derived]
                #[allow(clippy::derive_partial_eq_without_eq)]
                impl ::core::cmp::PartialEq for Body {
                    #[inline]
                    fn eq(&self, other: &Body) -> bool {
                        let __self_tag = ::core::intrinsics::discriminant_value(self);
                        let __arg1_tag = ::core::intrinsics::discriminant_value(other);
                        __self_tag == __arg1_tag
                            && match (self, other) {
                                (
                                    Body::CastAddBody(__self_0),
                                    Body::CastAddBody(__arg1_0),
                                ) => *__self_0 == *__arg1_0,
                                (
                                    Body::CastRemoveBody(__self_0),
                                    Body::CastRemoveBody(__arg1_0),
                                ) => *__self_0 == *__arg1_0,
                                (
                                    Body::ReactionBody(__self_0),
                                    Body::ReactionBody(__arg1_0),
                                ) => *__self_0 == *__arg1_0,
                                (
                                    Body::VerificationAddEthAddressBody(__self_0),
                                    Body::VerificationAddEthAddressBody(__arg1_0),
                                ) => *__self_0 == *__arg1_0,
                                (
                                    Body::VerificationRemoveBody(__self_0),
                                    Body::VerificationRemoveBody(__arg1_0),
                                ) => *__self_0 == *__arg1_0,
                                (
                                    Body::SignerAddBody(__self_0),
                                    Body::SignerAddBody(__arg1_0),
                                ) => *__self_0 == *__arg1_0,
                                (
                                    Body::UserDataBody(__self_0),
                                    Body::UserDataBody(__arg1_0),
                                ) => *__self_0 == *__arg1_0,
                                (
                                    Body::SignerRemoveBody(__self_0),
                                    Body::SignerRemoveBody(__arg1_0),
                                ) => *__self_0 == *__arg1_0,
                                (Body::LinkBody(__self_0), Body::LinkBody(__arg1_0)) => {
                                    *__self_0 == *__arg1_0
                                }
                                (
                                    Body::UsernameProofBody(__self_0),
                                    Body::UsernameProofBody(__arg1_0),
                                ) => *__self_0 == *__arg1_0,
                                _ => unsafe { ::core::intrinsics::unreachable() }
                            }
                    }
                }
                impl Body {
                    /// Encodes the message to a buffer.
                    pub fn encode<B>(&self, buf: &mut B)
                    where
                        B: ::prost::bytes::BufMut,
                    {
                        match *self {
                            Body::CastAddBody(ref value) => {
                                ::prost::encoding::message::encode(5u32, &*value, buf);
                            }
                            Body::CastRemoveBody(ref value) => {
                                ::prost::encoding::message::encode(6u32, &*value, buf);
                            }
                            Body::ReactionBody(ref value) => {
                                ::prost::encoding::message::encode(7u32, &*value, buf);
                            }
                            Body::VerificationAddEthAddressBody(ref value) => {
                                ::prost::encoding::message::encode(9u32, &*value, buf);
                            }
                            Body::VerificationRemoveBody(ref value) => {
                                ::prost::encoding::message::encode(10u32, &*value, buf);
                            }
                            Body::SignerAddBody(ref value) => {
                                ::prost::encoding::message::encode(11u32, &*value, buf);
                            }
                            Body::UserDataBody(ref value) => {
                                ::prost::encoding::message::encode(12u32, &*value, buf);
                            }
                            Body::SignerRemoveBody(ref value) => {
                                ::prost::encoding::message::encode(13u32, &*value, buf);
                            }
                            Body::LinkBody(ref value) => {
                                ::prost::encoding::message::encode(14u32, &*value, buf);
                            }
                            Body::UsernameProofBody(ref value) => {
                                ::prost::encoding::message::encode(15u32, &*value, buf);
                            }
                        }
                    }
                    /// Decodes an instance of the message from a buffer, and merges it into self.
                    pub fn merge<B>(
                        field: &mut ::core::option::Option<Body>,
                        tag: u32,
                        wire_type: ::prost::encoding::WireType,
                        buf: &mut B,
                        ctx: ::prost::encoding::DecodeContext,
                    ) -> ::core::result::Result<(), ::prost::DecodeError>
                    where
                        B: ::prost::bytes::Buf,
                    {
                        match tag {
                            5u32 => {
                                match field {
                                    ::core::option::Option::Some(
                                        Body::CastAddBody(ref mut value),
                                    ) => {
                                        ::prost::encoding::message::merge(
                                            wire_type,
                                            value,
                                            buf,
                                            ctx,
                                        )
                                    }
                                    _ => {
                                        let mut owned_value = ::core::default::Default::default();
                                        let value = &mut owned_value;
                                        ::prost::encoding::message::merge(
                                                wire_type,
                                                value,
                                                buf,
                                                ctx,
                                            )
                                            .map(|_| {
                                                *field = ::core::option::Option::Some(
                                                    Body::CastAddBody(owned_value),
                                                );
                                            })
                                    }
                                }
                            }
                            6u32 => {
                                match field {
                                    ::core::option::Option::Some(
                                        Body::CastRemoveBody(ref mut value),
                                    ) => {
                                        ::prost::encoding::message::merge(
                                            wire_type,
                                            value,
                                            buf,
                                            ctx,
                                        )
                                    }
                                    _ => {
                                        let mut owned_value = ::core::default::Default::default();
                                        let value = &mut owned_value;
                                        ::prost::encoding::message::merge(
                                                wire_type,
                                                value,
                                                buf,
                                                ctx,
                                            )
                                            .map(|_| {
                                                *field = ::core::option::Option::Some(
                                                    Body::CastRemoveBody(owned_value),
                                                );
                                            })
                                    }
                                }
                            }
                            7u32 => {
                                match field {
                                    ::core::option::Option::Some(
                                        Body::ReactionBody(ref mut value),
                                    ) => {
                                        ::prost::encoding::message::merge(
                                            wire_type,
                                            value,
                                            buf,
                                            ctx,
                                        )
                                    }
                                    _ => {
                                        let mut owned_value = ::core::default::Default::default();
                                        let value = &mut owned_value;
                                        ::prost::encoding::message::merge(
                                                wire_type,
                                                value,
                                                buf,
                                                ctx,
                                            )
                                            .map(|_| {
                                                *field = ::core::option::Option::Some(
                                                    Body::ReactionBody(owned_value),
                                                );
                                            })
                                    }
                                }
                            }
                            9u32 => {
                                match field {
                                    ::core::option::Option::Some(
                                        Body::VerificationAddEthAddressBody(ref mut value),
                                    ) => {
                                        ::prost::encoding::message::merge(
                                            wire_type,
                                            value,
                                            buf,
                                            ctx,
                                        )
                                    }
                                    _ => {
                                        let mut owned_value = ::core::default::Default::default();
                                        let value = &mut owned_value;
                                        ::prost::encoding::message::merge(
                                                wire_type,
                                                value,
                                                buf,
                                                ctx,
                                            )
                                            .map(|_| {
                                                *field = ::core::option::Option::Some(
                                                    Body::VerificationAddEthAddressBody(owned_value),
                                                );
                                            })
                                    }
                                }
                            }
                            10u32 => {
                                match field {
                                    ::core::option::Option::Some(
                                        Body::VerificationRemoveBody(ref mut value),
                                    ) => {
                                        ::prost::encoding::message::merge(
                                            wire_type,
                                            value,
                                            buf,
                                            ctx,
                                        )
                                    }
                                    _ => {
                                        let mut owned_value = ::core::default::Default::default();
                                        let value = &mut owned_value;
                                        ::prost::encoding::message::merge(
                                                wire_type,
                                                value,
                                                buf,
                                                ctx,
                                            )
                                            .map(|_| {
                                                *field = ::core::option::Option::Some(
                                                    Body::VerificationRemoveBody(owned_value),
                                                );
                                            })
                                    }
                                }
                            }
                            11u32 => {
                                match field {
                                    ::core::option::Option::Some(
                                        Body::SignerAddBody(ref mut value),
                                    ) => {
                                        ::prost::encoding::message::merge(
                                            wire_type,
                                            value,
                                            buf,
                                            ctx,
                                        )
                                    }
                                    _ => {
                                        let mut owned_value = ::core::default::Default::default();
                                        let value = &mut owned_value;
                                        ::prost::encoding::message::merge(
                                                wire_type,
                                                value,
                                                buf,
                                                ctx,
                                            )
                                            .map(|_| {
                                                *field = ::core::option::Option::Some(
                                                    Body::SignerAddBody(owned_value),
                                                );
                                            })
                                    }
                                }
                            }
                            12u32 => {
                                match field {
                                    ::core::option::Option::Some(
                                        Body::UserDataBody(ref mut value),
                                    ) => {
                                        ::prost::encoding::message::merge(
                                            wire_type,
                                            value,
                                            buf,
                                            ctx,
                                        )
                                    }
                                    _ => {
                                        let mut owned_value = ::core::default::Default::default();
                                        let value = &mut owned_value;
                                        ::prost::encoding::message::merge(
                                                wire_type,
                                                value,
                                                buf,
                                                ctx,
                                            )
                                            .map(|_| {
                                                *field = ::core::option::Option::Some(
                                                    Body::UserDataBody(owned_value),
                                                );
                                            })
                                    }
                                }
                            }
                            13u32 => {
                                match field {
                                    ::core::option::Option::Some(
                                        Body::SignerRemoveBody(ref mut value),
                                    ) => {
                                        ::prost::encoding::message::merge(
                                            wire_type,
                                            value,
                                            buf,
                                            ctx,
                                        )
                                    }
                                    _ => {
                                        let mut owned_value = ::core::default::Default::default();
                                        let value = &mut owned_value;
                                        ::prost::encoding::message::merge(
                                                wire_type,
                                                value,
                                                buf,
                                                ctx,
                                            )
                                            .map(|_| {
                                                *field = ::core::option::Option::Some(
                                                    Body::SignerRemoveBody(owned_value),
                                                );
                                            })
                                    }
                                }
                            }
                            14u32 => {
                                match field {
                                    ::core::option::Option::Some(
                                        Body::LinkBody(ref mut value),
                                    ) => {
                                        ::prost::encoding::message::merge(
                                            wire_type,
                                            value,
                                            buf,
                                            ctx,
                                        )
                                    }
                                    _ => {
                                        let mut owned_value = ::core::default::Default::default();
                                        let value = &mut owned_value;
                                        ::prost::encoding::message::merge(
                                                wire_type,
                                                value,
                                                buf,
                                                ctx,
                                            )
                                            .map(|_| {
                                                *field = ::core::option::Option::Some(
                                                    Body::LinkBody(owned_value),
                                                );
                                            })
                                    }
                                }
                            }
                            15u32 => {
                                match field {
                                    ::core::option::Option::Some(
                                        Body::UsernameProofBody(ref mut value),
                                    ) => {
                                        ::prost::encoding::message::merge(
                                            wire_type,
                                            value,
                                            buf,
                                            ctx,
                                        )
                                    }
                                    _ => {
                                        let mut owned_value = ::core::default::Default::default();
                                        let value = &mut owned_value;
                                        ::prost::encoding::message::merge(
                                                wire_type,
                                                value,
                                                buf,
                                                ctx,
                                            )
                                            .map(|_| {
                                                *field = ::core::option::Option::Some(
                                                    Body::UsernameProofBody(owned_value),
                                                );
                                            })
                                    }
                                }
                            }
                            _ => {
                                ::core::panicking::panic_fmt(
                                    format_args!(
                                        "internal error: entered unreachable code: {0}",
                                        format_args!("invalid Body tag: {0}", tag),
                                    ),
                                );
                            }
                        }
                    }
                    /// Returns the encoded length of the message without a length delimiter.
                    #[inline]
                    pub fn encoded_len(&self) -> usize {
                        match *self {
                            Body::CastAddBody(ref value) => {
                                ::prost::encoding::message::encoded_len(5u32, &*value)
                            }
                            Body::CastRemoveBody(ref value) => {
                                ::prost::encoding::message::encoded_len(6u32, &*value)
                            }
                            Body::ReactionBody(ref value) => {
                                ::prost::encoding::message::encoded_len(7u32, &*value)
                            }
                            Body::VerificationAddEthAddressBody(ref value) => {
                                ::prost::encoding::message::encoded_len(9u32, &*value)
                            }
                            Body::VerificationRemoveBody(ref value) => {
                                ::prost::encoding::message::encoded_len(10u32, &*value)
                            }
                            Body::SignerAddBody(ref value) => {
                                ::prost::encoding::message::encoded_len(11u32, &*value)
                            }
                            Body::UserDataBody(ref value) => {
                                ::prost::encoding::message::encoded_len(12u32, &*value)
                            }
                            Body::SignerRemoveBody(ref value) => {
                                ::prost::encoding::message::encoded_len(13u32, &*value)
                            }
                            Body::LinkBody(ref value) => {
                                ::prost::encoding::message::encoded_len(14u32, &*value)
                            }
                            Body::UsernameProofBody(ref value) => {
                                ::prost::encoding::message::encoded_len(15u32, &*value)
                            }
                        }
                    }
                }
                impl ::core::fmt::Debug for Body {
                    fn fmt(
                        &self,
                        f: &mut ::core::fmt::Formatter,
                    ) -> ::core::fmt::Result {
                        match *self {
                            Body::CastAddBody(ref value) => {
                                let wrapper = &*value;
                                f.debug_tuple("CastAddBody").field(&wrapper).finish()
                            }
                            Body::CastRemoveBody(ref value) => {
                                let wrapper = &*value;
                                f.debug_tuple("CastRemoveBody").field(&wrapper).finish()
                            }
                            Body::ReactionBody(ref value) => {
                                let wrapper = &*value;
                                f.debug_tuple("ReactionBody").field(&wrapper).finish()
                            }
                            Body::VerificationAddEthAddressBody(ref value) => {
                                let wrapper = &*value;
                                f.debug_tuple("VerificationAddEthAddressBody")
                                    .field(&wrapper)
                                    .finish()
                            }
                            Body::VerificationRemoveBody(ref value) => {
                                let wrapper = &*value;
                                f.debug_tuple("VerificationRemoveBody")
                                    .field(&wrapper)
                                    .finish()
                            }
                            Body::SignerAddBody(ref value) => {
                                let wrapper = &*value;
                                f.debug_tuple("SignerAddBody").field(&wrapper).finish()
                            }
                            Body::UserDataBody(ref value) => {
                                let wrapper = &*value;
                                f.debug_tuple("UserDataBody").field(&wrapper).finish()
                            }
                            Body::SignerRemoveBody(ref value) => {
                                let wrapper = &*value;
                                f.debug_tuple("SignerRemoveBody").field(&wrapper).finish()
                            }
                            Body::LinkBody(ref value) => {
                                let wrapper = &*value;
                                f.debug_tuple("LinkBody").field(&wrapper).finish()
                            }
                            Body::UsernameProofBody(ref value) => {
                                let wrapper = &*value;
                                f.debug_tuple("UsernameProofBody").field(&wrapper).finish()
                            }
                        }
                    }
                }
            }
            /// * Adds an Ed25519 key pair that signs messages for a user
            #[allow(clippy::derive_partial_eq_without_eq)]
            pub struct SignerAddBody {
                /// Public key of the Ed25519 key pair
                #[prost(bytes = "vec", tag = "1")]
                pub signer: ::prost::alloc::vec::Vec<u8>,
                /// Name of the key pair
                #[prost(string, optional, tag = "2")]
                pub name: ::core::option::Option<::prost::alloc::string::String>,
            }
            #[automatically_derived]
            #[allow(clippy::derive_partial_eq_without_eq)]
            impl ::core::clone::Clone for SignerAddBody {
                #[inline]
                fn clone(&self) -> SignerAddBody {
                    SignerAddBody {
                        signer: ::core::clone::Clone::clone(&self.signer),
                        name: ::core::clone::Clone::clone(&self.name),
                    }
                }
            }
            #[allow(clippy::derive_partial_eq_without_eq)]
            #[automatically_derived]
            impl ::core::marker::StructuralPartialEq for SignerAddBody {}
            #[automatically_derived]
            #[allow(clippy::derive_partial_eq_without_eq)]
            impl ::core::cmp::PartialEq for SignerAddBody {
                #[inline]
                fn eq(&self, other: &SignerAddBody) -> bool {
                    self.signer == other.signer && self.name == other.name
                }
            }
            impl ::prost::Message for SignerAddBody {
                #[allow(unused_variables)]
                fn encode_raw<B>(&self, buf: &mut B)
                where
                    B: ::prost::bytes::BufMut,
                {
                    if self.signer != b"" as &[u8] {
                        ::prost::encoding::bytes::encode(1u32, &self.signer, buf);
                    }
                    if let ::core::option::Option::Some(ref value) = self.name {
                        ::prost::encoding::string::encode(2u32, value, buf);
                    }
                }
                #[allow(unused_variables)]
                fn merge_field<B>(
                    &mut self,
                    tag: u32,
                    wire_type: ::prost::encoding::WireType,
                    buf: &mut B,
                    ctx: ::prost::encoding::DecodeContext,
                ) -> ::core::result::Result<(), ::prost::DecodeError>
                where
                    B: ::prost::bytes::Buf,
                {
                    const STRUCT_NAME: &'static str = "SignerAddBody";
                    match tag {
                        1u32 => {
                            let mut value = &mut self.signer;
                            ::prost::encoding::bytes::merge(wire_type, value, buf, ctx)
                                .map_err(|mut error| {
                                    error.push(STRUCT_NAME, "signer");
                                    error
                                })
                        }
                        2u32 => {
                            let mut value = &mut self.name;
                            ::prost::encoding::string::merge(
                                    wire_type,
                                    value.get_or_insert_with(::core::default::Default::default),
                                    buf,
                                    ctx,
                                )
                                .map_err(|mut error| {
                                    error.push(STRUCT_NAME, "name");
                                    error
                                })
                        }
                        _ => ::prost::encoding::skip_field(wire_type, tag, buf, ctx),
                    }
                }
                #[inline]
                fn encoded_len(&self) -> usize {
                    0
                        + if self.signer != b"" as &[u8] {
                            ::prost::encoding::bytes::encoded_len(1u32, &self.signer)
                        } else {
                            0
                        }
                        + self
                            .name
                            .as_ref()
                            .map_or(
                                0,
                                |value| ::prost::encoding::string::encoded_len(2u32, value),
                            )
                }
                fn clear(&mut self) {
                    self.signer.clear();
                    self.name = ::core::option::Option::None;
                }
            }
            impl ::core::default::Default for SignerAddBody {
                fn default() -> Self {
                    SignerAddBody {
                        signer: ::core::default::Default::default(),
                        name: ::core::option::Option::None,
                    }
                }
            }
            impl ::core::fmt::Debug for SignerAddBody {
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    let mut builder = f.debug_struct("SignerAddBody");
                    let builder = {
                        let wrapper = {
                            fn ScalarWrapper<T>(v: T) -> T {
                                v
                            }
                            ScalarWrapper(&self.signer)
                        };
                        builder.field("signer", &wrapper)
                    };
                    let builder = {
                        let wrapper = {
                            struct ScalarWrapper<'a>(
                                &'a ::core::option::Option<::prost::alloc::string::String>,
                            );
                            impl<'a> ::core::fmt::Debug for ScalarWrapper<'a> {
                                fn fmt(
                                    &self,
                                    f: &mut ::core::fmt::Formatter,
                                ) -> ::core::fmt::Result {
                                    fn Inner<T>(v: T) -> T {
                                        v
                                    }
                                    ::core::fmt::Debug::fmt(&self.0.as_ref().map(Inner), f)
                                }
                            }
                            ScalarWrapper(&self.name)
                        };
                        builder.field("name", &wrapper)
                    };
                    builder.finish()
                }
            }
            #[allow(dead_code)]
            impl SignerAddBody {
                ///Returns the value of `name`, or the default value if `name` is unset.
                pub fn name(&self) -> &str {
                    match self.name {
                        ::core::option::Option::Some(ref val) => &val[..],
                        ::core::option::Option::None => "",
                    }
                }
            }
            /// * Removes an Ed25519 key pair that signs messages for a user
            #[allow(clippy::derive_partial_eq_without_eq)]
            pub struct SignerRemoveBody {
                /// Public key of the Ed25519 key pair
                #[prost(bytes = "vec", tag = "1")]
                pub signer: ::prost::alloc::vec::Vec<u8>,
            }
            #[automatically_derived]
            #[allow(clippy::derive_partial_eq_without_eq)]
            impl ::core::clone::Clone for SignerRemoveBody {
                #[inline]
                fn clone(&self) -> SignerRemoveBody {
                    SignerRemoveBody {
                        signer: ::core::clone::Clone::clone(&self.signer),
                    }
                }
            }
            #[allow(clippy::derive_partial_eq_without_eq)]
            #[automatically_derived]
            impl ::core::marker::StructuralPartialEq for SignerRemoveBody {}
            #[automatically_derived]
            #[allow(clippy::derive_partial_eq_without_eq)]
            impl ::core::cmp::PartialEq for SignerRemoveBody {
                #[inline]
                fn eq(&self, other: &SignerRemoveBody) -> bool {
                    self.signer == other.signer
                }
            }
            impl ::prost::Message for SignerRemoveBody {
                #[allow(unused_variables)]
                fn encode_raw<B>(&self, buf: &mut B)
                where
                    B: ::prost::bytes::BufMut,
                {
                    if self.signer != b"" as &[u8] {
                        ::prost::encoding::bytes::encode(1u32, &self.signer, buf);
                    }
                }
                #[allow(unused_variables)]
                fn merge_field<B>(
                    &mut self,
                    tag: u32,
                    wire_type: ::prost::encoding::WireType,
                    buf: &mut B,
                    ctx: ::prost::encoding::DecodeContext,
                ) -> ::core::result::Result<(), ::prost::DecodeError>
                where
                    B: ::prost::bytes::Buf,
                {
                    const STRUCT_NAME: &'static str = "SignerRemoveBody";
                    match tag {
                        1u32 => {
                            let mut value = &mut self.signer;
                            ::prost::encoding::bytes::merge(wire_type, value, buf, ctx)
                                .map_err(|mut error| {
                                    error.push(STRUCT_NAME, "signer");
                                    error
                                })
                        }
                        _ => ::prost::encoding::skip_field(wire_type, tag, buf, ctx),
                    }
                }
                #[inline]
                fn encoded_len(&self) -> usize {
                    0
                        + if self.signer != b"" as &[u8] {
                            ::prost::encoding::bytes::encoded_len(1u32, &self.signer)
                        } else {
                            0
                        }
                }
                fn clear(&mut self) {
                    self.signer.clear();
                }
            }
            impl ::core::default::Default for SignerRemoveBody {
                fn default() -> Self {
                    SignerRemoveBody {
                        signer: ::core::default::Default::default(),
                    }
                }
            }
            impl ::core::fmt::Debug for SignerRemoveBody {
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    let mut builder = f.debug_struct("SignerRemoveBody");
                    let builder = {
                        let wrapper = {
                            fn ScalarWrapper<T>(v: T) -> T {
                                v
                            }
                            ScalarWrapper(&self.signer)
                        };
                        builder.field("signer", &wrapper)
                    };
                    builder.finish()
                }
            }
            /// * Adds metadata about a user
            #[allow(clippy::derive_partial_eq_without_eq)]
            pub struct UserDataBody {
                /// Type of metadata
                #[prost(enumeration = "UserDataType", tag = "1")]
                pub r#type: i32,
                /// Value of the metadata
                #[prost(string, tag = "2")]
                pub value: ::prost::alloc::string::String,
            }
            #[automatically_derived]
            #[allow(clippy::derive_partial_eq_without_eq)]
            impl ::core::clone::Clone for UserDataBody {
                #[inline]
                fn clone(&self) -> UserDataBody {
                    UserDataBody {
                        r#type: ::core::clone::Clone::clone(&self.r#type),
                        value: ::core::clone::Clone::clone(&self.value),
                    }
                }
            }
            #[allow(clippy::derive_partial_eq_without_eq)]
            #[automatically_derived]
            impl ::core::marker::StructuralPartialEq for UserDataBody {}
            #[automatically_derived]
            #[allow(clippy::derive_partial_eq_without_eq)]
            impl ::core::cmp::PartialEq for UserDataBody {
                #[inline]
                fn eq(&self, other: &UserDataBody) -> bool {
                    self.r#type == other.r#type && self.value == other.value
                }
            }
            impl ::prost::Message for UserDataBody {
                #[allow(unused_variables)]
                fn encode_raw<B>(&self, buf: &mut B)
                where
                    B: ::prost::bytes::BufMut,
                {
                    if self.r#type != UserDataType::default() as i32 {
                        ::prost::encoding::int32::encode(1u32, &self.r#type, buf);
                    }
                    if self.value != "" {
                        ::prost::encoding::string::encode(2u32, &self.value, buf);
                    }
                }
                #[allow(unused_variables)]
                fn merge_field<B>(
                    &mut self,
                    tag: u32,
                    wire_type: ::prost::encoding::WireType,
                    buf: &mut B,
                    ctx: ::prost::encoding::DecodeContext,
                ) -> ::core::result::Result<(), ::prost::DecodeError>
                where
                    B: ::prost::bytes::Buf,
                {
                    const STRUCT_NAME: &'static str = "UserDataBody";
                    match tag {
                        1u32 => {
                            let mut value = &mut self.r#type;
                            ::prost::encoding::int32::merge(wire_type, value, buf, ctx)
                                .map_err(|mut error| {
                                    error.push(STRUCT_NAME, "r#type");
                                    error
                                })
                        }
                        2u32 => {
                            let mut value = &mut self.value;
                            ::prost::encoding::string::merge(wire_type, value, buf, ctx)
                                .map_err(|mut error| {
                                    error.push(STRUCT_NAME, "value");
                                    error
                                })
                        }
                        _ => ::prost::encoding::skip_field(wire_type, tag, buf, ctx),
                    }
                }
                #[inline]
                fn encoded_len(&self) -> usize {
                    0
                        + if self.r#type != UserDataType::default() as i32 {
                            ::prost::encoding::int32::encoded_len(1u32, &self.r#type)
                        } else {
                            0
                        }
                        + if self.value != "" {
                            ::prost::encoding::string::encoded_len(2u32, &self.value)
                        } else {
                            0
                        }
                }
                fn clear(&mut self) {
                    self.r#type = UserDataType::default() as i32;
                    self.value.clear();
                }
            }
            impl ::core::default::Default for UserDataBody {
                fn default() -> Self {
                    UserDataBody {
                        r#type: UserDataType::default() as i32,
                        value: ::prost::alloc::string::String::new(),
                    }
                }
            }
            impl ::core::fmt::Debug for UserDataBody {
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    let mut builder = f.debug_struct("UserDataBody");
                    let builder = {
                        let wrapper = {
                            struct ScalarWrapper<'a>(&'a i32);
                            impl<'a> ::core::fmt::Debug for ScalarWrapper<'a> {
                                fn fmt(
                                    &self,
                                    f: &mut ::core::fmt::Formatter,
                                ) -> ::core::fmt::Result {
                                    match UserDataType::from_i32(*self.0) {
                                        None => ::core::fmt::Debug::fmt(&self.0, f),
                                        Some(en) => ::core::fmt::Debug::fmt(&en, f),
                                    }
                                }
                            }
                            ScalarWrapper(&self.r#type)
                        };
                        builder.field("r#type", &wrapper)
                    };
                    let builder = {
                        let wrapper = {
                            fn ScalarWrapper<T>(v: T) -> T {
                                v
                            }
                            ScalarWrapper(&self.value)
                        };
                        builder.field("value", &wrapper)
                    };
                    builder.finish()
                }
            }
            #[allow(dead_code)]
            impl UserDataBody {
                ///Returns the enum value of `type`, or the default if the field is set to an invalid enum value.
                pub fn r#type(&self) -> UserDataType {
                    UserDataType::from_i32(self.r#type)
                        .unwrap_or(UserDataType::default())
                }
                ///Sets `type` to the provided enum value.
                pub fn set_type(&mut self, value: UserDataType) {
                    self.r#type = value as i32;
                }
            }
            #[allow(clippy::derive_partial_eq_without_eq)]
            pub struct Embed {
                #[prost(oneof = "embed::Embed", tags = "1, 2")]
                pub embed: ::core::option::Option<embed::Embed>,
            }
            #[automatically_derived]
            #[allow(clippy::derive_partial_eq_without_eq)]
            impl ::core::clone::Clone for Embed {
                #[inline]
                fn clone(&self) -> Embed {
                    Embed {
                        embed: ::core::clone::Clone::clone(&self.embed),
                    }
                }
            }
            #[allow(clippy::derive_partial_eq_without_eq)]
            #[automatically_derived]
            impl ::core::marker::StructuralPartialEq for Embed {}
            #[automatically_derived]
            #[allow(clippy::derive_partial_eq_without_eq)]
            impl ::core::cmp::PartialEq for Embed {
                #[inline]
                fn eq(&self, other: &Embed) -> bool {
                    self.embed == other.embed
                }
            }
            impl ::prost::Message for Embed {
                #[allow(unused_variables)]
                fn encode_raw<B>(&self, buf: &mut B)
                where
                    B: ::prost::bytes::BufMut,
                {
                    if let Some(ref oneof) = self.embed {
                        oneof.encode(buf)
                    }
                }
                #[allow(unused_variables)]
                fn merge_field<B>(
                    &mut self,
                    tag: u32,
                    wire_type: ::prost::encoding::WireType,
                    buf: &mut B,
                    ctx: ::prost::encoding::DecodeContext,
                ) -> ::core::result::Result<(), ::prost::DecodeError>
                where
                    B: ::prost::bytes::Buf,
                {
                    const STRUCT_NAME: &'static str = "Embed";
                    match tag {
                        1u32 | 2u32 => {
                            let mut value = &mut self.embed;
                            embed::Embed::merge(value, tag, wire_type, buf, ctx)
                                .map_err(|mut error| {
                                    error.push(STRUCT_NAME, "embed");
                                    error
                                })
                        }
                        _ => ::prost::encoding::skip_field(wire_type, tag, buf, ctx),
                    }
                }
                #[inline]
                fn encoded_len(&self) -> usize {
                    0 + self.embed.as_ref().map_or(0, embed::Embed::encoded_len)
                }
                fn clear(&mut self) {
                    self.embed = ::core::option::Option::None;
                }
            }
            impl ::core::default::Default for Embed {
                fn default() -> Self {
                    Embed {
                        embed: ::core::default::Default::default(),
                    }
                }
            }
            impl ::core::fmt::Debug for Embed {
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    let mut builder = f.debug_struct("Embed");
                    let builder = {
                        let wrapper = &self.embed;
                        builder.field("embed", &wrapper)
                    };
                    builder.finish()
                }
            }
            /// Nested message and enum types in `Embed`.
            pub mod embed {
                #[allow(clippy::derive_partial_eq_without_eq)]
                pub enum Embed {
                    #[prost(string, tag = "1")]
                    Url(::prost::alloc::string::String),
                    #[prost(message, tag = "2")]
                    CastId(super::CastId),
                }
                #[automatically_derived]
                #[allow(clippy::derive_partial_eq_without_eq)]
                impl ::core::clone::Clone for Embed {
                    #[inline]
                    fn clone(&self) -> Embed {
                        match self {
                            Embed::Url(__self_0) => {
                                Embed::Url(::core::clone::Clone::clone(__self_0))
                            }
                            Embed::CastId(__self_0) => {
                                Embed::CastId(::core::clone::Clone::clone(__self_0))
                            }
                        }
                    }
                }
                #[allow(clippy::derive_partial_eq_without_eq)]
                #[automatically_derived]
                impl ::core::marker::StructuralPartialEq for Embed {}
                #[automatically_derived]
                #[allow(clippy::derive_partial_eq_without_eq)]
                impl ::core::cmp::PartialEq for Embed {
                    #[inline]
                    fn eq(&self, other: &Embed) -> bool {
                        let __self_tag = ::core::intrinsics::discriminant_value(self);
                        let __arg1_tag = ::core::intrinsics::discriminant_value(other);
                        __self_tag == __arg1_tag
                            && match (self, other) {
                                (Embed::Url(__self_0), Embed::Url(__arg1_0)) => {
                                    *__self_0 == *__arg1_0
                                }
                                (Embed::CastId(__self_0), Embed::CastId(__arg1_0)) => {
                                    *__self_0 == *__arg1_0
                                }
                                _ => unsafe { ::core::intrinsics::unreachable() }
                            }
                    }
                }
                impl Embed {
                    /// Encodes the message to a buffer.
                    pub fn encode<B>(&self, buf: &mut B)
                    where
                        B: ::prost::bytes::BufMut,
                    {
                        match *self {
                            Embed::Url(ref value) => {
                                ::prost::encoding::string::encode(1u32, &*value, buf);
                            }
                            Embed::CastId(ref value) => {
                                ::prost::encoding::message::encode(2u32, &*value, buf);
                            }
                        }
                    }
                    /// Decodes an instance of the message from a buffer, and merges it into self.
                    pub fn merge<B>(
                        field: &mut ::core::option::Option<Embed>,
                        tag: u32,
                        wire_type: ::prost::encoding::WireType,
                        buf: &mut B,
                        ctx: ::prost::encoding::DecodeContext,
                    ) -> ::core::result::Result<(), ::prost::DecodeError>
                    where
                        B: ::prost::bytes::Buf,
                    {
                        match tag {
                            1u32 => {
                                match field {
                                    ::core::option::Option::Some(Embed::Url(ref mut value)) => {
                                        ::prost::encoding::string::merge(wire_type, value, buf, ctx)
                                    }
                                    _ => {
                                        let mut owned_value = ::core::default::Default::default();
                                        let value = &mut owned_value;
                                        ::prost::encoding::string::merge(wire_type, value, buf, ctx)
                                            .map(|_| {
                                                *field = ::core::option::Option::Some(
                                                    Embed::Url(owned_value),
                                                );
                                            })
                                    }
                                }
                            }
                            2u32 => {
                                match field {
                                    ::core::option::Option::Some(
                                        Embed::CastId(ref mut value),
                                    ) => {
                                        ::prost::encoding::message::merge(
                                            wire_type,
                                            value,
                                            buf,
                                            ctx,
                                        )
                                    }
                                    _ => {
                                        let mut owned_value = ::core::default::Default::default();
                                        let value = &mut owned_value;
                                        ::prost::encoding::message::merge(
                                                wire_type,
                                                value,
                                                buf,
                                                ctx,
                                            )
                                            .map(|_| {
                                                *field = ::core::option::Option::Some(
                                                    Embed::CastId(owned_value),
                                                );
                                            })
                                    }
                                }
                            }
                            _ => {
                                ::core::panicking::panic_fmt(
                                    format_args!(
                                        "internal error: entered unreachable code: {0}",
                                        format_args!("invalid Embed tag: {0}", tag),
                                    ),
                                );
                            }
                        }
                    }
                    /// Returns the encoded length of the message without a length delimiter.
                    #[inline]
                    pub fn encoded_len(&self) -> usize {
                        match *self {
                            Embed::Url(ref value) => {
                                ::prost::encoding::string::encoded_len(1u32, &*value)
                            }
                            Embed::CastId(ref value) => {
                                ::prost::encoding::message::encoded_len(2u32, &*value)
                            }
                        }
                    }
                }
                impl ::core::fmt::Debug for Embed {
                    fn fmt(
                        &self,
                        f: &mut ::core::fmt::Formatter,
                    ) -> ::core::fmt::Result {
                        match *self {
                            Embed::Url(ref value) => {
                                let wrapper = {
                                    fn ScalarWrapper<T>(v: T) -> T {
                                        v
                                    }
                                    ScalarWrapper(&*value)
                                };
                                f.debug_tuple("Url").field(&wrapper).finish()
                            }
                            Embed::CastId(ref value) => {
                                let wrapper = &*value;
                                f.debug_tuple("CastId").field(&wrapper).finish()
                            }
                        }
                    }
                }
            }
            /// * Adds a new Cast
            #[allow(clippy::derive_partial_eq_without_eq)]
            pub struct CastAddBody {
                /// URLs to be embedded in the cast
                #[prost(string, repeated, tag = "1")]
                pub embeds_deprecated: ::prost::alloc::vec::Vec<
                    ::prost::alloc::string::String,
                >,
                /// Fids mentioned in the cast
                #[prost(uint64, repeated, tag = "2")]
                pub mentions: ::prost::alloc::vec::Vec<u64>,
                /// Text of the cast
                #[prost(string, tag = "4")]
                pub text: ::prost::alloc::string::String,
                /// Positions of the mentions in the text
                #[prost(uint32, repeated, tag = "5")]
                pub mentions_positions: ::prost::alloc::vec::Vec<u32>,
                /// URLs or cast ids to be embedded in the cast
                #[prost(message, repeated, tag = "6")]
                pub embeds: ::prost::alloc::vec::Vec<Embed>,
                #[prost(oneof = "cast_add_body::Parent", tags = "3, 7")]
                pub parent: ::core::option::Option<cast_add_body::Parent>,
            }
            #[automatically_derived]
            #[allow(clippy::derive_partial_eq_without_eq)]
            impl ::core::clone::Clone for CastAddBody {
                #[inline]
                fn clone(&self) -> CastAddBody {
                    CastAddBody {
                        embeds_deprecated: ::core::clone::Clone::clone(
                            &self.embeds_deprecated,
                        ),
                        mentions: ::core::clone::Clone::clone(&self.mentions),
                        text: ::core::clone::Clone::clone(&self.text),
                        mentions_positions: ::core::clone::Clone::clone(
                            &self.mentions_positions,
                        ),
                        embeds: ::core::clone::Clone::clone(&self.embeds),
                        parent: ::core::clone::Clone::clone(&self.parent),
                    }
                }
            }
            #[allow(clippy::derive_partial_eq_without_eq)]
            #[automatically_derived]
            impl ::core::marker::StructuralPartialEq for CastAddBody {}
            #[automatically_derived]
            #[allow(clippy::derive_partial_eq_without_eq)]
            impl ::core::cmp::PartialEq for CastAddBody {
                #[inline]
                fn eq(&self, other: &CastAddBody) -> bool {
                    self.embeds_deprecated == other.embeds_deprecated
                        && self.mentions == other.mentions && self.text == other.text
                        && self.mentions_positions == other.mentions_positions
                        && self.embeds == other.embeds && self.parent == other.parent
                }
            }
            impl ::prost::Message for CastAddBody {
                #[allow(unused_variables)]
                fn encode_raw<B>(&self, buf: &mut B)
                where
                    B: ::prost::bytes::BufMut,
                {
                    ::prost::encoding::string::encode_repeated(
                        1u32,
                        &self.embeds_deprecated,
                        buf,
                    );
                    ::prost::encoding::uint64::encode_packed(2u32, &self.mentions, buf);
                    if let Some(ref oneof) = self.parent {
                        oneof.encode(buf)
                    }
                    if self.text != "" {
                        ::prost::encoding::string::encode(4u32, &self.text, buf);
                    }
                    ::prost::encoding::uint32::encode_packed(
                        5u32,
                        &self.mentions_positions,
                        buf,
                    );
                    for msg in &self.embeds {
                        ::prost::encoding::message::encode(6u32, msg, buf);
                    }
                }
                #[allow(unused_variables)]
                fn merge_field<B>(
                    &mut self,
                    tag: u32,
                    wire_type: ::prost::encoding::WireType,
                    buf: &mut B,
                    ctx: ::prost::encoding::DecodeContext,
                ) -> ::core::result::Result<(), ::prost::DecodeError>
                where
                    B: ::prost::bytes::Buf,
                {
                    const STRUCT_NAME: &'static str = "CastAddBody";
                    match tag {
                        1u32 => {
                            let mut value = &mut self.embeds_deprecated;
                            ::prost::encoding::string::merge_repeated(
                                    wire_type,
                                    value,
                                    buf,
                                    ctx,
                                )
                                .map_err(|mut error| {
                                    error.push(STRUCT_NAME, "embeds_deprecated");
                                    error
                                })
                        }
                        2u32 => {
                            let mut value = &mut self.mentions;
                            ::prost::encoding::uint64::merge_repeated(
                                    wire_type,
                                    value,
                                    buf,
                                    ctx,
                                )
                                .map_err(|mut error| {
                                    error.push(STRUCT_NAME, "mentions");
                                    error
                                })
                        }
                        3u32 | 7u32 => {
                            let mut value = &mut self.parent;
                            cast_add_body::Parent::merge(value, tag, wire_type, buf, ctx)
                                .map_err(|mut error| {
                                    error.push(STRUCT_NAME, "parent");
                                    error
                                })
                        }
                        4u32 => {
                            let mut value = &mut self.text;
                            ::prost::encoding::string::merge(wire_type, value, buf, ctx)
                                .map_err(|mut error| {
                                    error.push(STRUCT_NAME, "text");
                                    error
                                })
                        }
                        5u32 => {
                            let mut value = &mut self.mentions_positions;
                            ::prost::encoding::uint32::merge_repeated(
                                    wire_type,
                                    value,
                                    buf,
                                    ctx,
                                )
                                .map_err(|mut error| {
                                    error.push(STRUCT_NAME, "mentions_positions");
                                    error
                                })
                        }
                        6u32 => {
                            let mut value = &mut self.embeds;
                            ::prost::encoding::message::merge_repeated(
                                    wire_type,
                                    value,
                                    buf,
                                    ctx,
                                )
                                .map_err(|mut error| {
                                    error.push(STRUCT_NAME, "embeds");
                                    error
                                })
                        }
                        _ => ::prost::encoding::skip_field(wire_type, tag, buf, ctx),
                    }
                }
                #[inline]
                fn encoded_len(&self) -> usize {
                    0
                        + ::prost::encoding::string::encoded_len_repeated(
                            1u32,
                            &self.embeds_deprecated,
                        )
                        + ::prost::encoding::uint64::encoded_len_packed(
                            2u32,
                            &self.mentions,
                        )
                        + self
                            .parent
                            .as_ref()
                            .map_or(0, cast_add_body::Parent::encoded_len)
                        + if self.text != "" {
                            ::prost::encoding::string::encoded_len(4u32, &self.text)
                        } else {
                            0
                        }
                        + ::prost::encoding::uint32::encoded_len_packed(
                            5u32,
                            &self.mentions_positions,
                        )
                        + ::prost::encoding::message::encoded_len_repeated(
                            6u32,
                            &self.embeds,
                        )
                }
                fn clear(&mut self) {
                    self.embeds_deprecated.clear();
                    self.mentions.clear();
                    self.parent = ::core::option::Option::None;
                    self.text.clear();
                    self.mentions_positions.clear();
                    self.embeds.clear();
                }
            }
            impl ::core::default::Default for CastAddBody {
                fn default() -> Self {
                    CastAddBody {
                        embeds_deprecated: ::prost::alloc::vec::Vec::new(),
                        mentions: ::prost::alloc::vec::Vec::new(),
                        parent: ::core::default::Default::default(),
                        text: ::prost::alloc::string::String::new(),
                        mentions_positions: ::prost::alloc::vec::Vec::new(),
                        embeds: ::core::default::Default::default(),
                    }
                }
            }
            impl ::core::fmt::Debug for CastAddBody {
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    let mut builder = f.debug_struct("CastAddBody");
                    let builder = {
                        let wrapper = {
                            struct ScalarWrapper<'a>(
                                &'a ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
                            );
                            impl<'a> ::core::fmt::Debug for ScalarWrapper<'a> {
                                fn fmt(
                                    &self,
                                    f: &mut ::core::fmt::Formatter,
                                ) -> ::core::fmt::Result {
                                    let mut vec_builder = f.debug_list();
                                    for v in self.0 {
                                        fn Inner<T>(v: T) -> T {
                                            v
                                        }
                                        vec_builder.entry(&Inner(v));
                                    }
                                    vec_builder.finish()
                                }
                            }
                            ScalarWrapper(&self.embeds_deprecated)
                        };
                        builder.field("embeds_deprecated", &wrapper)
                    };
                    let builder = {
                        let wrapper = {
                            struct ScalarWrapper<'a>(&'a ::prost::alloc::vec::Vec<u64>);
                            impl<'a> ::core::fmt::Debug for ScalarWrapper<'a> {
                                fn fmt(
                                    &self,
                                    f: &mut ::core::fmt::Formatter,
                                ) -> ::core::fmt::Result {
                                    let mut vec_builder = f.debug_list();
                                    for v in self.0 {
                                        fn Inner<T>(v: T) -> T {
                                            v
                                        }
                                        vec_builder.entry(&Inner(v));
                                    }
                                    vec_builder.finish()
                                }
                            }
                            ScalarWrapper(&self.mentions)
                        };
                        builder.field("mentions", &wrapper)
                    };
                    let builder = {
                        let wrapper = {
                            fn ScalarWrapper<T>(v: T) -> T {
                                v
                            }
                            ScalarWrapper(&self.text)
                        };
                        builder.field("text", &wrapper)
                    };
                    let builder = {
                        let wrapper = {
                            struct ScalarWrapper<'a>(&'a ::prost::alloc::vec::Vec<u32>);
                            impl<'a> ::core::fmt::Debug for ScalarWrapper<'a> {
                                fn fmt(
                                    &self,
                                    f: &mut ::core::fmt::Formatter,
                                ) -> ::core::fmt::Result {
                                    let mut vec_builder = f.debug_list();
                                    for v in self.0 {
                                        fn Inner<T>(v: T) -> T {
                                            v
                                        }
                                        vec_builder.entry(&Inner(v));
                                    }
                                    vec_builder.finish()
                                }
                            }
                            ScalarWrapper(&self.mentions_positions)
                        };
                        builder.field("mentions_positions", &wrapper)
                    };
                    let builder = {
                        let wrapper = &self.embeds;
                        builder.field("embeds", &wrapper)
                    };
                    let builder = {
                        let wrapper = &self.parent;
                        builder.field("parent", &wrapper)
                    };
                    builder.finish()
                }
            }
            /// Nested message and enum types in `CastAddBody`.
            pub mod cast_add_body {
                #[allow(clippy::derive_partial_eq_without_eq)]
                pub enum Parent {
                    /// Parent cast of the cast
                    #[prost(message, tag = "3")]
                    ParentCastId(super::CastId),
                    /// Parent URL
                    #[prost(string, tag = "7")]
                    ParentUrl(::prost::alloc::string::String),
                }
                #[automatically_derived]
                #[allow(clippy::derive_partial_eq_without_eq)]
                impl ::core::clone::Clone for Parent {
                    #[inline]
                    fn clone(&self) -> Parent {
                        match self {
                            Parent::ParentCastId(__self_0) => {
                                Parent::ParentCastId(::core::clone::Clone::clone(__self_0))
                            }
                            Parent::ParentUrl(__self_0) => {
                                Parent::ParentUrl(::core::clone::Clone::clone(__self_0))
                            }
                        }
                    }
                }
                #[allow(clippy::derive_partial_eq_without_eq)]
                #[automatically_derived]
                impl ::core::marker::StructuralPartialEq for Parent {}
                #[automatically_derived]
                #[allow(clippy::derive_partial_eq_without_eq)]
                impl ::core::cmp::PartialEq for Parent {
                    #[inline]
                    fn eq(&self, other: &Parent) -> bool {
                        let __self_tag = ::core::intrinsics::discriminant_value(self);
                        let __arg1_tag = ::core::intrinsics::discriminant_value(other);
                        __self_tag == __arg1_tag
                            && match (self, other) {
                                (
                                    Parent::ParentCastId(__self_0),
                                    Parent::ParentCastId(__arg1_0),
                                ) => *__self_0 == *__arg1_0,
                                (
                                    Parent::ParentUrl(__self_0),
                                    Parent::ParentUrl(__arg1_0),
                                ) => *__self_0 == *__arg1_0,
                                _ => unsafe { ::core::intrinsics::unreachable() }
                            }
                    }
                }
                impl Parent {
                    /// Encodes the message to a buffer.
                    pub fn encode<B>(&self, buf: &mut B)
                    where
                        B: ::prost::bytes::BufMut,
                    {
                        match *self {
                            Parent::ParentCastId(ref value) => {
                                ::prost::encoding::message::encode(3u32, &*value, buf);
                            }
                            Parent::ParentUrl(ref value) => {
                                ::prost::encoding::string::encode(7u32, &*value, buf);
                            }
                        }
                    }
                    /// Decodes an instance of the message from a buffer, and merges it into self.
                    pub fn merge<B>(
                        field: &mut ::core::option::Option<Parent>,
                        tag: u32,
                        wire_type: ::prost::encoding::WireType,
                        buf: &mut B,
                        ctx: ::prost::encoding::DecodeContext,
                    ) -> ::core::result::Result<(), ::prost::DecodeError>
                    where
                        B: ::prost::bytes::Buf,
                    {
                        match tag {
                            3u32 => {
                                match field {
                                    ::core::option::Option::Some(
                                        Parent::ParentCastId(ref mut value),
                                    ) => {
                                        ::prost::encoding::message::merge(
                                            wire_type,
                                            value,
                                            buf,
                                            ctx,
                                        )
                                    }
                                    _ => {
                                        let mut owned_value = ::core::default::Default::default();
                                        let value = &mut owned_value;
                                        ::prost::encoding::message::merge(
                                                wire_type,
                                                value,
                                                buf,
                                                ctx,
                                            )
                                            .map(|_| {
                                                *field = ::core::option::Option::Some(
                                                    Parent::ParentCastId(owned_value),
                                                );
                                            })
                                    }
                                }
                            }
                            7u32 => {
                                match field {
                                    ::core::option::Option::Some(
                                        Parent::ParentUrl(ref mut value),
                                    ) => {
                                        ::prost::encoding::string::merge(wire_type, value, buf, ctx)
                                    }
                                    _ => {
                                        let mut owned_value = ::core::default::Default::default();
                                        let value = &mut owned_value;
                                        ::prost::encoding::string::merge(wire_type, value, buf, ctx)
                                            .map(|_| {
                                                *field = ::core::option::Option::Some(
                                                    Parent::ParentUrl(owned_value),
                                                );
                                            })
                                    }
                                }
                            }
                            _ => {
                                ::core::panicking::panic_fmt(
                                    format_args!(
                                        "internal error: entered unreachable code: {0}",
                                        format_args!("invalid Parent tag: {0}", tag),
                                    ),
                                );
                            }
                        }
                    }
                    /// Returns the encoded length of the message without a length delimiter.
                    #[inline]
                    pub fn encoded_len(&self) -> usize {
                        match *self {
                            Parent::ParentCastId(ref value) => {
                                ::prost::encoding::message::encoded_len(3u32, &*value)
                            }
                            Parent::ParentUrl(ref value) => {
                                ::prost::encoding::string::encoded_len(7u32, &*value)
                            }
                        }
                    }
                }
                impl ::core::fmt::Debug for Parent {
                    fn fmt(
                        &self,
                        f: &mut ::core::fmt::Formatter,
                    ) -> ::core::fmt::Result {
                        match *self {
                            Parent::ParentCastId(ref value) => {
                                let wrapper = &*value;
                                f.debug_tuple("ParentCastId").field(&wrapper).finish()
                            }
                            Parent::ParentUrl(ref value) => {
                                let wrapper = {
                                    fn ScalarWrapper<T>(v: T) -> T {
                                        v
                                    }
                                    ScalarWrapper(&*value)
                                };
                                f.debug_tuple("ParentUrl").field(&wrapper).finish()
                            }
                        }
                    }
                }
            }
            /// * Removes an existing Cast
            #[allow(clippy::derive_partial_eq_without_eq)]
            pub struct CastRemoveBody {
                /// Hash of the cast to remove
                #[prost(bytes = "vec", tag = "1")]
                pub target_hash: ::prost::alloc::vec::Vec<u8>,
            }
            #[automatically_derived]
            #[allow(clippy::derive_partial_eq_without_eq)]
            impl ::core::clone::Clone for CastRemoveBody {
                #[inline]
                fn clone(&self) -> CastRemoveBody {
                    CastRemoveBody {
                        target_hash: ::core::clone::Clone::clone(&self.target_hash),
                    }
                }
            }
            #[allow(clippy::derive_partial_eq_without_eq)]
            #[automatically_derived]
            impl ::core::marker::StructuralPartialEq for CastRemoveBody {}
            #[automatically_derived]
            #[allow(clippy::derive_partial_eq_without_eq)]
            impl ::core::cmp::PartialEq for CastRemoveBody {
                #[inline]
                fn eq(&self, other: &CastRemoveBody) -> bool {
                    self.target_hash == other.target_hash
                }
            }
            impl ::prost::Message for CastRemoveBody {
                #[allow(unused_variables)]
                fn encode_raw<B>(&self, buf: &mut B)
                where
                    B: ::prost::bytes::BufMut,
                {
                    if self.target_hash != b"" as &[u8] {
                        ::prost::encoding::bytes::encode(1u32, &self.target_hash, buf);
                    }
                }
                #[allow(unused_variables)]
                fn merge_field<B>(
                    &mut self,
                    tag: u32,
                    wire_type: ::prost::encoding::WireType,
                    buf: &mut B,
                    ctx: ::prost::encoding::DecodeContext,
                ) -> ::core::result::Result<(), ::prost::DecodeError>
                where
                    B: ::prost::bytes::Buf,
                {
                    const STRUCT_NAME: &'static str = "CastRemoveBody";
                    match tag {
                        1u32 => {
                            let mut value = &mut self.target_hash;
                            ::prost::encoding::bytes::merge(wire_type, value, buf, ctx)
                                .map_err(|mut error| {
                                    error.push(STRUCT_NAME, "target_hash");
                                    error
                                })
                        }
                        _ => ::prost::encoding::skip_field(wire_type, tag, buf, ctx),
                    }
                }
                #[inline]
                fn encoded_len(&self) -> usize {
                    0
                        + if self.target_hash != b"" as &[u8] {
                            ::prost::encoding::bytes::encoded_len(
                                1u32,
                                &self.target_hash,
                            )
                        } else {
                            0
                        }
                }
                fn clear(&mut self) {
                    self.target_hash.clear();
                }
            }
            impl ::core::default::Default for CastRemoveBody {
                fn default() -> Self {
                    CastRemoveBody {
                        target_hash: ::core::default::Default::default(),
                    }
                }
            }
            impl ::core::fmt::Debug for CastRemoveBody {
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    let mut builder = f.debug_struct("CastRemoveBody");
                    let builder = {
                        let wrapper = {
                            fn ScalarWrapper<T>(v: T) -> T {
                                v
                            }
                            ScalarWrapper(&self.target_hash)
                        };
                        builder.field("target_hash", &wrapper)
                    };
                    builder.finish()
                }
            }
            /// * Identifier used to look up a Cast
            #[allow(clippy::derive_partial_eq_without_eq)]
            pub struct CastId {
                /// Fid of the user who created the cast
                #[prost(uint64, tag = "1")]
                pub fid: u64,
                /// Hash of the cast
                #[prost(bytes = "vec", tag = "2")]
                pub hash: ::prost::alloc::vec::Vec<u8>,
            }
            #[automatically_derived]
            #[allow(clippy::derive_partial_eq_without_eq)]
            impl ::core::clone::Clone for CastId {
                #[inline]
                fn clone(&self) -> CastId {
                    CastId {
                        fid: ::core::clone::Clone::clone(&self.fid),
                        hash: ::core::clone::Clone::clone(&self.hash),
                    }
                }
            }
            #[allow(clippy::derive_partial_eq_without_eq)]
            #[automatically_derived]
            impl ::core::marker::StructuralPartialEq for CastId {}
            #[automatically_derived]
            #[allow(clippy::derive_partial_eq_without_eq)]
            impl ::core::cmp::PartialEq for CastId {
                #[inline]
                fn eq(&self, other: &CastId) -> bool {
                    self.fid == other.fid && self.hash == other.hash
                }
            }
            impl ::prost::Message for CastId {
                #[allow(unused_variables)]
                fn encode_raw<B>(&self, buf: &mut B)
                where
                    B: ::prost::bytes::BufMut,
                {
                    if self.fid != 0u64 {
                        ::prost::encoding::uint64::encode(1u32, &self.fid, buf);
                    }
                    if self.hash != b"" as &[u8] {
                        ::prost::encoding::bytes::encode(2u32, &self.hash, buf);
                    }
                }
                #[allow(unused_variables)]
                fn merge_field<B>(
                    &mut self,
                    tag: u32,
                    wire_type: ::prost::encoding::WireType,
                    buf: &mut B,
                    ctx: ::prost::encoding::DecodeContext,
                ) -> ::core::result::Result<(), ::prost::DecodeError>
                where
                    B: ::prost::bytes::Buf,
                {
                    const STRUCT_NAME: &'static str = "CastId";
                    match tag {
                        1u32 => {
                            let mut value = &mut self.fid;
                            ::prost::encoding::uint64::merge(wire_type, value, buf, ctx)
                                .map_err(|mut error| {
                                    error.push(STRUCT_NAME, "fid");
                                    error
                                })
                        }
                        2u32 => {
                            let mut value = &mut self.hash;
                            ::prost::encoding::bytes::merge(wire_type, value, buf, ctx)
                                .map_err(|mut error| {
                                    error.push(STRUCT_NAME, "hash");
                                    error
                                })
                        }
                        _ => ::prost::encoding::skip_field(wire_type, tag, buf, ctx),
                    }
                }
                #[inline]
                fn encoded_len(&self) -> usize {
                    0
                        + if self.fid != 0u64 {
                            ::prost::encoding::uint64::encoded_len(1u32, &self.fid)
                        } else {
                            0
                        }
                        + if self.hash != b"" as &[u8] {
                            ::prost::encoding::bytes::encoded_len(2u32, &self.hash)
                        } else {
                            0
                        }
                }
                fn clear(&mut self) {
                    self.fid = 0u64;
                    self.hash.clear();
                }
            }
            impl ::core::default::Default for CastId {
                fn default() -> Self {
                    CastId {
                        fid: 0u64,
                        hash: ::core::default::Default::default(),
                    }
                }
            }
            impl ::core::fmt::Debug for CastId {
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    let mut builder = f.debug_struct("CastId");
                    let builder = {
                        let wrapper = {
                            fn ScalarWrapper<T>(v: T) -> T {
                                v
                            }
                            ScalarWrapper(&self.fid)
                        };
                        builder.field("fid", &wrapper)
                    };
                    let builder = {
                        let wrapper = {
                            fn ScalarWrapper<T>(v: T) -> T {
                                v
                            }
                            ScalarWrapper(&self.hash)
                        };
                        builder.field("hash", &wrapper)
                    };
                    builder.finish()
                }
            }
            /// * Adds or removes a Reaction from a Cast
            #[allow(clippy::derive_partial_eq_without_eq)]
            pub struct ReactionBody {
                /// Type of reaction
                #[prost(enumeration = "ReactionType", tag = "1")]
                pub r#type: i32,
                #[prost(oneof = "reaction_body::Target", tags = "2, 3")]
                pub target: ::core::option::Option<reaction_body::Target>,
            }
            #[automatically_derived]
            #[allow(clippy::derive_partial_eq_without_eq)]
            impl ::core::clone::Clone for ReactionBody {
                #[inline]
                fn clone(&self) -> ReactionBody {
                    ReactionBody {
                        r#type: ::core::clone::Clone::clone(&self.r#type),
                        target: ::core::clone::Clone::clone(&self.target),
                    }
                }
            }
            #[allow(clippy::derive_partial_eq_without_eq)]
            #[automatically_derived]
            impl ::core::marker::StructuralPartialEq for ReactionBody {}
            #[automatically_derived]
            #[allow(clippy::derive_partial_eq_without_eq)]
            impl ::core::cmp::PartialEq for ReactionBody {
                #[inline]
                fn eq(&self, other: &ReactionBody) -> bool {
                    self.r#type == other.r#type && self.target == other.target
                }
            }
            impl ::prost::Message for ReactionBody {
                #[allow(unused_variables)]
                fn encode_raw<B>(&self, buf: &mut B)
                where
                    B: ::prost::bytes::BufMut,
                {
                    if self.r#type != ReactionType::default() as i32 {
                        ::prost::encoding::int32::encode(1u32, &self.r#type, buf);
                    }
                    if let Some(ref oneof) = self.target {
                        oneof.encode(buf)
                    }
                }
                #[allow(unused_variables)]
                fn merge_field<B>(
                    &mut self,
                    tag: u32,
                    wire_type: ::prost::encoding::WireType,
                    buf: &mut B,
                    ctx: ::prost::encoding::DecodeContext,
                ) -> ::core::result::Result<(), ::prost::DecodeError>
                where
                    B: ::prost::bytes::Buf,
                {
                    const STRUCT_NAME: &'static str = "ReactionBody";
                    match tag {
                        1u32 => {
                            let mut value = &mut self.r#type;
                            ::prost::encoding::int32::merge(wire_type, value, buf, ctx)
                                .map_err(|mut error| {
                                    error.push(STRUCT_NAME, "r#type");
                                    error
                                })
                        }
                        2u32 | 3u32 => {
                            let mut value = &mut self.target;
                            reaction_body::Target::merge(value, tag, wire_type, buf, ctx)
                                .map_err(|mut error| {
                                    error.push(STRUCT_NAME, "target");
                                    error
                                })
                        }
                        _ => ::prost::encoding::skip_field(wire_type, tag, buf, ctx),
                    }
                }
                #[inline]
                fn encoded_len(&self) -> usize {
                    0
                        + if self.r#type != ReactionType::default() as i32 {
                            ::prost::encoding::int32::encoded_len(1u32, &self.r#type)
                        } else {
                            0
                        }
                        + self
                            .target
                            .as_ref()
                            .map_or(0, reaction_body::Target::encoded_len)
                }
                fn clear(&mut self) {
                    self.r#type = ReactionType::default() as i32;
                    self.target = ::core::option::Option::None;
                }
            }
            impl ::core::default::Default for ReactionBody {
                fn default() -> Self {
                    ReactionBody {
                        r#type: ReactionType::default() as i32,
                        target: ::core::default::Default::default(),
                    }
                }
            }
            impl ::core::fmt::Debug for ReactionBody {
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    let mut builder = f.debug_struct("ReactionBody");
                    let builder = {
                        let wrapper = {
                            struct ScalarWrapper<'a>(&'a i32);
                            impl<'a> ::core::fmt::Debug for ScalarWrapper<'a> {
                                fn fmt(
                                    &self,
                                    f: &mut ::core::fmt::Formatter,
                                ) -> ::core::fmt::Result {
                                    match ReactionType::from_i32(*self.0) {
                                        None => ::core::fmt::Debug::fmt(&self.0, f),
                                        Some(en) => ::core::fmt::Debug::fmt(&en, f),
                                    }
                                }
                            }
                            ScalarWrapper(&self.r#type)
                        };
                        builder.field("r#type", &wrapper)
                    };
                    let builder = {
                        let wrapper = &self.target;
                        builder.field("target", &wrapper)
                    };
                    builder.finish()
                }
            }
            #[allow(dead_code)]
            impl ReactionBody {
                ///Returns the enum value of `type`, or the default if the field is set to an invalid enum value.
                pub fn r#type(&self) -> ReactionType {
                    ReactionType::from_i32(self.r#type)
                        .unwrap_or(ReactionType::default())
                }
                ///Sets `type` to the provided enum value.
                pub fn set_type(&mut self, value: ReactionType) {
                    self.r#type = value as i32;
                }
            }
            /// Nested message and enum types in `ReactionBody`.
            pub mod reaction_body {
                #[allow(clippy::derive_partial_eq_without_eq)]
                pub enum Target {
                    /// CastId of the Cast to react to
                    #[prost(message, tag = "2")]
                    TargetCastId(super::CastId),
                    /// URL to react to
                    #[prost(string, tag = "3")]
                    TargetUrl(::prost::alloc::string::String),
                }
                #[automatically_derived]
                #[allow(clippy::derive_partial_eq_without_eq)]
                impl ::core::clone::Clone for Target {
                    #[inline]
                    fn clone(&self) -> Target {
                        match self {
                            Target::TargetCastId(__self_0) => {
                                Target::TargetCastId(::core::clone::Clone::clone(__self_0))
                            }
                            Target::TargetUrl(__self_0) => {
                                Target::TargetUrl(::core::clone::Clone::clone(__self_0))
                            }
                        }
                    }
                }
                #[allow(clippy::derive_partial_eq_without_eq)]
                #[automatically_derived]
                impl ::core::marker::StructuralPartialEq for Target {}
                #[automatically_derived]
                #[allow(clippy::derive_partial_eq_without_eq)]
                impl ::core::cmp::PartialEq for Target {
                    #[inline]
                    fn eq(&self, other: &Target) -> bool {
                        let __self_tag = ::core::intrinsics::discriminant_value(self);
                        let __arg1_tag = ::core::intrinsics::discriminant_value(other);
                        __self_tag == __arg1_tag
                            && match (self, other) {
                                (
                                    Target::TargetCastId(__self_0),
                                    Target::TargetCastId(__arg1_0),
                                ) => *__self_0 == *__arg1_0,
                                (
                                    Target::TargetUrl(__self_0),
                                    Target::TargetUrl(__arg1_0),
                                ) => *__self_0 == *__arg1_0,
                                _ => unsafe { ::core::intrinsics::unreachable() }
                            }
                    }
                }
                impl Target {
                    /// Encodes the message to a buffer.
                    pub fn encode<B>(&self, buf: &mut B)
                    where
                        B: ::prost::bytes::BufMut,
                    {
                        match *self {
                            Target::TargetCastId(ref value) => {
                                ::prost::encoding::message::encode(2u32, &*value, buf);
                            }
                            Target::TargetUrl(ref value) => {
                                ::prost::encoding::string::encode(3u32, &*value, buf);
                            }
                        }
                    }
                    /// Decodes an instance of the message from a buffer, and merges it into self.
                    pub fn merge<B>(
                        field: &mut ::core::option::Option<Target>,
                        tag: u32,
                        wire_type: ::prost::encoding::WireType,
                        buf: &mut B,
                        ctx: ::prost::encoding::DecodeContext,
                    ) -> ::core::result::Result<(), ::prost::DecodeError>
                    where
                        B: ::prost::bytes::Buf,
                    {
                        match tag {
                            2u32 => {
                                match field {
                                    ::core::option::Option::Some(
                                        Target::TargetCastId(ref mut value),
                                    ) => {
                                        ::prost::encoding::message::merge(
                                            wire_type,
                                            value,
                                            buf,
                                            ctx,
                                        )
                                    }
                                    _ => {
                                        let mut owned_value = ::core::default::Default::default();
                                        let value = &mut owned_value;
                                        ::prost::encoding::message::merge(
                                                wire_type,
                                                value,
                                                buf,
                                                ctx,
                                            )
                                            .map(|_| {
                                                *field = ::core::option::Option::Some(
                                                    Target::TargetCastId(owned_value),
                                                );
                                            })
                                    }
                                }
                            }
                            3u32 => {
                                match field {
                                    ::core::option::Option::Some(
                                        Target::TargetUrl(ref mut value),
                                    ) => {
                                        ::prost::encoding::string::merge(wire_type, value, buf, ctx)
                                    }
                                    _ => {
                                        let mut owned_value = ::core::default::Default::default();
                                        let value = &mut owned_value;
                                        ::prost::encoding::string::merge(wire_type, value, buf, ctx)
                                            .map(|_| {
                                                *field = ::core::option::Option::Some(
                                                    Target::TargetUrl(owned_value),
                                                );
                                            })
                                    }
                                }
                            }
                            _ => {
                                ::core::panicking::panic_fmt(
                                    format_args!(
                                        "internal error: entered unreachable code: {0}",
                                        format_args!("invalid Target tag: {0}", tag),
                                    ),
                                );
                            }
                        }
                    }
                    /// Returns the encoded length of the message without a length delimiter.
                    #[inline]
                    pub fn encoded_len(&self) -> usize {
                        match *self {
                            Target::TargetCastId(ref value) => {
                                ::prost::encoding::message::encoded_len(2u32, &*value)
                            }
                            Target::TargetUrl(ref value) => {
                                ::prost::encoding::string::encoded_len(3u32, &*value)
                            }
                        }
                    }
                }
                impl ::core::fmt::Debug for Target {
                    fn fmt(
                        &self,
                        f: &mut ::core::fmt::Formatter,
                    ) -> ::core::fmt::Result {
                        match *self {
                            Target::TargetCastId(ref value) => {
                                let wrapper = &*value;
                                f.debug_tuple("TargetCastId").field(&wrapper).finish()
                            }
                            Target::TargetUrl(ref value) => {
                                let wrapper = {
                                    fn ScalarWrapper<T>(v: T) -> T {
                                        v
                                    }
                                    ScalarWrapper(&*value)
                                };
                                f.debug_tuple("TargetUrl").field(&wrapper).finish()
                            }
                        }
                    }
                }
            }
            /// * Adds a Verification of ownership of an Ethereum Address
            #[allow(clippy::derive_partial_eq_without_eq)]
            pub struct VerificationAddEthAddressBody {
                /// Ethereum address being verified
                #[prost(bytes = "vec", tag = "1")]
                pub address: ::prost::alloc::vec::Vec<u8>,
                /// Signature produced by the user's Ethereum address
                #[prost(bytes = "vec", tag = "2")]
                pub eth_signature: ::prost::alloc::vec::Vec<u8>,
                /// Hash of the latest Ethereum block when the signature was produced
                #[prost(bytes = "vec", tag = "3")]
                pub block_hash: ::prost::alloc::vec::Vec<u8>,
            }
            #[automatically_derived]
            #[allow(clippy::derive_partial_eq_without_eq)]
            impl ::core::clone::Clone for VerificationAddEthAddressBody {
                #[inline]
                fn clone(&self) -> VerificationAddEthAddressBody {
                    VerificationAddEthAddressBody {
                        address: ::core::clone::Clone::clone(&self.address),
                        eth_signature: ::core::clone::Clone::clone(&self.eth_signature),
                        block_hash: ::core::clone::Clone::clone(&self.block_hash),
                    }
                }
            }
            #[allow(clippy::derive_partial_eq_without_eq)]
            #[automatically_derived]
            impl ::core::marker::StructuralPartialEq for VerificationAddEthAddressBody {}
            #[automatically_derived]
            #[allow(clippy::derive_partial_eq_without_eq)]
            impl ::core::cmp::PartialEq for VerificationAddEthAddressBody {
                #[inline]
                fn eq(&self, other: &VerificationAddEthAddressBody) -> bool {
                    self.address == other.address
                        && self.eth_signature == other.eth_signature
                        && self.block_hash == other.block_hash
                }
            }
            impl ::prost::Message for VerificationAddEthAddressBody {
                #[allow(unused_variables)]
                fn encode_raw<B>(&self, buf: &mut B)
                where
                    B: ::prost::bytes::BufMut,
                {
                    if self.address != b"" as &[u8] {
                        ::prost::encoding::bytes::encode(1u32, &self.address, buf);
                    }
                    if self.eth_signature != b"" as &[u8] {
                        ::prost::encoding::bytes::encode(2u32, &self.eth_signature, buf);
                    }
                    if self.block_hash != b"" as &[u8] {
                        ::prost::encoding::bytes::encode(3u32, &self.block_hash, buf);
                    }
                }
                #[allow(unused_variables)]
                fn merge_field<B>(
                    &mut self,
                    tag: u32,
                    wire_type: ::prost::encoding::WireType,
                    buf: &mut B,
                    ctx: ::prost::encoding::DecodeContext,
                ) -> ::core::result::Result<(), ::prost::DecodeError>
                where
                    B: ::prost::bytes::Buf,
                {
                    const STRUCT_NAME: &'static str = "VerificationAddEthAddressBody";
                    match tag {
                        1u32 => {
                            let mut value = &mut self.address;
                            ::prost::encoding::bytes::merge(wire_type, value, buf, ctx)
                                .map_err(|mut error| {
                                    error.push(STRUCT_NAME, "address");
                                    error
                                })
                        }
                        2u32 => {
                            let mut value = &mut self.eth_signature;
                            ::prost::encoding::bytes::merge(wire_type, value, buf, ctx)
                                .map_err(|mut error| {
                                    error.push(STRUCT_NAME, "eth_signature");
                                    error
                                })
                        }
                        3u32 => {
                            let mut value = &mut self.block_hash;
                            ::prost::encoding::bytes::merge(wire_type, value, buf, ctx)
                                .map_err(|mut error| {
                                    error.push(STRUCT_NAME, "block_hash");
                                    error
                                })
                        }
                        _ => ::prost::encoding::skip_field(wire_type, tag, buf, ctx),
                    }
                }
                #[inline]
                fn encoded_len(&self) -> usize {
                    0
                        + if self.address != b"" as &[u8] {
                            ::prost::encoding::bytes::encoded_len(1u32, &self.address)
                        } else {
                            0
                        }
                        + if self.eth_signature != b"" as &[u8] {
                            ::prost::encoding::bytes::encoded_len(
                                2u32,
                                &self.eth_signature,
                            )
                        } else {
                            0
                        }
                        + if self.block_hash != b"" as &[u8] {
                            ::prost::encoding::bytes::encoded_len(3u32, &self.block_hash)
                        } else {
                            0
                        }
                }
                fn clear(&mut self) {
                    self.address.clear();
                    self.eth_signature.clear();
                    self.block_hash.clear();
                }
            }
            impl ::core::default::Default for VerificationAddEthAddressBody {
                fn default() -> Self {
                    VerificationAddEthAddressBody {
                        address: ::core::default::Default::default(),
                        eth_signature: ::core::default::Default::default(),
                        block_hash: ::core::default::Default::default(),
                    }
                }
            }
            impl ::core::fmt::Debug for VerificationAddEthAddressBody {
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    let mut builder = f.debug_struct("VerificationAddEthAddressBody");
                    let builder = {
                        let wrapper = {
                            fn ScalarWrapper<T>(v: T) -> T {
                                v
                            }
                            ScalarWrapper(&self.address)
                        };
                        builder.field("address", &wrapper)
                    };
                    let builder = {
                        let wrapper = {
                            fn ScalarWrapper<T>(v: T) -> T {
                                v
                            }
                            ScalarWrapper(&self.eth_signature)
                        };
                        builder.field("eth_signature", &wrapper)
                    };
                    let builder = {
                        let wrapper = {
                            fn ScalarWrapper<T>(v: T) -> T {
                                v
                            }
                            ScalarWrapper(&self.block_hash)
                        };
                        builder.field("block_hash", &wrapper)
                    };
                    builder.finish()
                }
            }
            /// * Removes a Verification of any type
            #[allow(clippy::derive_partial_eq_without_eq)]
            pub struct VerificationRemoveBody {
                /// Address of the Verification to remove
                #[prost(bytes = "vec", tag = "1")]
                pub address: ::prost::alloc::vec::Vec<u8>,
            }
            #[automatically_derived]
            #[allow(clippy::derive_partial_eq_without_eq)]
            impl ::core::clone::Clone for VerificationRemoveBody {
                #[inline]
                fn clone(&self) -> VerificationRemoveBody {
                    VerificationRemoveBody {
                        address: ::core::clone::Clone::clone(&self.address),
                    }
                }
            }
            #[allow(clippy::derive_partial_eq_without_eq)]
            #[automatically_derived]
            impl ::core::marker::StructuralPartialEq for VerificationRemoveBody {}
            #[automatically_derived]
            #[allow(clippy::derive_partial_eq_without_eq)]
            impl ::core::cmp::PartialEq for VerificationRemoveBody {
                #[inline]
                fn eq(&self, other: &VerificationRemoveBody) -> bool {
                    self.address == other.address
                }
            }
            impl ::prost::Message for VerificationRemoveBody {
                #[allow(unused_variables)]
                fn encode_raw<B>(&self, buf: &mut B)
                where
                    B: ::prost::bytes::BufMut,
                {
                    if self.address != b"" as &[u8] {
                        ::prost::encoding::bytes::encode(1u32, &self.address, buf);
                    }
                }
                #[allow(unused_variables)]
                fn merge_field<B>(
                    &mut self,
                    tag: u32,
                    wire_type: ::prost::encoding::WireType,
                    buf: &mut B,
                    ctx: ::prost::encoding::DecodeContext,
                ) -> ::core::result::Result<(), ::prost::DecodeError>
                where
                    B: ::prost::bytes::Buf,
                {
                    const STRUCT_NAME: &'static str = "VerificationRemoveBody";
                    match tag {
                        1u32 => {
                            let mut value = &mut self.address;
                            ::prost::encoding::bytes::merge(wire_type, value, buf, ctx)
                                .map_err(|mut error| {
                                    error.push(STRUCT_NAME, "address");
                                    error
                                })
                        }
                        _ => ::prost::encoding::skip_field(wire_type, tag, buf, ctx),
                    }
                }
                #[inline]
                fn encoded_len(&self) -> usize {
                    0
                        + if self.address != b"" as &[u8] {
                            ::prost::encoding::bytes::encoded_len(1u32, &self.address)
                        } else {
                            0
                        }
                }
                fn clear(&mut self) {
                    self.address.clear();
                }
            }
            impl ::core::default::Default for VerificationRemoveBody {
                fn default() -> Self {
                    VerificationRemoveBody {
                        address: ::core::default::Default::default(),
                    }
                }
            }
            impl ::core::fmt::Debug for VerificationRemoveBody {
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    let mut builder = f.debug_struct("VerificationRemoveBody");
                    let builder = {
                        let wrapper = {
                            fn ScalarWrapper<T>(v: T) -> T {
                                v
                            }
                            ScalarWrapper(&self.address)
                        };
                        builder.field("address", &wrapper)
                    };
                    builder.finish()
                }
            }
            /// * Adds or removes a Link
            #[allow(clippy::derive_partial_eq_without_eq)]
            pub struct LinkBody {
                /// Type of link, <= 8 characters
                #[prost(string, tag = "1")]
                pub r#type: ::prost::alloc::string::String,
                /// User-defined timestamp that preserves original timestamp when message.data.timestamp needs to be updated for compaction
                #[prost(uint32, optional, tag = "2")]
                pub display_timestamp: ::core::option::Option<u32>,
                #[prost(oneof = "link_body::Target", tags = "3")]
                pub target: ::core::option::Option<link_body::Target>,
            }
            #[automatically_derived]
            #[allow(clippy::derive_partial_eq_without_eq)]
            impl ::core::clone::Clone for LinkBody {
                #[inline]
                fn clone(&self) -> LinkBody {
                    LinkBody {
                        r#type: ::core::clone::Clone::clone(&self.r#type),
                        display_timestamp: ::core::clone::Clone::clone(
                            &self.display_timestamp,
                        ),
                        target: ::core::clone::Clone::clone(&self.target),
                    }
                }
            }
            #[allow(clippy::derive_partial_eq_without_eq)]
            #[automatically_derived]
            impl ::core::marker::StructuralPartialEq for LinkBody {}
            #[automatically_derived]
            #[allow(clippy::derive_partial_eq_without_eq)]
            impl ::core::cmp::PartialEq for LinkBody {
                #[inline]
                fn eq(&self, other: &LinkBody) -> bool {
                    self.r#type == other.r#type
                        && self.display_timestamp == other.display_timestamp
                        && self.target == other.target
                }
            }
            impl ::prost::Message for LinkBody {
                #[allow(unused_variables)]
                fn encode_raw<B>(&self, buf: &mut B)
                where
                    B: ::prost::bytes::BufMut,
                {
                    if self.r#type != "" {
                        ::prost::encoding::string::encode(1u32, &self.r#type, buf);
                    }
                    if let ::core::option::Option::Some(ref value)
                        = self.display_timestamp
                    {
                        ::prost::encoding::uint32::encode(2u32, value, buf);
                    }
                    if let Some(ref oneof) = self.target {
                        oneof.encode(buf)
                    }
                }
                #[allow(unused_variables)]
                fn merge_field<B>(
                    &mut self,
                    tag: u32,
                    wire_type: ::prost::encoding::WireType,
                    buf: &mut B,
                    ctx: ::prost::encoding::DecodeContext,
                ) -> ::core::result::Result<(), ::prost::DecodeError>
                where
                    B: ::prost::bytes::Buf,
                {
                    const STRUCT_NAME: &'static str = "LinkBody";
                    match tag {
                        1u32 => {
                            let mut value = &mut self.r#type;
                            ::prost::encoding::string::merge(wire_type, value, buf, ctx)
                                .map_err(|mut error| {
                                    error.push(STRUCT_NAME, "r#type");
                                    error
                                })
                        }
                        2u32 => {
                            let mut value = &mut self.display_timestamp;
                            ::prost::encoding::uint32::merge(
                                    wire_type,
                                    value.get_or_insert_with(::core::default::Default::default),
                                    buf,
                                    ctx,
                                )
                                .map_err(|mut error| {
                                    error.push(STRUCT_NAME, "display_timestamp");
                                    error
                                })
                        }
                        3u32 => {
                            let mut value = &mut self.target;
                            link_body::Target::merge(value, tag, wire_type, buf, ctx)
                                .map_err(|mut error| {
                                    error.push(STRUCT_NAME, "target");
                                    error
                                })
                        }
                        _ => ::prost::encoding::skip_field(wire_type, tag, buf, ctx),
                    }
                }
                #[inline]
                fn encoded_len(&self) -> usize {
                    0
                        + if self.r#type != "" {
                            ::prost::encoding::string::encoded_len(1u32, &self.r#type)
                        } else {
                            0
                        }
                        + self
                            .display_timestamp
                            .as_ref()
                            .map_or(
                                0,
                                |value| ::prost::encoding::uint32::encoded_len(2u32, value),
                            )
                        + self.target.as_ref().map_or(0, link_body::Target::encoded_len)
                }
                fn clear(&mut self) {
                    self.r#type.clear();
                    self.display_timestamp = ::core::option::Option::None;
                    self.target = ::core::option::Option::None;
                }
            }
            impl ::core::default::Default for LinkBody {
                fn default() -> Self {
                    LinkBody {
                        r#type: ::prost::alloc::string::String::new(),
                        display_timestamp: ::core::option::Option::None,
                        target: ::core::default::Default::default(),
                    }
                }
            }
            impl ::core::fmt::Debug for LinkBody {
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    let mut builder = f.debug_struct("LinkBody");
                    let builder = {
                        let wrapper = {
                            fn ScalarWrapper<T>(v: T) -> T {
                                v
                            }
                            ScalarWrapper(&self.r#type)
                        };
                        builder.field("r#type", &wrapper)
                    };
                    let builder = {
                        let wrapper = {
                            struct ScalarWrapper<'a>(&'a ::core::option::Option<u32>);
                            impl<'a> ::core::fmt::Debug for ScalarWrapper<'a> {
                                fn fmt(
                                    &self,
                                    f: &mut ::core::fmt::Formatter,
                                ) -> ::core::fmt::Result {
                                    fn Inner<T>(v: T) -> T {
                                        v
                                    }
                                    ::core::fmt::Debug::fmt(&self.0.as_ref().map(Inner), f)
                                }
                            }
                            ScalarWrapper(&self.display_timestamp)
                        };
                        builder.field("display_timestamp", &wrapper)
                    };
                    let builder = {
                        let wrapper = &self.target;
                        builder.field("target", &wrapper)
                    };
                    builder.finish()
                }
            }
            #[allow(dead_code)]
            impl LinkBody {
                ///Returns the value of `display_timestamp`, or the default value if `display_timestamp` is unset.
                pub fn display_timestamp(&self) -> u32 {
                    match self.display_timestamp {
                        ::core::option::Option::Some(val) => val,
                        ::core::option::Option::None => 0u32,
                    }
                }
            }
            /// Nested message and enum types in `LinkBody`.
            pub mod link_body {
                #[allow(clippy::derive_partial_eq_without_eq)]
                pub enum Target {
                    /// The fid the link relates to
                    #[prost(uint64, tag = "3")]
                    TargetFid(u64),
                }
                #[automatically_derived]
                #[allow(clippy::derive_partial_eq_without_eq)]
                impl ::core::clone::Clone for Target {
                    #[inline]
                    fn clone(&self) -> Target {
                        match self {
                            Target::TargetFid(__self_0) => {
                                Target::TargetFid(::core::clone::Clone::clone(__self_0))
                            }
                        }
                    }
                }
                #[allow(clippy::derive_partial_eq_without_eq)]
                #[automatically_derived]
                impl ::core::marker::StructuralPartialEq for Target {}
                #[automatically_derived]
                #[allow(clippy::derive_partial_eq_without_eq)]
                impl ::core::cmp::PartialEq for Target {
                    #[inline]
                    fn eq(&self, other: &Target) -> bool {
                        match (self, other) {
                            (
                                Target::TargetFid(__self_0),
                                Target::TargetFid(__arg1_0),
                            ) => *__self_0 == *__arg1_0,
                        }
                    }
                }
                impl Target {
                    /// Encodes the message to a buffer.
                    pub fn encode<B>(&self, buf: &mut B)
                    where
                        B: ::prost::bytes::BufMut,
                    {
                        match *self {
                            Target::TargetFid(ref value) => {
                                ::prost::encoding::uint64::encode(3u32, &*value, buf);
                            }
                        }
                    }
                    /// Decodes an instance of the message from a buffer, and merges it into self.
                    pub fn merge<B>(
                        field: &mut ::core::option::Option<Target>,
                        tag: u32,
                        wire_type: ::prost::encoding::WireType,
                        buf: &mut B,
                        ctx: ::prost::encoding::DecodeContext,
                    ) -> ::core::result::Result<(), ::prost::DecodeError>
                    where
                        B: ::prost::bytes::Buf,
                    {
                        match tag {
                            3u32 => {
                                match field {
                                    ::core::option::Option::Some(
                                        Target::TargetFid(ref mut value),
                                    ) => {
                                        ::prost::encoding::uint64::merge(wire_type, value, buf, ctx)
                                    }
                                    _ => {
                                        let mut owned_value = ::core::default::Default::default();
                                        let value = &mut owned_value;
                                        ::prost::encoding::uint64::merge(wire_type, value, buf, ctx)
                                            .map(|_| {
                                                *field = ::core::option::Option::Some(
                                                    Target::TargetFid(owned_value),
                                                );
                                            })
                                    }
                                }
                            }
                            _ => {
                                ::core::panicking::panic_fmt(
                                    format_args!(
                                        "internal error: entered unreachable code: {0}",
                                        format_args!("invalid Target tag: {0}", tag),
                                    ),
                                );
                            }
                        }
                    }
                    /// Returns the encoded length of the message without a length delimiter.
                    #[inline]
                    pub fn encoded_len(&self) -> usize {
                        match *self {
                            Target::TargetFid(ref value) => {
                                ::prost::encoding::uint64::encoded_len(3u32, &*value)
                            }
                        }
                    }
                }
                impl ::core::fmt::Debug for Target {
                    fn fmt(
                        &self,
                        f: &mut ::core::fmt::Formatter,
                    ) -> ::core::fmt::Result {
                        match *self {
                            Target::TargetFid(ref value) => {
                                let wrapper = {
                                    fn ScalarWrapper<T>(v: T) -> T {
                                        v
                                    }
                                    ScalarWrapper(&*value)
                                };
                                f.debug_tuple("TargetFid").field(&wrapper).finish()
                            }
                        }
                    }
                }
            }
            /// * Type of hashing scheme used to produce a digest of MessageData
            #[repr(i32)]
            pub enum HashScheme {
                None = 0,
                /// Default scheme for hashing MessageData
                Blake3 = 1,
            }
            #[automatically_derived]
            impl ::core::clone::Clone for HashScheme {
                #[inline]
                fn clone(&self) -> HashScheme {
                    *self
                }
            }
            #[automatically_derived]
            impl ::core::marker::Copy for HashScheme {}
            #[automatically_derived]
            impl ::core::fmt::Debug for HashScheme {
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    ::core::fmt::Formatter::write_str(
                        f,
                        match self {
                            HashScheme::None => "None",
                            HashScheme::Blake3 => "Blake3",
                        },
                    )
                }
            }
            #[automatically_derived]
            impl ::core::marker::StructuralPartialEq for HashScheme {}
            #[automatically_derived]
            impl ::core::cmp::PartialEq for HashScheme {
                #[inline]
                fn eq(&self, other: &HashScheme) -> bool {
                    let __self_tag = ::core::intrinsics::discriminant_value(self);
                    let __arg1_tag = ::core::intrinsics::discriminant_value(other);
                    __self_tag == __arg1_tag
                }
            }
            #[automatically_derived]
            impl ::core::marker::StructuralEq for HashScheme {}
            #[automatically_derived]
            impl ::core::cmp::Eq for HashScheme {
                #[inline]
                #[doc(hidden)]
                #[no_coverage]
                fn assert_receiver_is_total_eq(&self) -> () {}
            }
            #[automatically_derived]
            impl ::core::hash::Hash for HashScheme {
                fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {
                    let __self_tag = ::core::intrinsics::discriminant_value(self);
                    ::core::hash::Hash::hash(&__self_tag, state)
                }
            }
            #[automatically_derived]
            impl ::core::cmp::PartialOrd for HashScheme {
                #[inline]
                fn partial_cmp(
                    &self,
                    other: &HashScheme,
                ) -> ::core::option::Option<::core::cmp::Ordering> {
                    let __self_tag = ::core::intrinsics::discriminant_value(self);
                    let __arg1_tag = ::core::intrinsics::discriminant_value(other);
                    ::core::cmp::PartialOrd::partial_cmp(&__self_tag, &__arg1_tag)
                }
            }
            #[automatically_derived]
            impl ::core::cmp::Ord for HashScheme {
                #[inline]
                fn cmp(&self, other: &HashScheme) -> ::core::cmp::Ordering {
                    let __self_tag = ::core::intrinsics::discriminant_value(self);
                    let __arg1_tag = ::core::intrinsics::discriminant_value(other);
                    ::core::cmp::Ord::cmp(&__self_tag, &__arg1_tag)
                }
            }
            impl HashScheme {
                ///Returns `true` if `value` is a variant of `HashScheme`.
                pub fn is_valid(value: i32) -> bool {
                    match value {
                        0 => true,
                        1 => true,
                        _ => false,
                    }
                }
                ///Converts an `i32` to a `HashScheme`, or `None` if `value` is not a valid variant.
                pub fn from_i32(value: i32) -> ::core::option::Option<HashScheme> {
                    match value {
                        0 => ::core::option::Option::Some(HashScheme::None),
                        1 => ::core::option::Option::Some(HashScheme::Blake3),
                        _ => ::core::option::Option::None,
                    }
                }
            }
            impl ::core::default::Default for HashScheme {
                fn default() -> HashScheme {
                    HashScheme::None
                }
            }
            impl ::core::convert::From<HashScheme> for i32 {
                fn from(value: HashScheme) -> i32 {
                    value as i32
                }
            }
            impl HashScheme {
                /// String value of the enum field names used in the ProtoBuf definition.
                ///
                /// The values are not transformed in any way and thus are considered stable
                /// (if the ProtoBuf definition does not change) and safe for programmatic use.
                pub fn as_str_name(&self) -> &'static str {
                    match self {
                        HashScheme::None => "HASH_SCHEME_NONE",
                        HashScheme::Blake3 => "HASH_SCHEME_BLAKE3",
                    }
                }
                /// Creates an enum from field names used in the ProtoBuf definition.
                pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
                    match value {
                        "HASH_SCHEME_NONE" => Some(Self::None),
                        "HASH_SCHEME_BLAKE3" => Some(Self::Blake3),
                        _ => None,
                    }
                }
            }
            /// * Type of signature scheme used to sign the Message hash
            #[repr(i32)]
            pub enum SignatureScheme {
                None = 0,
                /// Ed25519 signature (default)
                Ed25519 = 1,
                /// ECDSA signature using EIP-712 scheme
                Eip712 = 2,
            }
            #[automatically_derived]
            impl ::core::clone::Clone for SignatureScheme {
                #[inline]
                fn clone(&self) -> SignatureScheme {
                    *self
                }
            }
            #[automatically_derived]
            impl ::core::marker::Copy for SignatureScheme {}
            #[automatically_derived]
            impl ::core::fmt::Debug for SignatureScheme {
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    ::core::fmt::Formatter::write_str(
                        f,
                        match self {
                            SignatureScheme::None => "None",
                            SignatureScheme::Ed25519 => "Ed25519",
                            SignatureScheme::Eip712 => "Eip712",
                        },
                    )
                }
            }
            #[automatically_derived]
            impl ::core::marker::StructuralPartialEq for SignatureScheme {}
            #[automatically_derived]
            impl ::core::cmp::PartialEq for SignatureScheme {
                #[inline]
                fn eq(&self, other: &SignatureScheme) -> bool {
                    let __self_tag = ::core::intrinsics::discriminant_value(self);
                    let __arg1_tag = ::core::intrinsics::discriminant_value(other);
                    __self_tag == __arg1_tag
                }
            }
            #[automatically_derived]
            impl ::core::marker::StructuralEq for SignatureScheme {}
            #[automatically_derived]
            impl ::core::cmp::Eq for SignatureScheme {
                #[inline]
                #[doc(hidden)]
                #[no_coverage]
                fn assert_receiver_is_total_eq(&self) -> () {}
            }
            #[automatically_derived]
            impl ::core::hash::Hash for SignatureScheme {
                fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {
                    let __self_tag = ::core::intrinsics::discriminant_value(self);
                    ::core::hash::Hash::hash(&__self_tag, state)
                }
            }
            #[automatically_derived]
            impl ::core::cmp::PartialOrd for SignatureScheme {
                #[inline]
                fn partial_cmp(
                    &self,
                    other: &SignatureScheme,
                ) -> ::core::option::Option<::core::cmp::Ordering> {
                    let __self_tag = ::core::intrinsics::discriminant_value(self);
                    let __arg1_tag = ::core::intrinsics::discriminant_value(other);
                    ::core::cmp::PartialOrd::partial_cmp(&__self_tag, &__arg1_tag)
                }
            }
            #[automatically_derived]
            impl ::core::cmp::Ord for SignatureScheme {
                #[inline]
                fn cmp(&self, other: &SignatureScheme) -> ::core::cmp::Ordering {
                    let __self_tag = ::core::intrinsics::discriminant_value(self);
                    let __arg1_tag = ::core::intrinsics::discriminant_value(other);
                    ::core::cmp::Ord::cmp(&__self_tag, &__arg1_tag)
                }
            }
            impl SignatureScheme {
                ///Returns `true` if `value` is a variant of `SignatureScheme`.
                pub fn is_valid(value: i32) -> bool {
                    match value {
                        0 => true,
                        1 => true,
                        2 => true,
                        _ => false,
                    }
                }
                ///Converts an `i32` to a `SignatureScheme`, or `None` if `value` is not a valid variant.
                pub fn from_i32(value: i32) -> ::core::option::Option<SignatureScheme> {
                    match value {
                        0 => ::core::option::Option::Some(SignatureScheme::None),
                        1 => ::core::option::Option::Some(SignatureScheme::Ed25519),
                        2 => ::core::option::Option::Some(SignatureScheme::Eip712),
                        _ => ::core::option::Option::None,
                    }
                }
            }
            impl ::core::default::Default for SignatureScheme {
                fn default() -> SignatureScheme {
                    SignatureScheme::None
                }
            }
            impl ::core::convert::From<SignatureScheme> for i32 {
                fn from(value: SignatureScheme) -> i32 {
                    value as i32
                }
            }
            impl SignatureScheme {
                /// String value of the enum field names used in the ProtoBuf definition.
                ///
                /// The values are not transformed in any way and thus are considered stable
                /// (if the ProtoBuf definition does not change) and safe for programmatic use.
                pub fn as_str_name(&self) -> &'static str {
                    match self {
                        SignatureScheme::None => "SIGNATURE_SCHEME_NONE",
                        SignatureScheme::Ed25519 => "SIGNATURE_SCHEME_ED25519",
                        SignatureScheme::Eip712 => "SIGNATURE_SCHEME_EIP712",
                    }
                }
                /// Creates an enum from field names used in the ProtoBuf definition.
                pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
                    match value {
                        "SIGNATURE_SCHEME_NONE" => Some(Self::None),
                        "SIGNATURE_SCHEME_ED25519" => Some(Self::Ed25519),
                        "SIGNATURE_SCHEME_EIP712" => Some(Self::Eip712),
                        _ => None,
                    }
                }
            }
            /// * Type of the MessageBody
            #[repr(i32)]
            pub enum MessageType {
                None = 0,
                /// Add a new Cast
                CastAdd = 1,
                /// Remove an existing Cast
                CastRemove = 2,
                /// Add a Reaction to a Cast
                ReactionAdd = 3,
                /// Remove a Reaction from a Cast
                ReactionRemove = 4,
                /// Add a new Link
                LinkAdd = 5,
                /// Remove an existing Link
                LinkRemove = 6,
                /// Add a Verification of an Ethereum Address
                VerificationAddEthAddress = 7,
                /// Remove a Verification
                VerificationRemove = 8,
                /// Add a new Ed25519 key pair that signs messages for a user
                SignerAdd = 9,
                /// Remove an Ed25519 key pair that signs messages for a user
                SignerRemove = 10,
                /// Add metadata about a user
                UserDataAdd = 11,
                /// Add or replace a username proof
                UsernameProof = 12,
            }
            #[automatically_derived]
            impl ::core::clone::Clone for MessageType {
                #[inline]
                fn clone(&self) -> MessageType {
                    *self
                }
            }
            #[automatically_derived]
            impl ::core::marker::Copy for MessageType {}
            #[automatically_derived]
            impl ::core::fmt::Debug for MessageType {
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    ::core::fmt::Formatter::write_str(
                        f,
                        match self {
                            MessageType::None => "None",
                            MessageType::CastAdd => "CastAdd",
                            MessageType::CastRemove => "CastRemove",
                            MessageType::ReactionAdd => "ReactionAdd",
                            MessageType::ReactionRemove => "ReactionRemove",
                            MessageType::LinkAdd => "LinkAdd",
                            MessageType::LinkRemove => "LinkRemove",
                            MessageType::VerificationAddEthAddress => {
                                "VerificationAddEthAddress"
                            }
                            MessageType::VerificationRemove => "VerificationRemove",
                            MessageType::SignerAdd => "SignerAdd",
                            MessageType::SignerRemove => "SignerRemove",
                            MessageType::UserDataAdd => "UserDataAdd",
                            MessageType::UsernameProof => "UsernameProof",
                        },
                    )
                }
            }
            #[automatically_derived]
            impl ::core::marker::StructuralPartialEq for MessageType {}
            #[automatically_derived]
            impl ::core::cmp::PartialEq for MessageType {
                #[inline]
                fn eq(&self, other: &MessageType) -> bool {
                    let __self_tag = ::core::intrinsics::discriminant_value(self);
                    let __arg1_tag = ::core::intrinsics::discriminant_value(other);
                    __self_tag == __arg1_tag
                }
            }
            #[automatically_derived]
            impl ::core::marker::StructuralEq for MessageType {}
            #[automatically_derived]
            impl ::core::cmp::Eq for MessageType {
                #[inline]
                #[doc(hidden)]
                #[no_coverage]
                fn assert_receiver_is_total_eq(&self) -> () {}
            }
            #[automatically_derived]
            impl ::core::hash::Hash for MessageType {
                fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {
                    let __self_tag = ::core::intrinsics::discriminant_value(self);
                    ::core::hash::Hash::hash(&__self_tag, state)
                }
            }
            #[automatically_derived]
            impl ::core::cmp::PartialOrd for MessageType {
                #[inline]
                fn partial_cmp(
                    &self,
                    other: &MessageType,
                ) -> ::core::option::Option<::core::cmp::Ordering> {
                    let __self_tag = ::core::intrinsics::discriminant_value(self);
                    let __arg1_tag = ::core::intrinsics::discriminant_value(other);
                    ::core::cmp::PartialOrd::partial_cmp(&__self_tag, &__arg1_tag)
                }
            }
            #[automatically_derived]
            impl ::core::cmp::Ord for MessageType {
                #[inline]
                fn cmp(&self, other: &MessageType) -> ::core::cmp::Ordering {
                    let __self_tag = ::core::intrinsics::discriminant_value(self);
                    let __arg1_tag = ::core::intrinsics::discriminant_value(other);
                    ::core::cmp::Ord::cmp(&__self_tag, &__arg1_tag)
                }
            }
            impl MessageType {
                ///Returns `true` if `value` is a variant of `MessageType`.
                pub fn is_valid(value: i32) -> bool {
                    match value {
                        0 => true,
                        1 => true,
                        2 => true,
                        3 => true,
                        4 => true,
                        5 => true,
                        6 => true,
                        7 => true,
                        8 => true,
                        9 => true,
                        10 => true,
                        11 => true,
                        12 => true,
                        _ => false,
                    }
                }
                ///Converts an `i32` to a `MessageType`, or `None` if `value` is not a valid variant.
                pub fn from_i32(value: i32) -> ::core::option::Option<MessageType> {
                    match value {
                        0 => ::core::option::Option::Some(MessageType::None),
                        1 => ::core::option::Option::Some(MessageType::CastAdd),
                        2 => ::core::option::Option::Some(MessageType::CastRemove),
                        3 => ::core::option::Option::Some(MessageType::ReactionAdd),
                        4 => ::core::option::Option::Some(MessageType::ReactionRemove),
                        5 => ::core::option::Option::Some(MessageType::LinkAdd),
                        6 => ::core::option::Option::Some(MessageType::LinkRemove),
                        7 => {
                            ::core::option::Option::Some(
                                MessageType::VerificationAddEthAddress,
                            )
                        }
                        8 => {
                            ::core::option::Option::Some(MessageType::VerificationRemove)
                        }
                        9 => ::core::option::Option::Some(MessageType::SignerAdd),
                        10 => ::core::option::Option::Some(MessageType::SignerRemove),
                        11 => ::core::option::Option::Some(MessageType::UserDataAdd),
                        12 => ::core::option::Option::Some(MessageType::UsernameProof),
                        _ => ::core::option::Option::None,
                    }
                }
            }
            impl ::core::default::Default for MessageType {
                fn default() -> MessageType {
                    MessageType::None
                }
            }
            impl ::core::convert::From<MessageType> for i32 {
                fn from(value: MessageType) -> i32 {
                    value as i32
                }
            }
            impl MessageType {
                /// String value of the enum field names used in the ProtoBuf definition.
                ///
                /// The values are not transformed in any way and thus are considered stable
                /// (if the ProtoBuf definition does not change) and safe for programmatic use.
                pub fn as_str_name(&self) -> &'static str {
                    match self {
                        MessageType::None => "MESSAGE_TYPE_NONE",
                        MessageType::CastAdd => "MESSAGE_TYPE_CAST_ADD",
                        MessageType::CastRemove => "MESSAGE_TYPE_CAST_REMOVE",
                        MessageType::ReactionAdd => "MESSAGE_TYPE_REACTION_ADD",
                        MessageType::ReactionRemove => "MESSAGE_TYPE_REACTION_REMOVE",
                        MessageType::LinkAdd => "MESSAGE_TYPE_LINK_ADD",
                        MessageType::LinkRemove => "MESSAGE_TYPE_LINK_REMOVE",
                        MessageType::VerificationAddEthAddress => {
                            "MESSAGE_TYPE_VERIFICATION_ADD_ETH_ADDRESS"
                        }
                        MessageType::VerificationRemove => {
                            "MESSAGE_TYPE_VERIFICATION_REMOVE"
                        }
                        MessageType::SignerAdd => "MESSAGE_TYPE_SIGNER_ADD",
                        MessageType::SignerRemove => "MESSAGE_TYPE_SIGNER_REMOVE",
                        MessageType::UserDataAdd => "MESSAGE_TYPE_USER_DATA_ADD",
                        MessageType::UsernameProof => "MESSAGE_TYPE_USERNAME_PROOF",
                    }
                }
                /// Creates an enum from field names used in the ProtoBuf definition.
                pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
                    match value {
                        "MESSAGE_TYPE_NONE" => Some(Self::None),
                        "MESSAGE_TYPE_CAST_ADD" => Some(Self::CastAdd),
                        "MESSAGE_TYPE_CAST_REMOVE" => Some(Self::CastRemove),
                        "MESSAGE_TYPE_REACTION_ADD" => Some(Self::ReactionAdd),
                        "MESSAGE_TYPE_REACTION_REMOVE" => Some(Self::ReactionRemove),
                        "MESSAGE_TYPE_LINK_ADD" => Some(Self::LinkAdd),
                        "MESSAGE_TYPE_LINK_REMOVE" => Some(Self::LinkRemove),
                        "MESSAGE_TYPE_VERIFICATION_ADD_ETH_ADDRESS" => {
                            Some(Self::VerificationAddEthAddress)
                        }
                        "MESSAGE_TYPE_VERIFICATION_REMOVE" => {
                            Some(Self::VerificationRemove)
                        }
                        "MESSAGE_TYPE_SIGNER_ADD" => Some(Self::SignerAdd),
                        "MESSAGE_TYPE_SIGNER_REMOVE" => Some(Self::SignerRemove),
                        "MESSAGE_TYPE_USER_DATA_ADD" => Some(Self::UserDataAdd),
                        "MESSAGE_TYPE_USERNAME_PROOF" => Some(Self::UsernameProof),
                        _ => None,
                    }
                }
            }
            /// * Farcaster network the message is intended for
            #[repr(i32)]
            pub enum FarcasterNetwork {
                None = 0,
                /// Public primary network
                Mainnet = 1,
                /// Public test network
                Testnet = 2,
                /// Private test network
                Devnet = 3,
            }
            #[automatically_derived]
            impl ::core::clone::Clone for FarcasterNetwork {
                #[inline]
                fn clone(&self) -> FarcasterNetwork {
                    *self
                }
            }
            #[automatically_derived]
            impl ::core::marker::Copy for FarcasterNetwork {}
            #[automatically_derived]
            impl ::core::fmt::Debug for FarcasterNetwork {
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    ::core::fmt::Formatter::write_str(
                        f,
                        match self {
                            FarcasterNetwork::None => "None",
                            FarcasterNetwork::Mainnet => "Mainnet",
                            FarcasterNetwork::Testnet => "Testnet",
                            FarcasterNetwork::Devnet => "Devnet",
                        },
                    )
                }
            }
            #[automatically_derived]
            impl ::core::marker::StructuralPartialEq for FarcasterNetwork {}
            #[automatically_derived]
            impl ::core::cmp::PartialEq for FarcasterNetwork {
                #[inline]
                fn eq(&self, other: &FarcasterNetwork) -> bool {
                    let __self_tag = ::core::intrinsics::discriminant_value(self);
                    let __arg1_tag = ::core::intrinsics::discriminant_value(other);
                    __self_tag == __arg1_tag
                }
            }
            #[automatically_derived]
            impl ::core::marker::StructuralEq for FarcasterNetwork {}
            #[automatically_derived]
            impl ::core::cmp::Eq for FarcasterNetwork {
                #[inline]
                #[doc(hidden)]
                #[no_coverage]
                fn assert_receiver_is_total_eq(&self) -> () {}
            }
            #[automatically_derived]
            impl ::core::hash::Hash for FarcasterNetwork {
                fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {
                    let __self_tag = ::core::intrinsics::discriminant_value(self);
                    ::core::hash::Hash::hash(&__self_tag, state)
                }
            }
            #[automatically_derived]
            impl ::core::cmp::PartialOrd for FarcasterNetwork {
                #[inline]
                fn partial_cmp(
                    &self,
                    other: &FarcasterNetwork,
                ) -> ::core::option::Option<::core::cmp::Ordering> {
                    let __self_tag = ::core::intrinsics::discriminant_value(self);
                    let __arg1_tag = ::core::intrinsics::discriminant_value(other);
                    ::core::cmp::PartialOrd::partial_cmp(&__self_tag, &__arg1_tag)
                }
            }
            #[automatically_derived]
            impl ::core::cmp::Ord for FarcasterNetwork {
                #[inline]
                fn cmp(&self, other: &FarcasterNetwork) -> ::core::cmp::Ordering {
                    let __self_tag = ::core::intrinsics::discriminant_value(self);
                    let __arg1_tag = ::core::intrinsics::discriminant_value(other);
                    ::core::cmp::Ord::cmp(&__self_tag, &__arg1_tag)
                }
            }
            impl FarcasterNetwork {
                ///Returns `true` if `value` is a variant of `FarcasterNetwork`.
                pub fn is_valid(value: i32) -> bool {
                    match value {
                        0 => true,
                        1 => true,
                        2 => true,
                        3 => true,
                        _ => false,
                    }
                }
                ///Converts an `i32` to a `FarcasterNetwork`, or `None` if `value` is not a valid variant.
                pub fn from_i32(value: i32) -> ::core::option::Option<FarcasterNetwork> {
                    match value {
                        0 => ::core::option::Option::Some(FarcasterNetwork::None),
                        1 => ::core::option::Option::Some(FarcasterNetwork::Mainnet),
                        2 => ::core::option::Option::Some(FarcasterNetwork::Testnet),
                        3 => ::core::option::Option::Some(FarcasterNetwork::Devnet),
                        _ => ::core::option::Option::None,
                    }
                }
            }
            impl ::core::default::Default for FarcasterNetwork {
                fn default() -> FarcasterNetwork {
                    FarcasterNetwork::None
                }
            }
            impl ::core::convert::From<FarcasterNetwork> for i32 {
                fn from(value: FarcasterNetwork) -> i32 {
                    value as i32
                }
            }
            impl FarcasterNetwork {
                /// String value of the enum field names used in the ProtoBuf definition.
                ///
                /// The values are not transformed in any way and thus are considered stable
                /// (if the ProtoBuf definition does not change) and safe for programmatic use.
                pub fn as_str_name(&self) -> &'static str {
                    match self {
                        FarcasterNetwork::None => "FARCASTER_NETWORK_NONE",
                        FarcasterNetwork::Mainnet => "FARCASTER_NETWORK_MAINNET",
                        FarcasterNetwork::Testnet => "FARCASTER_NETWORK_TESTNET",
                        FarcasterNetwork::Devnet => "FARCASTER_NETWORK_DEVNET",
                    }
                }
                /// Creates an enum from field names used in the ProtoBuf definition.
                pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
                    match value {
                        "FARCASTER_NETWORK_NONE" => Some(Self::None),
                        "FARCASTER_NETWORK_MAINNET" => Some(Self::Mainnet),
                        "FARCASTER_NETWORK_TESTNET" => Some(Self::Testnet),
                        "FARCASTER_NETWORK_DEVNET" => Some(Self::Devnet),
                        _ => None,
                    }
                }
            }
            /// * Type of UserData
            #[repr(i32)]
            pub enum UserDataType {
                None = 0,
                /// Profile Picture for the user
                Pfp = 1,
                /// Display Name for the user
                Display = 2,
                /// Bio for the user
                Bio = 3,
                /// URL of the user
                Url = 5,
                /// Preferred Name for the user
                Username = 6,
            }
            #[automatically_derived]
            impl ::core::clone::Clone for UserDataType {
                #[inline]
                fn clone(&self) -> UserDataType {
                    *self
                }
            }
            #[automatically_derived]
            impl ::core::marker::Copy for UserDataType {}
            #[automatically_derived]
            impl ::core::fmt::Debug for UserDataType {
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    ::core::fmt::Formatter::write_str(
                        f,
                        match self {
                            UserDataType::None => "None",
                            UserDataType::Pfp => "Pfp",
                            UserDataType::Display => "Display",
                            UserDataType::Bio => "Bio",
                            UserDataType::Url => "Url",
                            UserDataType::Username => "Username",
                        },
                    )
                }
            }
            #[automatically_derived]
            impl ::core::marker::StructuralPartialEq for UserDataType {}
            #[automatically_derived]
            impl ::core::cmp::PartialEq for UserDataType {
                #[inline]
                fn eq(&self, other: &UserDataType) -> bool {
                    let __self_tag = ::core::intrinsics::discriminant_value(self);
                    let __arg1_tag = ::core::intrinsics::discriminant_value(other);
                    __self_tag == __arg1_tag
                }
            }
            #[automatically_derived]
            impl ::core::marker::StructuralEq for UserDataType {}
            #[automatically_derived]
            impl ::core::cmp::Eq for UserDataType {
                #[inline]
                #[doc(hidden)]
                #[no_coverage]
                fn assert_receiver_is_total_eq(&self) -> () {}
            }
            #[automatically_derived]
            impl ::core::hash::Hash for UserDataType {
                fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {
                    let __self_tag = ::core::intrinsics::discriminant_value(self);
                    ::core::hash::Hash::hash(&__self_tag, state)
                }
            }
            #[automatically_derived]
            impl ::core::cmp::PartialOrd for UserDataType {
                #[inline]
                fn partial_cmp(
                    &self,
                    other: &UserDataType,
                ) -> ::core::option::Option<::core::cmp::Ordering> {
                    let __self_tag = ::core::intrinsics::discriminant_value(self);
                    let __arg1_tag = ::core::intrinsics::discriminant_value(other);
                    ::core::cmp::PartialOrd::partial_cmp(&__self_tag, &__arg1_tag)
                }
            }
            #[automatically_derived]
            impl ::core::cmp::Ord for UserDataType {
                #[inline]
                fn cmp(&self, other: &UserDataType) -> ::core::cmp::Ordering {
                    let __self_tag = ::core::intrinsics::discriminant_value(self);
                    let __arg1_tag = ::core::intrinsics::discriminant_value(other);
                    ::core::cmp::Ord::cmp(&__self_tag, &__arg1_tag)
                }
            }
            impl UserDataType {
                ///Returns `true` if `value` is a variant of `UserDataType`.
                pub fn is_valid(value: i32) -> bool {
                    match value {
                        0 => true,
                        1 => true,
                        2 => true,
                        3 => true,
                        5 => true,
                        6 => true,
                        _ => false,
                    }
                }
                ///Converts an `i32` to a `UserDataType`, or `None` if `value` is not a valid variant.
                pub fn from_i32(value: i32) -> ::core::option::Option<UserDataType> {
                    match value {
                        0 => ::core::option::Option::Some(UserDataType::None),
                        1 => ::core::option::Option::Some(UserDataType::Pfp),
                        2 => ::core::option::Option::Some(UserDataType::Display),
                        3 => ::core::option::Option::Some(UserDataType::Bio),
                        5 => ::core::option::Option::Some(UserDataType::Url),
                        6 => ::core::option::Option::Some(UserDataType::Username),
                        _ => ::core::option::Option::None,
                    }
                }
            }
            impl ::core::default::Default for UserDataType {
                fn default() -> UserDataType {
                    UserDataType::None
                }
            }
            impl ::core::convert::From<UserDataType> for i32 {
                fn from(value: UserDataType) -> i32 {
                    value as i32
                }
            }
            impl UserDataType {
                /// String value of the enum field names used in the ProtoBuf definition.
                ///
                /// The values are not transformed in any way and thus are considered stable
                /// (if the ProtoBuf definition does not change) and safe for programmatic use.
                pub fn as_str_name(&self) -> &'static str {
                    match self {
                        UserDataType::None => "USER_DATA_TYPE_NONE",
                        UserDataType::Pfp => "USER_DATA_TYPE_PFP",
                        UserDataType::Display => "USER_DATA_TYPE_DISPLAY",
                        UserDataType::Bio => "USER_DATA_TYPE_BIO",
                        UserDataType::Url => "USER_DATA_TYPE_URL",
                        UserDataType::Username => "USER_DATA_TYPE_USERNAME",
                    }
                }
                /// Creates an enum from field names used in the ProtoBuf definition.
                pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
                    match value {
                        "USER_DATA_TYPE_NONE" => Some(Self::None),
                        "USER_DATA_TYPE_PFP" => Some(Self::Pfp),
                        "USER_DATA_TYPE_DISPLAY" => Some(Self::Display),
                        "USER_DATA_TYPE_BIO" => Some(Self::Bio),
                        "USER_DATA_TYPE_URL" => Some(Self::Url),
                        "USER_DATA_TYPE_USERNAME" => Some(Self::Username),
                        _ => None,
                    }
                }
            }
            /// * Type of Reaction
            #[repr(i32)]
            pub enum ReactionType {
                None = 0,
                /// Like the target cast
                Like = 1,
                /// Share target cast to the user's audience
                Recast = 2,
            }
            #[automatically_derived]
            impl ::core::clone::Clone for ReactionType {
                #[inline]
                fn clone(&self) -> ReactionType {
                    *self
                }
            }
            #[automatically_derived]
            impl ::core::marker::Copy for ReactionType {}
            #[automatically_derived]
            impl ::core::fmt::Debug for ReactionType {
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    ::core::fmt::Formatter::write_str(
                        f,
                        match self {
                            ReactionType::None => "None",
                            ReactionType::Like => "Like",
                            ReactionType::Recast => "Recast",
                        },
                    )
                }
            }
            #[automatically_derived]
            impl ::core::marker::StructuralPartialEq for ReactionType {}
            #[automatically_derived]
            impl ::core::cmp::PartialEq for ReactionType {
                #[inline]
                fn eq(&self, other: &ReactionType) -> bool {
                    let __self_tag = ::core::intrinsics::discriminant_value(self);
                    let __arg1_tag = ::core::intrinsics::discriminant_value(other);
                    __self_tag == __arg1_tag
                }
            }
            #[automatically_derived]
            impl ::core::marker::StructuralEq for ReactionType {}
            #[automatically_derived]
            impl ::core::cmp::Eq for ReactionType {
                #[inline]
                #[doc(hidden)]
                #[no_coverage]
                fn assert_receiver_is_total_eq(&self) -> () {}
            }
            #[automatically_derived]
            impl ::core::hash::Hash for ReactionType {
                fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {
                    let __self_tag = ::core::intrinsics::discriminant_value(self);
                    ::core::hash::Hash::hash(&__self_tag, state)
                }
            }
            #[automatically_derived]
            impl ::core::cmp::PartialOrd for ReactionType {
                #[inline]
                fn partial_cmp(
                    &self,
                    other: &ReactionType,
                ) -> ::core::option::Option<::core::cmp::Ordering> {
                    let __self_tag = ::core::intrinsics::discriminant_value(self);
                    let __arg1_tag = ::core::intrinsics::discriminant_value(other);
                    ::core::cmp::PartialOrd::partial_cmp(&__self_tag, &__arg1_tag)
                }
            }
            #[automatically_derived]
            impl ::core::cmp::Ord for ReactionType {
                #[inline]
                fn cmp(&self, other: &ReactionType) -> ::core::cmp::Ordering {
                    let __self_tag = ::core::intrinsics::discriminant_value(self);
                    let __arg1_tag = ::core::intrinsics::discriminant_value(other);
                    ::core::cmp::Ord::cmp(&__self_tag, &__arg1_tag)
                }
            }
            impl ReactionType {
                ///Returns `true` if `value` is a variant of `ReactionType`.
                pub fn is_valid(value: i32) -> bool {
                    match value {
                        0 => true,
                        1 => true,
                        2 => true,
                        _ => false,
                    }
                }
                ///Converts an `i32` to a `ReactionType`, or `None` if `value` is not a valid variant.
                pub fn from_i32(value: i32) -> ::core::option::Option<ReactionType> {
                    match value {
                        0 => ::core::option::Option::Some(ReactionType::None),
                        1 => ::core::option::Option::Some(ReactionType::Like),
                        2 => ::core::option::Option::Some(ReactionType::Recast),
                        _ => ::core::option::Option::None,
                    }
                }
            }
            impl ::core::default::Default for ReactionType {
                fn default() -> ReactionType {
                    ReactionType::None
                }
            }
            impl ::core::convert::From<ReactionType> for i32 {
                fn from(value: ReactionType) -> i32 {
                    value as i32
                }
            }
            impl ReactionType {
                /// String value of the enum field names used in the ProtoBuf definition.
                ///
                /// The values are not transformed in any way and thus are considered stable
                /// (if the ProtoBuf definition does not change) and safe for programmatic use.
                pub fn as_str_name(&self) -> &'static str {
                    match self {
                        ReactionType::None => "REACTION_TYPE_NONE",
                        ReactionType::Like => "REACTION_TYPE_LIKE",
                        ReactionType::Recast => "REACTION_TYPE_RECAST",
                    }
                }
                /// Creates an enum from field names used in the ProtoBuf definition.
                pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
                    match value {
                        "REACTION_TYPE_NONE" => Some(Self::None),
                        "REACTION_TYPE_LIKE" => Some(Self::Like),
                        "REACTION_TYPE_RECAST" => Some(Self::Recast),
                        _ => None,
                    }
                }
            }
            #[allow(clippy::derive_partial_eq_without_eq)]
            pub struct IdRegistryEvent {
                #[prost(uint32, tag = "1")]
                pub block_number: u32,
                #[prost(bytes = "vec", tag = "2")]
                pub block_hash: ::prost::alloc::vec::Vec<u8>,
                #[prost(bytes = "vec", tag = "3")]
                pub transaction_hash: ::prost::alloc::vec::Vec<u8>,
                #[prost(uint32, tag = "4")]
                pub log_index: u32,
                #[prost(uint64, tag = "5")]
                pub fid: u64,
                #[prost(bytes = "vec", tag = "6")]
                pub to: ::prost::alloc::vec::Vec<u8>,
                #[prost(enumeration = "IdRegistryEventType", tag = "7")]
                pub r#type: i32,
                #[prost(bytes = "vec", tag = "8")]
                pub from: ::prost::alloc::vec::Vec<u8>,
            }
            #[automatically_derived]
            #[allow(clippy::derive_partial_eq_without_eq)]
            impl ::core::clone::Clone for IdRegistryEvent {
                #[inline]
                fn clone(&self) -> IdRegistryEvent {
                    IdRegistryEvent {
                        block_number: ::core::clone::Clone::clone(&self.block_number),
                        block_hash: ::core::clone::Clone::clone(&self.block_hash),
                        transaction_hash: ::core::clone::Clone::clone(
                            &self.transaction_hash,
                        ),
                        log_index: ::core::clone::Clone::clone(&self.log_index),
                        fid: ::core::clone::Clone::clone(&self.fid),
                        to: ::core::clone::Clone::clone(&self.to),
                        r#type: ::core::clone::Clone::clone(&self.r#type),
                        from: ::core::clone::Clone::clone(&self.from),
                    }
                }
            }
            #[allow(clippy::derive_partial_eq_without_eq)]
            #[automatically_derived]
            impl ::core::marker::StructuralPartialEq for IdRegistryEvent {}
            #[automatically_derived]
            #[allow(clippy::derive_partial_eq_without_eq)]
            impl ::core::cmp::PartialEq for IdRegistryEvent {
                #[inline]
                fn eq(&self, other: &IdRegistryEvent) -> bool {
                    self.block_number == other.block_number
                        && self.block_hash == other.block_hash
                        && self.transaction_hash == other.transaction_hash
                        && self.log_index == other.log_index && self.fid == other.fid
                        && self.to == other.to && self.r#type == other.r#type
                        && self.from == other.from
                }
            }
            impl ::prost::Message for IdRegistryEvent {
                #[allow(unused_variables)]
                fn encode_raw<B>(&self, buf: &mut B)
                where
                    B: ::prost::bytes::BufMut,
                {
                    if self.block_number != 0u32 {
                        ::prost::encoding::uint32::encode(1u32, &self.block_number, buf);
                    }
                    if self.block_hash != b"" as &[u8] {
                        ::prost::encoding::bytes::encode(2u32, &self.block_hash, buf);
                    }
                    if self.transaction_hash != b"" as &[u8] {
                        ::prost::encoding::bytes::encode(
                            3u32,
                            &self.transaction_hash,
                            buf,
                        );
                    }
                    if self.log_index != 0u32 {
                        ::prost::encoding::uint32::encode(4u32, &self.log_index, buf);
                    }
                    if self.fid != 0u64 {
                        ::prost::encoding::uint64::encode(5u32, &self.fid, buf);
                    }
                    if self.to != b"" as &[u8] {
                        ::prost::encoding::bytes::encode(6u32, &self.to, buf);
                    }
                    if self.r#type != IdRegistryEventType::default() as i32 {
                        ::prost::encoding::int32::encode(7u32, &self.r#type, buf);
                    }
                    if self.from != b"" as &[u8] {
                        ::prost::encoding::bytes::encode(8u32, &self.from, buf);
                    }
                }
                #[allow(unused_variables)]
                fn merge_field<B>(
                    &mut self,
                    tag: u32,
                    wire_type: ::prost::encoding::WireType,
                    buf: &mut B,
                    ctx: ::prost::encoding::DecodeContext,
                ) -> ::core::result::Result<(), ::prost::DecodeError>
                where
                    B: ::prost::bytes::Buf,
                {
                    const STRUCT_NAME: &'static str = "IdRegistryEvent";
                    match tag {
                        1u32 => {
                            let mut value = &mut self.block_number;
                            ::prost::encoding::uint32::merge(wire_type, value, buf, ctx)
                                .map_err(|mut error| {
                                    error.push(STRUCT_NAME, "block_number");
                                    error
                                })
                        }
                        2u32 => {
                            let mut value = &mut self.block_hash;
                            ::prost::encoding::bytes::merge(wire_type, value, buf, ctx)
                                .map_err(|mut error| {
                                    error.push(STRUCT_NAME, "block_hash");
                                    error
                                })
                        }
                        3u32 => {
                            let mut value = &mut self.transaction_hash;
                            ::prost::encoding::bytes::merge(wire_type, value, buf, ctx)
                                .map_err(|mut error| {
                                    error.push(STRUCT_NAME, "transaction_hash");
                                    error
                                })
                        }
                        4u32 => {
                            let mut value = &mut self.log_index;
                            ::prost::encoding::uint32::merge(wire_type, value, buf, ctx)
                                .map_err(|mut error| {
                                    error.push(STRUCT_NAME, "log_index");
                                    error
                                })
                        }
                        5u32 => {
                            let mut value = &mut self.fid;
                            ::prost::encoding::uint64::merge(wire_type, value, buf, ctx)
                                .map_err(|mut error| {
                                    error.push(STRUCT_NAME, "fid");
                                    error
                                })
                        }
                        6u32 => {
                            let mut value = &mut self.to;
                            ::prost::encoding::bytes::merge(wire_type, value, buf, ctx)
                                .map_err(|mut error| {
                                    error.push(STRUCT_NAME, "to");
                                    error
                                })
                        }
                        7u32 => {
                            let mut value = &mut self.r#type;
                            ::prost::encoding::int32::merge(wire_type, value, buf, ctx)
                                .map_err(|mut error| {
                                    error.push(STRUCT_NAME, "r#type");
                                    error
                                })
                        }
                        8u32 => {
                            let mut value = &mut self.from;
                            ::prost::encoding::bytes::merge(wire_type, value, buf, ctx)
                                .map_err(|mut error| {
                                    error.push(STRUCT_NAME, "from");
                                    error
                                })
                        }
                        _ => ::prost::encoding::skip_field(wire_type, tag, buf, ctx),
                    }
                }
                #[inline]
                fn encoded_len(&self) -> usize {
                    0
                        + if self.block_number != 0u32 {
                            ::prost::encoding::uint32::encoded_len(
                                1u32,
                                &self.block_number,
                            )
                        } else {
                            0
                        }
                        + if self.block_hash != b"" as &[u8] {
                            ::prost::encoding::bytes::encoded_len(2u32, &self.block_hash)
                        } else {
                            0
                        }
                        + if self.transaction_hash != b"" as &[u8] {
                            ::prost::encoding::bytes::encoded_len(
                                3u32,
                                &self.transaction_hash,
                            )
                        } else {
                            0
                        }
                        + if self.log_index != 0u32 {
                            ::prost::encoding::uint32::encoded_len(4u32, &self.log_index)
                        } else {
                            0
                        }
                        + if self.fid != 0u64 {
                            ::prost::encoding::uint64::encoded_len(5u32, &self.fid)
                        } else {
                            0
                        }
                        + if self.to != b"" as &[u8] {
                            ::prost::encoding::bytes::encoded_len(6u32, &self.to)
                        } else {
                            0
                        }
                        + if self.r#type != IdRegistryEventType::default() as i32 {
                            ::prost::encoding::int32::encoded_len(7u32, &self.r#type)
                        } else {
                            0
                        }
                        + if self.from != b"" as &[u8] {
                            ::prost::encoding::bytes::encoded_len(8u32, &self.from)
                        } else {
                            0
                        }
                }
                fn clear(&mut self) {
                    self.block_number = 0u32;
                    self.block_hash.clear();
                    self.transaction_hash.clear();
                    self.log_index = 0u32;
                    self.fid = 0u64;
                    self.to.clear();
                    self.r#type = IdRegistryEventType::default() as i32;
                    self.from.clear();
                }
            }
            impl ::core::default::Default for IdRegistryEvent {
                fn default() -> Self {
                    IdRegistryEvent {
                        block_number: 0u32,
                        block_hash: ::core::default::Default::default(),
                        transaction_hash: ::core::default::Default::default(),
                        log_index: 0u32,
                        fid: 0u64,
                        to: ::core::default::Default::default(),
                        r#type: IdRegistryEventType::default() as i32,
                        from: ::core::default::Default::default(),
                    }
                }
            }
            impl ::core::fmt::Debug for IdRegistryEvent {
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    let mut builder = f.debug_struct("IdRegistryEvent");
                    let builder = {
                        let wrapper = {
                            fn ScalarWrapper<T>(v: T) -> T {
                                v
                            }
                            ScalarWrapper(&self.block_number)
                        };
                        builder.field("block_number", &wrapper)
                    };
                    let builder = {
                        let wrapper = {
                            fn ScalarWrapper<T>(v: T) -> T {
                                v
                            }
                            ScalarWrapper(&self.block_hash)
                        };
                        builder.field("block_hash", &wrapper)
                    };
                    let builder = {
                        let wrapper = {
                            fn ScalarWrapper<T>(v: T) -> T {
                                v
                            }
                            ScalarWrapper(&self.transaction_hash)
                        };
                        builder.field("transaction_hash", &wrapper)
                    };
                    let builder = {
                        let wrapper = {
                            fn ScalarWrapper<T>(v: T) -> T {
                                v
                            }
                            ScalarWrapper(&self.log_index)
                        };
                        builder.field("log_index", &wrapper)
                    };
                    let builder = {
                        let wrapper = {
                            fn ScalarWrapper<T>(v: T) -> T {
                                v
                            }
                            ScalarWrapper(&self.fid)
                        };
                        builder.field("fid", &wrapper)
                    };
                    let builder = {
                        let wrapper = {
                            fn ScalarWrapper<T>(v: T) -> T {
                                v
                            }
                            ScalarWrapper(&self.to)
                        };
                        builder.field("to", &wrapper)
                    };
                    let builder = {
                        let wrapper = {
                            struct ScalarWrapper<'a>(&'a i32);
                            impl<'a> ::core::fmt::Debug for ScalarWrapper<'a> {
                                fn fmt(
                                    &self,
                                    f: &mut ::core::fmt::Formatter,
                                ) -> ::core::fmt::Result {
                                    match IdRegistryEventType::from_i32(*self.0) {
                                        None => ::core::fmt::Debug::fmt(&self.0, f),
                                        Some(en) => ::core::fmt::Debug::fmt(&en, f),
                                    }
                                }
                            }
                            ScalarWrapper(&self.r#type)
                        };
                        builder.field("r#type", &wrapper)
                    };
                    let builder = {
                        let wrapper = {
                            fn ScalarWrapper<T>(v: T) -> T {
                                v
                            }
                            ScalarWrapper(&self.from)
                        };
                        builder.field("from", &wrapper)
                    };
                    builder.finish()
                }
            }
            #[allow(dead_code)]
            impl IdRegistryEvent {
                ///Returns the enum value of `type`, or the default if the field is set to an invalid enum value.
                pub fn r#type(&self) -> IdRegistryEventType {
                    IdRegistryEventType::from_i32(self.r#type)
                        .unwrap_or(IdRegistryEventType::default())
                }
                ///Sets `type` to the provided enum value.
                pub fn set_type(&mut self, value: IdRegistryEventType) {
                    self.r#type = value as i32;
                }
            }
            #[repr(i32)]
            pub enum IdRegistryEventType {
                None = 0,
                Register = 1,
                Transfer = 2,
            }
            #[automatically_derived]
            impl ::core::clone::Clone for IdRegistryEventType {
                #[inline]
                fn clone(&self) -> IdRegistryEventType {
                    *self
                }
            }
            #[automatically_derived]
            impl ::core::marker::Copy for IdRegistryEventType {}
            #[automatically_derived]
            impl ::core::fmt::Debug for IdRegistryEventType {
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    ::core::fmt::Formatter::write_str(
                        f,
                        match self {
                            IdRegistryEventType::None => "None",
                            IdRegistryEventType::Register => "Register",
                            IdRegistryEventType::Transfer => "Transfer",
                        },
                    )
                }
            }
            #[automatically_derived]
            impl ::core::marker::StructuralPartialEq for IdRegistryEventType {}
            #[automatically_derived]
            impl ::core::cmp::PartialEq for IdRegistryEventType {
                #[inline]
                fn eq(&self, other: &IdRegistryEventType) -> bool {
                    let __self_tag = ::core::intrinsics::discriminant_value(self);
                    let __arg1_tag = ::core::intrinsics::discriminant_value(other);
                    __self_tag == __arg1_tag
                }
            }
            #[automatically_derived]
            impl ::core::marker::StructuralEq for IdRegistryEventType {}
            #[automatically_derived]
            impl ::core::cmp::Eq for IdRegistryEventType {
                #[inline]
                #[doc(hidden)]
                #[no_coverage]
                fn assert_receiver_is_total_eq(&self) -> () {}
            }
            #[automatically_derived]
            impl ::core::hash::Hash for IdRegistryEventType {
                fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {
                    let __self_tag = ::core::intrinsics::discriminant_value(self);
                    ::core::hash::Hash::hash(&__self_tag, state)
                }
            }
            #[automatically_derived]
            impl ::core::cmp::PartialOrd for IdRegistryEventType {
                #[inline]
                fn partial_cmp(
                    &self,
                    other: &IdRegistryEventType,
                ) -> ::core::option::Option<::core::cmp::Ordering> {
                    let __self_tag = ::core::intrinsics::discriminant_value(self);
                    let __arg1_tag = ::core::intrinsics::discriminant_value(other);
                    ::core::cmp::PartialOrd::partial_cmp(&__self_tag, &__arg1_tag)
                }
            }
            #[automatically_derived]
            impl ::core::cmp::Ord for IdRegistryEventType {
                #[inline]
                fn cmp(&self, other: &IdRegistryEventType) -> ::core::cmp::Ordering {
                    let __self_tag = ::core::intrinsics::discriminant_value(self);
                    let __arg1_tag = ::core::intrinsics::discriminant_value(other);
                    ::core::cmp::Ord::cmp(&__self_tag, &__arg1_tag)
                }
            }
            impl IdRegistryEventType {
                ///Returns `true` if `value` is a variant of `IdRegistryEventType`.
                pub fn is_valid(value: i32) -> bool {
                    match value {
                        0 => true,
                        1 => true,
                        2 => true,
                        _ => false,
                    }
                }
                ///Converts an `i32` to a `IdRegistryEventType`, or `None` if `value` is not a valid variant.
                pub fn from_i32(
                    value: i32,
                ) -> ::core::option::Option<IdRegistryEventType> {
                    match value {
                        0 => ::core::option::Option::Some(IdRegistryEventType::None),
                        1 => ::core::option::Option::Some(IdRegistryEventType::Register),
                        2 => ::core::option::Option::Some(IdRegistryEventType::Transfer),
                        _ => ::core::option::Option::None,
                    }
                }
            }
            impl ::core::default::Default for IdRegistryEventType {
                fn default() -> IdRegistryEventType {
                    IdRegistryEventType::None
                }
            }
            impl ::core::convert::From<IdRegistryEventType> for i32 {
                fn from(value: IdRegistryEventType) -> i32 {
                    value as i32
                }
            }
            impl IdRegistryEventType {
                /// String value of the enum field names used in the ProtoBuf definition.
                ///
                /// The values are not transformed in any way and thus are considered stable
                /// (if the ProtoBuf definition does not change) and safe for programmatic use.
                pub fn as_str_name(&self) -> &'static str {
                    match self {
                        IdRegistryEventType::None => "ID_REGISTRY_EVENT_TYPE_NONE",
                        IdRegistryEventType::Register => {
                            "ID_REGISTRY_EVENT_TYPE_REGISTER"
                        }
                        IdRegistryEventType::Transfer => {
                            "ID_REGISTRY_EVENT_TYPE_TRANSFER"
                        }
                    }
                }
                /// Creates an enum from field names used in the ProtoBuf definition.
                pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
                    match value {
                        "ID_REGISTRY_EVENT_TYPE_NONE" => Some(Self::None),
                        "ID_REGISTRY_EVENT_TYPE_REGISTER" => Some(Self::Register),
                        "ID_REGISTRY_EVENT_TYPE_TRANSFER" => Some(Self::Transfer),
                        _ => None,
                    }
                }
            }
            #[allow(clippy::derive_partial_eq_without_eq)]
            pub struct GossipAddressInfo {
                #[prost(string, tag = "1")]
                pub address: ::prost::alloc::string::String,
                #[prost(uint32, tag = "2")]
                pub family: u32,
                #[prost(uint32, tag = "3")]
                pub port: u32,
                #[prost(string, tag = "4")]
                pub dns_name: ::prost::alloc::string::String,
            }
            #[automatically_derived]
            #[allow(clippy::derive_partial_eq_without_eq)]
            impl ::core::clone::Clone for GossipAddressInfo {
                #[inline]
                fn clone(&self) -> GossipAddressInfo {
                    GossipAddressInfo {
                        address: ::core::clone::Clone::clone(&self.address),
                        family: ::core::clone::Clone::clone(&self.family),
                        port: ::core::clone::Clone::clone(&self.port),
                        dns_name: ::core::clone::Clone::clone(&self.dns_name),
                    }
                }
            }
            #[allow(clippy::derive_partial_eq_without_eq)]
            #[automatically_derived]
            impl ::core::marker::StructuralPartialEq for GossipAddressInfo {}
            #[automatically_derived]
            #[allow(clippy::derive_partial_eq_without_eq)]
            impl ::core::cmp::PartialEq for GossipAddressInfo {
                #[inline]
                fn eq(&self, other: &GossipAddressInfo) -> bool {
                    self.address == other.address && self.family == other.family
                        && self.port == other.port && self.dns_name == other.dns_name
                }
            }
            impl ::prost::Message for GossipAddressInfo {
                #[allow(unused_variables)]
                fn encode_raw<B>(&self, buf: &mut B)
                where
                    B: ::prost::bytes::BufMut,
                {
                    if self.address != "" {
                        ::prost::encoding::string::encode(1u32, &self.address, buf);
                    }
                    if self.family != 0u32 {
                        ::prost::encoding::uint32::encode(2u32, &self.family, buf);
                    }
                    if self.port != 0u32 {
                        ::prost::encoding::uint32::encode(3u32, &self.port, buf);
                    }
                    if self.dns_name != "" {
                        ::prost::encoding::string::encode(4u32, &self.dns_name, buf);
                    }
                }
                #[allow(unused_variables)]
                fn merge_field<B>(
                    &mut self,
                    tag: u32,
                    wire_type: ::prost::encoding::WireType,
                    buf: &mut B,
                    ctx: ::prost::encoding::DecodeContext,
                ) -> ::core::result::Result<(), ::prost::DecodeError>
                where
                    B: ::prost::bytes::Buf,
                {
                    const STRUCT_NAME: &'static str = "GossipAddressInfo";
                    match tag {
                        1u32 => {
                            let mut value = &mut self.address;
                            ::prost::encoding::string::merge(wire_type, value, buf, ctx)
                                .map_err(|mut error| {
                                    error.push(STRUCT_NAME, "address");
                                    error
                                })
                        }
                        2u32 => {
                            let mut value = &mut self.family;
                            ::prost::encoding::uint32::merge(wire_type, value, buf, ctx)
                                .map_err(|mut error| {
                                    error.push(STRUCT_NAME, "family");
                                    error
                                })
                        }
                        3u32 => {
                            let mut value = &mut self.port;
                            ::prost::encoding::uint32::merge(wire_type, value, buf, ctx)
                                .map_err(|mut error| {
                                    error.push(STRUCT_NAME, "port");
                                    error
                                })
                        }
                        4u32 => {
                            let mut value = &mut self.dns_name;
                            ::prost::encoding::string::merge(wire_type, value, buf, ctx)
                                .map_err(|mut error| {
                                    error.push(STRUCT_NAME, "dns_name");
                                    error
                                })
                        }
                        _ => ::prost::encoding::skip_field(wire_type, tag, buf, ctx),
                    }
                }
                #[inline]
                fn encoded_len(&self) -> usize {
                    0
                        + if self.address != "" {
                            ::prost::encoding::string::encoded_len(1u32, &self.address)
                        } else {
                            0
                        }
                        + if self.family != 0u32 {
                            ::prost::encoding::uint32::encoded_len(2u32, &self.family)
                        } else {
                            0
                        }
                        + if self.port != 0u32 {
                            ::prost::encoding::uint32::encoded_len(3u32, &self.port)
                        } else {
                            0
                        }
                        + if self.dns_name != "" {
                            ::prost::encoding::string::encoded_len(4u32, &self.dns_name)
                        } else {
                            0
                        }
                }
                fn clear(&mut self) {
                    self.address.clear();
                    self.family = 0u32;
                    self.port = 0u32;
                    self.dns_name.clear();
                }
            }
            impl ::core::default::Default for GossipAddressInfo {
                fn default() -> Self {
                    GossipAddressInfo {
                        address: ::prost::alloc::string::String::new(),
                        family: 0u32,
                        port: 0u32,
                        dns_name: ::prost::alloc::string::String::new(),
                    }
                }
            }
            impl ::core::fmt::Debug for GossipAddressInfo {
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    let mut builder = f.debug_struct("GossipAddressInfo");
                    let builder = {
                        let wrapper = {
                            fn ScalarWrapper<T>(v: T) -> T {
                                v
                            }
                            ScalarWrapper(&self.address)
                        };
                        builder.field("address", &wrapper)
                    };
                    let builder = {
                        let wrapper = {
                            fn ScalarWrapper<T>(v: T) -> T {
                                v
                            }
                            ScalarWrapper(&self.family)
                        };
                        builder.field("family", &wrapper)
                    };
                    let builder = {
                        let wrapper = {
                            fn ScalarWrapper<T>(v: T) -> T {
                                v
                            }
                            ScalarWrapper(&self.port)
                        };
                        builder.field("port", &wrapper)
                    };
                    let builder = {
                        let wrapper = {
                            fn ScalarWrapper<T>(v: T) -> T {
                                v
                            }
                            ScalarWrapper(&self.dns_name)
                        };
                        builder.field("dns_name", &wrapper)
                    };
                    builder.finish()
                }
            }
            #[allow(clippy::derive_partial_eq_without_eq)]
            pub struct ContactInfoContent {
                #[prost(message, optional, tag = "1")]
                pub gossip_address: ::core::option::Option<GossipAddressInfo>,
                #[prost(message, optional, tag = "2")]
                pub rpc_address: ::core::option::Option<GossipAddressInfo>,
                #[prost(string, repeated, tag = "3")]
                pub excluded_hashes: ::prost::alloc::vec::Vec<
                    ::prost::alloc::string::String,
                >,
                #[prost(uint32, tag = "4")]
                pub count: u32,
                #[prost(string, tag = "5")]
                pub hub_version: ::prost::alloc::string::String,
                #[prost(enumeration = "FarcasterNetwork", tag = "6")]
                pub network: i32,
                #[prost(string, tag = "7")]
                pub app_version: ::prost::alloc::string::String,
            }
            #[automatically_derived]
            #[allow(clippy::derive_partial_eq_without_eq)]
            impl ::core::clone::Clone for ContactInfoContent {
                #[inline]
                fn clone(&self) -> ContactInfoContent {
                    ContactInfoContent {
                        gossip_address: ::core::clone::Clone::clone(
                            &self.gossip_address,
                        ),
                        rpc_address: ::core::clone::Clone::clone(&self.rpc_address),
                        excluded_hashes: ::core::clone::Clone::clone(
                            &self.excluded_hashes,
                        ),
                        count: ::core::clone::Clone::clone(&self.count),
                        hub_version: ::core::clone::Clone::clone(&self.hub_version),
                        network: ::core::clone::Clone::clone(&self.network),
                        app_version: ::core::clone::Clone::clone(&self.app_version),
                    }
                }
            }
            #[allow(clippy::derive_partial_eq_without_eq)]
            #[automatically_derived]
            impl ::core::marker::StructuralPartialEq for ContactInfoContent {}
            #[automatically_derived]
            #[allow(clippy::derive_partial_eq_without_eq)]
            impl ::core::cmp::PartialEq for ContactInfoContent {
                #[inline]
                fn eq(&self, other: &ContactInfoContent) -> bool {
                    self.gossip_address == other.gossip_address
                        && self.rpc_address == other.rpc_address
                        && self.excluded_hashes == other.excluded_hashes
                        && self.count == other.count
                        && self.hub_version == other.hub_version
                        && self.network == other.network
                        && self.app_version == other.app_version
                }
            }
            impl ::prost::Message for ContactInfoContent {
                #[allow(unused_variables)]
                fn encode_raw<B>(&self, buf: &mut B)
                where
                    B: ::prost::bytes::BufMut,
                {
                    if let Some(ref msg) = self.gossip_address {
                        ::prost::encoding::message::encode(1u32, msg, buf);
                    }
                    if let Some(ref msg) = self.rpc_address {
                        ::prost::encoding::message::encode(2u32, msg, buf);
                    }
                    ::prost::encoding::string::encode_repeated(
                        3u32,
                        &self.excluded_hashes,
                        buf,
                    );
                    if self.count != 0u32 {
                        ::prost::encoding::uint32::encode(4u32, &self.count, buf);
                    }
                    if self.hub_version != "" {
                        ::prost::encoding::string::encode(5u32, &self.hub_version, buf);
                    }
                    if self.network != FarcasterNetwork::default() as i32 {
                        ::prost::encoding::int32::encode(6u32, &self.network, buf);
                    }
                    if self.app_version != "" {
                        ::prost::encoding::string::encode(7u32, &self.app_version, buf);
                    }
                }
                #[allow(unused_variables)]
                fn merge_field<B>(
                    &mut self,
                    tag: u32,
                    wire_type: ::prost::encoding::WireType,
                    buf: &mut B,
                    ctx: ::prost::encoding::DecodeContext,
                ) -> ::core::result::Result<(), ::prost::DecodeError>
                where
                    B: ::prost::bytes::Buf,
                {
                    const STRUCT_NAME: &'static str = "ContactInfoContent";
                    match tag {
                        1u32 => {
                            let mut value = &mut self.gossip_address;
                            ::prost::encoding::message::merge(
                                    wire_type,
                                    value.get_or_insert_with(::core::default::Default::default),
                                    buf,
                                    ctx,
                                )
                                .map_err(|mut error| {
                                    error.push(STRUCT_NAME, "gossip_address");
                                    error
                                })
                        }
                        2u32 => {
                            let mut value = &mut self.rpc_address;
                            ::prost::encoding::message::merge(
                                    wire_type,
                                    value.get_or_insert_with(::core::default::Default::default),
                                    buf,
                                    ctx,
                                )
                                .map_err(|mut error| {
                                    error.push(STRUCT_NAME, "rpc_address");
                                    error
                                })
                        }
                        3u32 => {
                            let mut value = &mut self.excluded_hashes;
                            ::prost::encoding::string::merge_repeated(
                                    wire_type,
                                    value,
                                    buf,
                                    ctx,
                                )
                                .map_err(|mut error| {
                                    error.push(STRUCT_NAME, "excluded_hashes");
                                    error
                                })
                        }
                        4u32 => {
                            let mut value = &mut self.count;
                            ::prost::encoding::uint32::merge(wire_type, value, buf, ctx)
                                .map_err(|mut error| {
                                    error.push(STRUCT_NAME, "count");
                                    error
                                })
                        }
                        5u32 => {
                            let mut value = &mut self.hub_version;
                            ::prost::encoding::string::merge(wire_type, value, buf, ctx)
                                .map_err(|mut error| {
                                    error.push(STRUCT_NAME, "hub_version");
                                    error
                                })
                        }
                        6u32 => {
                            let mut value = &mut self.network;
                            ::prost::encoding::int32::merge(wire_type, value, buf, ctx)
                                .map_err(|mut error| {
                                    error.push(STRUCT_NAME, "network");
                                    error
                                })
                        }
                        7u32 => {
                            let mut value = &mut self.app_version;
                            ::prost::encoding::string::merge(wire_type, value, buf, ctx)
                                .map_err(|mut error| {
                                    error.push(STRUCT_NAME, "app_version");
                                    error
                                })
                        }
                        _ => ::prost::encoding::skip_field(wire_type, tag, buf, ctx),
                    }
                }
                #[inline]
                fn encoded_len(&self) -> usize {
                    0
                        + self
                            .gossip_address
                            .as_ref()
                            .map_or(
                                0,
                                |msg| ::prost::encoding::message::encoded_len(1u32, msg),
                            )
                        + self
                            .rpc_address
                            .as_ref()
                            .map_or(
                                0,
                                |msg| ::prost::encoding::message::encoded_len(2u32, msg),
                            )
                        + ::prost::encoding::string::encoded_len_repeated(
                            3u32,
                            &self.excluded_hashes,
                        )
                        + if self.count != 0u32 {
                            ::prost::encoding::uint32::encoded_len(4u32, &self.count)
                        } else {
                            0
                        }
                        + if self.hub_version != "" {
                            ::prost::encoding::string::encoded_len(
                                5u32,
                                &self.hub_version,
                            )
                        } else {
                            0
                        }
                        + if self.network != FarcasterNetwork::default() as i32 {
                            ::prost::encoding::int32::encoded_len(6u32, &self.network)
                        } else {
                            0
                        }
                        + if self.app_version != "" {
                            ::prost::encoding::string::encoded_len(
                                7u32,
                                &self.app_version,
                            )
                        } else {
                            0
                        }
                }
                fn clear(&mut self) {
                    self.gossip_address = ::core::option::Option::None;
                    self.rpc_address = ::core::option::Option::None;
                    self.excluded_hashes.clear();
                    self.count = 0u32;
                    self.hub_version.clear();
                    self.network = FarcasterNetwork::default() as i32;
                    self.app_version.clear();
                }
            }
            impl ::core::default::Default for ContactInfoContent {
                fn default() -> Self {
                    ContactInfoContent {
                        gossip_address: ::core::default::Default::default(),
                        rpc_address: ::core::default::Default::default(),
                        excluded_hashes: ::prost::alloc::vec::Vec::new(),
                        count: 0u32,
                        hub_version: ::prost::alloc::string::String::new(),
                        network: FarcasterNetwork::default() as i32,
                        app_version: ::prost::alloc::string::String::new(),
                    }
                }
            }
            impl ::core::fmt::Debug for ContactInfoContent {
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    let mut builder = f.debug_struct("ContactInfoContent");
                    let builder = {
                        let wrapper = &self.gossip_address;
                        builder.field("gossip_address", &wrapper)
                    };
                    let builder = {
                        let wrapper = &self.rpc_address;
                        builder.field("rpc_address", &wrapper)
                    };
                    let builder = {
                        let wrapper = {
                            struct ScalarWrapper<'a>(
                                &'a ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
                            );
                            impl<'a> ::core::fmt::Debug for ScalarWrapper<'a> {
                                fn fmt(
                                    &self,
                                    f: &mut ::core::fmt::Formatter,
                                ) -> ::core::fmt::Result {
                                    let mut vec_builder = f.debug_list();
                                    for v in self.0 {
                                        fn Inner<T>(v: T) -> T {
                                            v
                                        }
                                        vec_builder.entry(&Inner(v));
                                    }
                                    vec_builder.finish()
                                }
                            }
                            ScalarWrapper(&self.excluded_hashes)
                        };
                        builder.field("excluded_hashes", &wrapper)
                    };
                    let builder = {
                        let wrapper = {
                            fn ScalarWrapper<T>(v: T) -> T {
                                v
                            }
                            ScalarWrapper(&self.count)
                        };
                        builder.field("count", &wrapper)
                    };
                    let builder = {
                        let wrapper = {
                            fn ScalarWrapper<T>(v: T) -> T {
                                v
                            }
                            ScalarWrapper(&self.hub_version)
                        };
                        builder.field("hub_version", &wrapper)
                    };
                    let builder = {
                        let wrapper = {
                            struct ScalarWrapper<'a>(&'a i32);
                            impl<'a> ::core::fmt::Debug for ScalarWrapper<'a> {
                                fn fmt(
                                    &self,
                                    f: &mut ::core::fmt::Formatter,
                                ) -> ::core::fmt::Result {
                                    match FarcasterNetwork::from_i32(*self.0) {
                                        None => ::core::fmt::Debug::fmt(&self.0, f),
                                        Some(en) => ::core::fmt::Debug::fmt(&en, f),
                                    }
                                }
                            }
                            ScalarWrapper(&self.network)
                        };
                        builder.field("network", &wrapper)
                    };
                    let builder = {
                        let wrapper = {
                            fn ScalarWrapper<T>(v: T) -> T {
                                v
                            }
                            ScalarWrapper(&self.app_version)
                        };
                        builder.field("app_version", &wrapper)
                    };
                    builder.finish()
                }
            }
            #[allow(dead_code)]
            impl ContactInfoContent {
                ///Returns the enum value of `network`, or the default if the field is set to an invalid enum value.
                pub fn network(&self) -> FarcasterNetwork {
                    FarcasterNetwork::from_i32(self.network)
                        .unwrap_or(FarcasterNetwork::default())
                }
                ///Sets `network` to the provided enum value.
                pub fn set_network(&mut self, value: FarcasterNetwork) {
                    self.network = value as i32;
                }
            }
            #[allow(clippy::derive_partial_eq_without_eq)]
            pub struct PingMessageBody {
                #[prost(bytes = "vec", tag = "1")]
                pub ping_origin_peer_id: ::prost::alloc::vec::Vec<u8>,
                #[prost(uint64, tag = "2")]
                pub ping_timestamp: u64,
            }
            #[automatically_derived]
            #[allow(clippy::derive_partial_eq_without_eq)]
            impl ::core::clone::Clone for PingMessageBody {
                #[inline]
                fn clone(&self) -> PingMessageBody {
                    PingMessageBody {
                        ping_origin_peer_id: ::core::clone::Clone::clone(
                            &self.ping_origin_peer_id,
                        ),
                        ping_timestamp: ::core::clone::Clone::clone(&self.ping_timestamp),
                    }
                }
            }
            #[allow(clippy::derive_partial_eq_without_eq)]
            #[automatically_derived]
            impl ::core::marker::StructuralPartialEq for PingMessageBody {}
            #[automatically_derived]
            #[allow(clippy::derive_partial_eq_without_eq)]
            impl ::core::cmp::PartialEq for PingMessageBody {
                #[inline]
                fn eq(&self, other: &PingMessageBody) -> bool {
                    self.ping_origin_peer_id == other.ping_origin_peer_id
                        && self.ping_timestamp == other.ping_timestamp
                }
            }
            impl ::prost::Message for PingMessageBody {
                #[allow(unused_variables)]
                fn encode_raw<B>(&self, buf: &mut B)
                where
                    B: ::prost::bytes::BufMut,
                {
                    if self.ping_origin_peer_id != b"" as &[u8] {
                        ::prost::encoding::bytes::encode(
                            1u32,
                            &self.ping_origin_peer_id,
                            buf,
                        );
                    }
                    if self.ping_timestamp != 0u64 {
                        ::prost::encoding::uint64::encode(
                            2u32,
                            &self.ping_timestamp,
                            buf,
                        );
                    }
                }
                #[allow(unused_variables)]
                fn merge_field<B>(
                    &mut self,
                    tag: u32,
                    wire_type: ::prost::encoding::WireType,
                    buf: &mut B,
                    ctx: ::prost::encoding::DecodeContext,
                ) -> ::core::result::Result<(), ::prost::DecodeError>
                where
                    B: ::prost::bytes::Buf,
                {
                    const STRUCT_NAME: &'static str = "PingMessageBody";
                    match tag {
                        1u32 => {
                            let mut value = &mut self.ping_origin_peer_id;
                            ::prost::encoding::bytes::merge(wire_type, value, buf, ctx)
                                .map_err(|mut error| {
                                    error.push(STRUCT_NAME, "ping_origin_peer_id");
                                    error
                                })
                        }
                        2u32 => {
                            let mut value = &mut self.ping_timestamp;
                            ::prost::encoding::uint64::merge(wire_type, value, buf, ctx)
                                .map_err(|mut error| {
                                    error.push(STRUCT_NAME, "ping_timestamp");
                                    error
                                })
                        }
                        _ => ::prost::encoding::skip_field(wire_type, tag, buf, ctx),
                    }
                }
                #[inline]
                fn encoded_len(&self) -> usize {
                    0
                        + if self.ping_origin_peer_id != b"" as &[u8] {
                            ::prost::encoding::bytes::encoded_len(
                                1u32,
                                &self.ping_origin_peer_id,
                            )
                        } else {
                            0
                        }
                        + if self.ping_timestamp != 0u64 {
                            ::prost::encoding::uint64::encoded_len(
                                2u32,
                                &self.ping_timestamp,
                            )
                        } else {
                            0
                        }
                }
                fn clear(&mut self) {
                    self.ping_origin_peer_id.clear();
                    self.ping_timestamp = 0u64;
                }
            }
            impl ::core::default::Default for PingMessageBody {
                fn default() -> Self {
                    PingMessageBody {
                        ping_origin_peer_id: ::core::default::Default::default(),
                        ping_timestamp: 0u64,
                    }
                }
            }
            impl ::core::fmt::Debug for PingMessageBody {
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    let mut builder = f.debug_struct("PingMessageBody");
                    let builder = {
                        let wrapper = {
                            fn ScalarWrapper<T>(v: T) -> T {
                                v
                            }
                            ScalarWrapper(&self.ping_origin_peer_id)
                        };
                        builder.field("ping_origin_peer_id", &wrapper)
                    };
                    let builder = {
                        let wrapper = {
                            fn ScalarWrapper<T>(v: T) -> T {
                                v
                            }
                            ScalarWrapper(&self.ping_timestamp)
                        };
                        builder.field("ping_timestamp", &wrapper)
                    };
                    builder.finish()
                }
            }
            #[allow(clippy::derive_partial_eq_without_eq)]
            pub struct AckMessageBody {
                #[prost(bytes = "vec", tag = "1")]
                pub ping_origin_peer_id: ::prost::alloc::vec::Vec<u8>,
                #[prost(bytes = "vec", tag = "2")]
                pub ack_origin_peer_id: ::prost::alloc::vec::Vec<u8>,
                #[prost(uint64, tag = "3")]
                pub ping_timestamp: u64,
                #[prost(uint64, tag = "4")]
                pub ack_timestamp: u64,
            }
            #[automatically_derived]
            #[allow(clippy::derive_partial_eq_without_eq)]
            impl ::core::clone::Clone for AckMessageBody {
                #[inline]
                fn clone(&self) -> AckMessageBody {
                    AckMessageBody {
                        ping_origin_peer_id: ::core::clone::Clone::clone(
                            &self.ping_origin_peer_id,
                        ),
                        ack_origin_peer_id: ::core::clone::Clone::clone(
                            &self.ack_origin_peer_id,
                        ),
                        ping_timestamp: ::core::clone::Clone::clone(
                            &self.ping_timestamp,
                        ),
                        ack_timestamp: ::core::clone::Clone::clone(&self.ack_timestamp),
                    }
                }
            }
            #[allow(clippy::derive_partial_eq_without_eq)]
            #[automatically_derived]
            impl ::core::marker::StructuralPartialEq for AckMessageBody {}
            #[automatically_derived]
            #[allow(clippy::derive_partial_eq_without_eq)]
            impl ::core::cmp::PartialEq for AckMessageBody {
                #[inline]
                fn eq(&self, other: &AckMessageBody) -> bool {
                    self.ping_origin_peer_id == other.ping_origin_peer_id
                        && self.ack_origin_peer_id == other.ack_origin_peer_id
                        && self.ping_timestamp == other.ping_timestamp
                        && self.ack_timestamp == other.ack_timestamp
                }
            }
            impl ::prost::Message for AckMessageBody {
                #[allow(unused_variables)]
                fn encode_raw<B>(&self, buf: &mut B)
                where
                    B: ::prost::bytes::BufMut,
                {
                    if self.ping_origin_peer_id != b"" as &[u8] {
                        ::prost::encoding::bytes::encode(
                            1u32,
                            &self.ping_origin_peer_id,
                            buf,
                        );
                    }
                    if self.ack_origin_peer_id != b"" as &[u8] {
                        ::prost::encoding::bytes::encode(
                            2u32,
                            &self.ack_origin_peer_id,
                            buf,
                        );
                    }
                    if self.ping_timestamp != 0u64 {
                        ::prost::encoding::uint64::encode(
                            3u32,
                            &self.ping_timestamp,
                            buf,
                        );
                    }
                    if self.ack_timestamp != 0u64 {
                        ::prost::encoding::uint64::encode(
                            4u32,
                            &self.ack_timestamp,
                            buf,
                        );
                    }
                }
                #[allow(unused_variables)]
                fn merge_field<B>(
                    &mut self,
                    tag: u32,
                    wire_type: ::prost::encoding::WireType,
                    buf: &mut B,
                    ctx: ::prost::encoding::DecodeContext,
                ) -> ::core::result::Result<(), ::prost::DecodeError>
                where
                    B: ::prost::bytes::Buf,
                {
                    const STRUCT_NAME: &'static str = "AckMessageBody";
                    match tag {
                        1u32 => {
                            let mut value = &mut self.ping_origin_peer_id;
                            ::prost::encoding::bytes::merge(wire_type, value, buf, ctx)
                                .map_err(|mut error| {
                                    error.push(STRUCT_NAME, "ping_origin_peer_id");
                                    error
                                })
                        }
                        2u32 => {
                            let mut value = &mut self.ack_origin_peer_id;
                            ::prost::encoding::bytes::merge(wire_type, value, buf, ctx)
                                .map_err(|mut error| {
                                    error.push(STRUCT_NAME, "ack_origin_peer_id");
                                    error
                                })
                        }
                        3u32 => {
                            let mut value = &mut self.ping_timestamp;
                            ::prost::encoding::uint64::merge(wire_type, value, buf, ctx)
                                .map_err(|mut error| {
                                    error.push(STRUCT_NAME, "ping_timestamp");
                                    error
                                })
                        }
                        4u32 => {
                            let mut value = &mut self.ack_timestamp;
                            ::prost::encoding::uint64::merge(wire_type, value, buf, ctx)
                                .map_err(|mut error| {
                                    error.push(STRUCT_NAME, "ack_timestamp");
                                    error
                                })
                        }
                        _ => ::prost::encoding::skip_field(wire_type, tag, buf, ctx),
                    }
                }
                #[inline]
                fn encoded_len(&self) -> usize {
                    0
                        + if self.ping_origin_peer_id != b"" as &[u8] {
                            ::prost::encoding::bytes::encoded_len(
                                1u32,
                                &self.ping_origin_peer_id,
                            )
                        } else {
                            0
                        }
                        + if self.ack_origin_peer_id != b"" as &[u8] {
                            ::prost::encoding::bytes::encoded_len(
                                2u32,
                                &self.ack_origin_peer_id,
                            )
                        } else {
                            0
                        }
                        + if self.ping_timestamp != 0u64 {
                            ::prost::encoding::uint64::encoded_len(
                                3u32,
                                &self.ping_timestamp,
                            )
                        } else {
                            0
                        }
                        + if self.ack_timestamp != 0u64 {
                            ::prost::encoding::uint64::encoded_len(
                                4u32,
                                &self.ack_timestamp,
                            )
                        } else {
                            0
                        }
                }
                fn clear(&mut self) {
                    self.ping_origin_peer_id.clear();
                    self.ack_origin_peer_id.clear();
                    self.ping_timestamp = 0u64;
                    self.ack_timestamp = 0u64;
                }
            }
            impl ::core::default::Default for AckMessageBody {
                fn default() -> Self {
                    AckMessageBody {
                        ping_origin_peer_id: ::core::default::Default::default(),
                        ack_origin_peer_id: ::core::default::Default::default(),
                        ping_timestamp: 0u64,
                        ack_timestamp: 0u64,
                    }
                }
            }
            impl ::core::fmt::Debug for AckMessageBody {
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    let mut builder = f.debug_struct("AckMessageBody");
                    let builder = {
                        let wrapper = {
                            fn ScalarWrapper<T>(v: T) -> T {
                                v
                            }
                            ScalarWrapper(&self.ping_origin_peer_id)
                        };
                        builder.field("ping_origin_peer_id", &wrapper)
                    };
                    let builder = {
                        let wrapper = {
                            fn ScalarWrapper<T>(v: T) -> T {
                                v
                            }
                            ScalarWrapper(&self.ack_origin_peer_id)
                        };
                        builder.field("ack_origin_peer_id", &wrapper)
                    };
                    let builder = {
                        let wrapper = {
                            fn ScalarWrapper<T>(v: T) -> T {
                                v
                            }
                            ScalarWrapper(&self.ping_timestamp)
                        };
                        builder.field("ping_timestamp", &wrapper)
                    };
                    let builder = {
                        let wrapper = {
                            fn ScalarWrapper<T>(v: T) -> T {
                                v
                            }
                            ScalarWrapper(&self.ack_timestamp)
                        };
                        builder.field("ack_timestamp", &wrapper)
                    };
                    builder.finish()
                }
            }
            #[allow(clippy::derive_partial_eq_without_eq)]
            pub struct NetworkLatencyMessage {
                #[prost(oneof = "network_latency_message::Body", tags = "2, 3")]
                pub body: ::core::option::Option<network_latency_message::Body>,
            }
            #[automatically_derived]
            #[allow(clippy::derive_partial_eq_without_eq)]
            impl ::core::clone::Clone for NetworkLatencyMessage {
                #[inline]
                fn clone(&self) -> NetworkLatencyMessage {
                    NetworkLatencyMessage {
                        body: ::core::clone::Clone::clone(&self.body),
                    }
                }
            }
            #[allow(clippy::derive_partial_eq_without_eq)]
            #[automatically_derived]
            impl ::core::marker::StructuralPartialEq for NetworkLatencyMessage {}
            #[automatically_derived]
            #[allow(clippy::derive_partial_eq_without_eq)]
            impl ::core::cmp::PartialEq for NetworkLatencyMessage {
                #[inline]
                fn eq(&self, other: &NetworkLatencyMessage) -> bool {
                    self.body == other.body
                }
            }
            impl ::prost::Message for NetworkLatencyMessage {
                #[allow(unused_variables)]
                fn encode_raw<B>(&self, buf: &mut B)
                where
                    B: ::prost::bytes::BufMut,
                {
                    if let Some(ref oneof) = self.body {
                        oneof.encode(buf)
                    }
                }
                #[allow(unused_variables)]
                fn merge_field<B>(
                    &mut self,
                    tag: u32,
                    wire_type: ::prost::encoding::WireType,
                    buf: &mut B,
                    ctx: ::prost::encoding::DecodeContext,
                ) -> ::core::result::Result<(), ::prost::DecodeError>
                where
                    B: ::prost::bytes::Buf,
                {
                    const STRUCT_NAME: &'static str = "NetworkLatencyMessage";
                    match tag {
                        2u32 | 3u32 => {
                            let mut value = &mut self.body;
                            network_latency_message::Body::merge(
                                    value,
                                    tag,
                                    wire_type,
                                    buf,
                                    ctx,
                                )
                                .map_err(|mut error| {
                                    error.push(STRUCT_NAME, "body");
                                    error
                                })
                        }
                        _ => ::prost::encoding::skip_field(wire_type, tag, buf, ctx),
                    }
                }
                #[inline]
                fn encoded_len(&self) -> usize {
                    0
                        + self
                            .body
                            .as_ref()
                            .map_or(0, network_latency_message::Body::encoded_len)
                }
                fn clear(&mut self) {
                    self.body = ::core::option::Option::None;
                }
            }
            impl ::core::default::Default for NetworkLatencyMessage {
                fn default() -> Self {
                    NetworkLatencyMessage {
                        body: ::core::default::Default::default(),
                    }
                }
            }
            impl ::core::fmt::Debug for NetworkLatencyMessage {
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    let mut builder = f.debug_struct("NetworkLatencyMessage");
                    let builder = {
                        let wrapper = &self.body;
                        builder.field("body", &wrapper)
                    };
                    builder.finish()
                }
            }
            /// Nested message and enum types in `NetworkLatencyMessage`.
            pub mod network_latency_message {
                #[allow(clippy::derive_partial_eq_without_eq)]
                pub enum Body {
                    #[prost(message, tag = "2")]
                    PingMessage(super::PingMessageBody),
                    #[prost(message, tag = "3")]
                    AckMessage(super::AckMessageBody),
                }
                #[automatically_derived]
                #[allow(clippy::derive_partial_eq_without_eq)]
                impl ::core::clone::Clone for Body {
                    #[inline]
                    fn clone(&self) -> Body {
                        match self {
                            Body::PingMessage(__self_0) => {
                                Body::PingMessage(::core::clone::Clone::clone(__self_0))
                            }
                            Body::AckMessage(__self_0) => {
                                Body::AckMessage(::core::clone::Clone::clone(__self_0))
                            }
                        }
                    }
                }
                #[allow(clippy::derive_partial_eq_without_eq)]
                #[automatically_derived]
                impl ::core::marker::StructuralPartialEq for Body {}
                #[automatically_derived]
                #[allow(clippy::derive_partial_eq_without_eq)]
                impl ::core::cmp::PartialEq for Body {
                    #[inline]
                    fn eq(&self, other: &Body) -> bool {
                        let __self_tag = ::core::intrinsics::discriminant_value(self);
                        let __arg1_tag = ::core::intrinsics::discriminant_value(other);
                        __self_tag == __arg1_tag
                            && match (self, other) {
                                (
                                    Body::PingMessage(__self_0),
                                    Body::PingMessage(__arg1_0),
                                ) => *__self_0 == *__arg1_0,
                                (Body::AckMessage(__self_0), Body::AckMessage(__arg1_0)) => {
                                    *__self_0 == *__arg1_0
                                }
                                _ => unsafe { ::core::intrinsics::unreachable() }
                            }
                    }
                }
                impl Body {
                    /// Encodes the message to a buffer.
                    pub fn encode<B>(&self, buf: &mut B)
                    where
                        B: ::prost::bytes::BufMut,
                    {
                        match *self {
                            Body::PingMessage(ref value) => {
                                ::prost::encoding::message::encode(2u32, &*value, buf);
                            }
                            Body::AckMessage(ref value) => {
                                ::prost::encoding::message::encode(3u32, &*value, buf);
                            }
                        }
                    }
                    /// Decodes an instance of the message from a buffer, and merges it into self.
                    pub fn merge<B>(
                        field: &mut ::core::option::Option<Body>,
                        tag: u32,
                        wire_type: ::prost::encoding::WireType,
                        buf: &mut B,
                        ctx: ::prost::encoding::DecodeContext,
                    ) -> ::core::result::Result<(), ::prost::DecodeError>
                    where
                        B: ::prost::bytes::Buf,
                    {
                        match tag {
                            2u32 => {
                                match field {
                                    ::core::option::Option::Some(
                                        Body::PingMessage(ref mut value),
                                    ) => {
                                        ::prost::encoding::message::merge(
                                            wire_type,
                                            value,
                                            buf,
                                            ctx,
                                        )
                                    }
                                    _ => {
                                        let mut owned_value = ::core::default::Default::default();
                                        let value = &mut owned_value;
                                        ::prost::encoding::message::merge(
                                                wire_type,
                                                value,
                                                buf,
                                                ctx,
                                            )
                                            .map(|_| {
                                                *field = ::core::option::Option::Some(
                                                    Body::PingMessage(owned_value),
                                                );
                                            })
                                    }
                                }
                            }
                            3u32 => {
                                match field {
                                    ::core::option::Option::Some(
                                        Body::AckMessage(ref mut value),
                                    ) => {
                                        ::prost::encoding::message::merge(
                                            wire_type,
                                            value,
                                            buf,
                                            ctx,
                                        )
                                    }
                                    _ => {
                                        let mut owned_value = ::core::default::Default::default();
                                        let value = &mut owned_value;
                                        ::prost::encoding::message::merge(
                                                wire_type,
                                                value,
                                                buf,
                                                ctx,
                                            )
                                            .map(|_| {
                                                *field = ::core::option::Option::Some(
                                                    Body::AckMessage(owned_value),
                                                );
                                            })
                                    }
                                }
                            }
                            _ => {
                                ::core::panicking::panic_fmt(
                                    format_args!(
                                        "internal error: entered unreachable code: {0}",
                                        format_args!("invalid Body tag: {0}", tag),
                                    ),
                                );
                            }
                        }
                    }
                    /// Returns the encoded length of the message without a length delimiter.
                    #[inline]
                    pub fn encoded_len(&self) -> usize {
                        match *self {
                            Body::PingMessage(ref value) => {
                                ::prost::encoding::message::encoded_len(2u32, &*value)
                            }
                            Body::AckMessage(ref value) => {
                                ::prost::encoding::message::encoded_len(3u32, &*value)
                            }
                        }
                    }
                }
                impl ::core::fmt::Debug for Body {
                    fn fmt(
                        &self,
                        f: &mut ::core::fmt::Formatter,
                    ) -> ::core::fmt::Result {
                        match *self {
                            Body::PingMessage(ref value) => {
                                let wrapper = &*value;
                                f.debug_tuple("PingMessage").field(&wrapper).finish()
                            }
                            Body::AckMessage(ref value) => {
                                let wrapper = &*value;
                                f.debug_tuple("AckMessage").field(&wrapper).finish()
                            }
                        }
                    }
                }
            }
            #[allow(clippy::derive_partial_eq_without_eq)]
            pub struct GossipMessage {
                #[prost(string, repeated, tag = "4")]
                pub topics: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
                #[prost(bytes = "vec", tag = "5")]
                pub peer_id: ::prost::alloc::vec::Vec<u8>,
                #[prost(enumeration = "GossipVersion", tag = "6")]
                pub version: i32,
                #[prost(oneof = "gossip_message::Content", tags = "1, 2, 3, 7")]
                pub content: ::core::option::Option<gossip_message::Content>,
            }
            #[automatically_derived]
            #[allow(clippy::derive_partial_eq_without_eq)]
            impl ::core::clone::Clone for GossipMessage {
                #[inline]
                fn clone(&self) -> GossipMessage {
                    GossipMessage {
                        topics: ::core::clone::Clone::clone(&self.topics),
                        peer_id: ::core::clone::Clone::clone(&self.peer_id),
                        version: ::core::clone::Clone::clone(&self.version),
                        content: ::core::clone::Clone::clone(&self.content),
                    }
                }
            }
            #[allow(clippy::derive_partial_eq_without_eq)]
            #[automatically_derived]
            impl ::core::marker::StructuralPartialEq for GossipMessage {}
            #[automatically_derived]
            #[allow(clippy::derive_partial_eq_without_eq)]
            impl ::core::cmp::PartialEq for GossipMessage {
                #[inline]
                fn eq(&self, other: &GossipMessage) -> bool {
                    self.topics == other.topics && self.peer_id == other.peer_id
                        && self.version == other.version && self.content == other.content
                }
            }
            impl ::prost::Message for GossipMessage {
                #[allow(unused_variables)]
                fn encode_raw<B>(&self, buf: &mut B)
                where
                    B: ::prost::bytes::BufMut,
                {
                    if let Some(ref oneof) = self.content {
                        oneof.encode(buf)
                    }
                    ::prost::encoding::string::encode_repeated(4u32, &self.topics, buf);
                    if self.peer_id != b"" as &[u8] {
                        ::prost::encoding::bytes::encode(5u32, &self.peer_id, buf);
                    }
                    if self.version != GossipVersion::default() as i32 {
                        ::prost::encoding::int32::encode(6u32, &self.version, buf);
                    }
                }
                #[allow(unused_variables)]
                fn merge_field<B>(
                    &mut self,
                    tag: u32,
                    wire_type: ::prost::encoding::WireType,
                    buf: &mut B,
                    ctx: ::prost::encoding::DecodeContext,
                ) -> ::core::result::Result<(), ::prost::DecodeError>
                where
                    B: ::prost::bytes::Buf,
                {
                    const STRUCT_NAME: &'static str = "GossipMessage";
                    match tag {
                        1u32 | 2u32 | 3u32 | 7u32 => {
                            let mut value = &mut self.content;
                            gossip_message::Content::merge(
                                    value,
                                    tag,
                                    wire_type,
                                    buf,
                                    ctx,
                                )
                                .map_err(|mut error| {
                                    error.push(STRUCT_NAME, "content");
                                    error
                                })
                        }
                        4u32 => {
                            let mut value = &mut self.topics;
                            ::prost::encoding::string::merge_repeated(
                                    wire_type,
                                    value,
                                    buf,
                                    ctx,
                                )
                                .map_err(|mut error| {
                                    error.push(STRUCT_NAME, "topics");
                                    error
                                })
                        }
                        5u32 => {
                            let mut value = &mut self.peer_id;
                            ::prost::encoding::bytes::merge(wire_type, value, buf, ctx)
                                .map_err(|mut error| {
                                    error.push(STRUCT_NAME, "peer_id");
                                    error
                                })
                        }
                        6u32 => {
                            let mut value = &mut self.version;
                            ::prost::encoding::int32::merge(wire_type, value, buf, ctx)
                                .map_err(|mut error| {
                                    error.push(STRUCT_NAME, "version");
                                    error
                                })
                        }
                        _ => ::prost::encoding::skip_field(wire_type, tag, buf, ctx),
                    }
                }
                #[inline]
                fn encoded_len(&self) -> usize {
                    0
                        + self
                            .content
                            .as_ref()
                            .map_or(0, gossip_message::Content::encoded_len)
                        + ::prost::encoding::string::encoded_len_repeated(
                            4u32,
                            &self.topics,
                        )
                        + if self.peer_id != b"" as &[u8] {
                            ::prost::encoding::bytes::encoded_len(5u32, &self.peer_id)
                        } else {
                            0
                        }
                        + if self.version != GossipVersion::default() as i32 {
                            ::prost::encoding::int32::encoded_len(6u32, &self.version)
                        } else {
                            0
                        }
                }
                fn clear(&mut self) {
                    self.content = ::core::option::Option::None;
                    self.topics.clear();
                    self.peer_id.clear();
                    self.version = GossipVersion::default() as i32;
                }
            }
            impl ::core::default::Default for GossipMessage {
                fn default() -> Self {
                    GossipMessage {
                        content: ::core::default::Default::default(),
                        topics: ::prost::alloc::vec::Vec::new(),
                        peer_id: ::core::default::Default::default(),
                        version: GossipVersion::default() as i32,
                    }
                }
            }
            impl ::core::fmt::Debug for GossipMessage {
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    let mut builder = f.debug_struct("GossipMessage");
                    let builder = {
                        let wrapper = {
                            struct ScalarWrapper<'a>(
                                &'a ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
                            );
                            impl<'a> ::core::fmt::Debug for ScalarWrapper<'a> {
                                fn fmt(
                                    &self,
                                    f: &mut ::core::fmt::Formatter,
                                ) -> ::core::fmt::Result {
                                    let mut vec_builder = f.debug_list();
                                    for v in self.0 {
                                        fn Inner<T>(v: T) -> T {
                                            v
                                        }
                                        vec_builder.entry(&Inner(v));
                                    }
                                    vec_builder.finish()
                                }
                            }
                            ScalarWrapper(&self.topics)
                        };
                        builder.field("topics", &wrapper)
                    };
                    let builder = {
                        let wrapper = {
                            fn ScalarWrapper<T>(v: T) -> T {
                                v
                            }
                            ScalarWrapper(&self.peer_id)
                        };
                        builder.field("peer_id", &wrapper)
                    };
                    let builder = {
                        let wrapper = {
                            struct ScalarWrapper<'a>(&'a i32);
                            impl<'a> ::core::fmt::Debug for ScalarWrapper<'a> {
                                fn fmt(
                                    &self,
                                    f: &mut ::core::fmt::Formatter,
                                ) -> ::core::fmt::Result {
                                    match GossipVersion::from_i32(*self.0) {
                                        None => ::core::fmt::Debug::fmt(&self.0, f),
                                        Some(en) => ::core::fmt::Debug::fmt(&en, f),
                                    }
                                }
                            }
                            ScalarWrapper(&self.version)
                        };
                        builder.field("version", &wrapper)
                    };
                    let builder = {
                        let wrapper = &self.content;
                        builder.field("content", &wrapper)
                    };
                    builder.finish()
                }
            }
            #[allow(dead_code)]
            impl GossipMessage {
                ///Returns the enum value of `version`, or the default if the field is set to an invalid enum value.
                pub fn version(&self) -> GossipVersion {
                    GossipVersion::from_i32(self.version)
                        .unwrap_or(GossipVersion::default())
                }
                ///Sets `version` to the provided enum value.
                pub fn set_version(&mut self, value: GossipVersion) {
                    self.version = value as i32;
                }
            }
            /// Nested message and enum types in `GossipMessage`.
            pub mod gossip_message {
                #[allow(clippy::derive_partial_eq_without_eq)]
                pub enum Content {
                    #[prost(message, tag = "1")]
                    Message(super::Message),
                    #[prost(message, tag = "2")]
                    IdRegistryEvent(super::IdRegistryEvent),
                    #[prost(message, tag = "3")]
                    ContactInfoContent(super::ContactInfoContent),
                    #[prost(message, tag = "7")]
                    NetworkLatencyMessage(super::NetworkLatencyMessage),
                }
                #[automatically_derived]
                #[allow(clippy::derive_partial_eq_without_eq)]
                impl ::core::clone::Clone for Content {
                    #[inline]
                    fn clone(&self) -> Content {
                        match self {
                            Content::Message(__self_0) => {
                                Content::Message(::core::clone::Clone::clone(__self_0))
                            }
                            Content::IdRegistryEvent(__self_0) => {
                                Content::IdRegistryEvent(
                                    ::core::clone::Clone::clone(__self_0),
                                )
                            }
                            Content::ContactInfoContent(__self_0) => {
                                Content::ContactInfoContent(
                                    ::core::clone::Clone::clone(__self_0),
                                )
                            }
                            Content::NetworkLatencyMessage(__self_0) => {
                                Content::NetworkLatencyMessage(
                                    ::core::clone::Clone::clone(__self_0),
                                )
                            }
                        }
                    }
                }
                #[allow(clippy::derive_partial_eq_without_eq)]
                #[automatically_derived]
                impl ::core::marker::StructuralPartialEq for Content {}
                #[automatically_derived]
                #[allow(clippy::derive_partial_eq_without_eq)]
                impl ::core::cmp::PartialEq for Content {
                    #[inline]
                    fn eq(&self, other: &Content) -> bool {
                        let __self_tag = ::core::intrinsics::discriminant_value(self);
                        let __arg1_tag = ::core::intrinsics::discriminant_value(other);
                        __self_tag == __arg1_tag
                            && match (self, other) {
                                (Content::Message(__self_0), Content::Message(__arg1_0)) => {
                                    *__self_0 == *__arg1_0
                                }
                                (
                                    Content::IdRegistryEvent(__self_0),
                                    Content::IdRegistryEvent(__arg1_0),
                                ) => *__self_0 == *__arg1_0,
                                (
                                    Content::ContactInfoContent(__self_0),
                                    Content::ContactInfoContent(__arg1_0),
                                ) => *__self_0 == *__arg1_0,
                                (
                                    Content::NetworkLatencyMessage(__self_0),
                                    Content::NetworkLatencyMessage(__arg1_0),
                                ) => *__self_0 == *__arg1_0,
                                _ => unsafe { ::core::intrinsics::unreachable() }
                            }
                    }
                }
                impl Content {
                    /// Encodes the message to a buffer.
                    pub fn encode<B>(&self, buf: &mut B)
                    where
                        B: ::prost::bytes::BufMut,
                    {
                        match *self {
                            Content::Message(ref value) => {
                                ::prost::encoding::message::encode(1u32, &*value, buf);
                            }
                            Content::IdRegistryEvent(ref value) => {
                                ::prost::encoding::message::encode(2u32, &*value, buf);
                            }
                            Content::ContactInfoContent(ref value) => {
                                ::prost::encoding::message::encode(3u32, &*value, buf);
                            }
                            Content::NetworkLatencyMessage(ref value) => {
                                ::prost::encoding::message::encode(7u32, &*value, buf);
                            }
                        }
                    }
                    /// Decodes an instance of the message from a buffer, and merges it into self.
                    pub fn merge<B>(
                        field: &mut ::core::option::Option<Content>,
                        tag: u32,
                        wire_type: ::prost::encoding::WireType,
                        buf: &mut B,
                        ctx: ::prost::encoding::DecodeContext,
                    ) -> ::core::result::Result<(), ::prost::DecodeError>
                    where
                        B: ::prost::bytes::Buf,
                    {
                        match tag {
                            1u32 => {
                                match field {
                                    ::core::option::Option::Some(
                                        Content::Message(ref mut value),
                                    ) => {
                                        ::prost::encoding::message::merge(
                                            wire_type,
                                            value,
                                            buf,
                                            ctx,
                                        )
                                    }
                                    _ => {
                                        let mut owned_value = ::core::default::Default::default();
                                        let value = &mut owned_value;
                                        ::prost::encoding::message::merge(
                                                wire_type,
                                                value,
                                                buf,
                                                ctx,
                                            )
                                            .map(|_| {
                                                *field = ::core::option::Option::Some(
                                                    Content::Message(owned_value),
                                                );
                                            })
                                    }
                                }
                            }
                            2u32 => {
                                match field {
                                    ::core::option::Option::Some(
                                        Content::IdRegistryEvent(ref mut value),
                                    ) => {
                                        ::prost::encoding::message::merge(
                                            wire_type,
                                            value,
                                            buf,
                                            ctx,
                                        )
                                    }
                                    _ => {
                                        let mut owned_value = ::core::default::Default::default();
                                        let value = &mut owned_value;
                                        ::prost::encoding::message::merge(
                                                wire_type,
                                                value,
                                                buf,
                                                ctx,
                                            )
                                            .map(|_| {
                                                *field = ::core::option::Option::Some(
                                                    Content::IdRegistryEvent(owned_value),
                                                );
                                            })
                                    }
                                }
                            }
                            3u32 => {
                                match field {
                                    ::core::option::Option::Some(
                                        Content::ContactInfoContent(ref mut value),
                                    ) => {
                                        ::prost::encoding::message::merge(
                                            wire_type,
                                            value,
                                            buf,
                                            ctx,
                                        )
                                    }
                                    _ => {
                                        let mut owned_value = ::core::default::Default::default();
                                        let value = &mut owned_value;
                                        ::prost::encoding::message::merge(
                                                wire_type,
                                                value,
                                                buf,
                                                ctx,
                                            )
                                            .map(|_| {
                                                *field = ::core::option::Option::Some(
                                                    Content::ContactInfoContent(owned_value),
                                                );
                                            })
                                    }
                                }
                            }
                            7u32 => {
                                match field {
                                    ::core::option::Option::Some(
                                        Content::NetworkLatencyMessage(ref mut value),
                                    ) => {
                                        ::prost::encoding::message::merge(
                                            wire_type,
                                            value,
                                            buf,
                                            ctx,
                                        )
                                    }
                                    _ => {
                                        let mut owned_value = ::core::default::Default::default();
                                        let value = &mut owned_value;
                                        ::prost::encoding::message::merge(
                                                wire_type,
                                                value,
                                                buf,
                                                ctx,
                                            )
                                            .map(|_| {
                                                *field = ::core::option::Option::Some(
                                                    Content::NetworkLatencyMessage(owned_value),
                                                );
                                            })
                                    }
                                }
                            }
                            _ => {
                                ::core::panicking::panic_fmt(
                                    format_args!(
                                        "internal error: entered unreachable code: {0}",
                                        format_args!("invalid Content tag: {0}", tag),
                                    ),
                                );
                            }
                        }
                    }
                    /// Returns the encoded length of the message without a length delimiter.
                    #[inline]
                    pub fn encoded_len(&self) -> usize {
                        match *self {
                            Content::Message(ref value) => {
                                ::prost::encoding::message::encoded_len(1u32, &*value)
                            }
                            Content::IdRegistryEvent(ref value) => {
                                ::prost::encoding::message::encoded_len(2u32, &*value)
                            }
                            Content::ContactInfoContent(ref value) => {
                                ::prost::encoding::message::encoded_len(3u32, &*value)
                            }
                            Content::NetworkLatencyMessage(ref value) => {
                                ::prost::encoding::message::encoded_len(7u32, &*value)
                            }
                        }
                    }
                }
                impl ::core::fmt::Debug for Content {
                    fn fmt(
                        &self,
                        f: &mut ::core::fmt::Formatter,
                    ) -> ::core::fmt::Result {
                        match *self {
                            Content::Message(ref value) => {
                                let wrapper = &*value;
                                f.debug_tuple("Message").field(&wrapper).finish()
                            }
                            Content::IdRegistryEvent(ref value) => {
                                let wrapper = &*value;
                                f.debug_tuple("IdRegistryEvent").field(&wrapper).finish()
                            }
                            Content::ContactInfoContent(ref value) => {
                                let wrapper = &*value;
                                f.debug_tuple("ContactInfoContent").field(&wrapper).finish()
                            }
                            Content::NetworkLatencyMessage(ref value) => {
                                let wrapper = &*value;
                                f.debug_tuple("NetworkLatencyMessage")
                                    .field(&wrapper)
                                    .finish()
                            }
                        }
                    }
                }
            }
            #[repr(i32)]
            pub enum GossipVersion {
                V1 = 0,
                V11 = 1,
            }
            #[automatically_derived]
            impl ::core::clone::Clone for GossipVersion {
                #[inline]
                fn clone(&self) -> GossipVersion {
                    *self
                }
            }
            #[automatically_derived]
            impl ::core::marker::Copy for GossipVersion {}
            #[automatically_derived]
            impl ::core::fmt::Debug for GossipVersion {
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    ::core::fmt::Formatter::write_str(
                        f,
                        match self {
                            GossipVersion::V1 => "V1",
                            GossipVersion::V11 => "V11",
                        },
                    )
                }
            }
            #[automatically_derived]
            impl ::core::marker::StructuralPartialEq for GossipVersion {}
            #[automatically_derived]
            impl ::core::cmp::PartialEq for GossipVersion {
                #[inline]
                fn eq(&self, other: &GossipVersion) -> bool {
                    let __self_tag = ::core::intrinsics::discriminant_value(self);
                    let __arg1_tag = ::core::intrinsics::discriminant_value(other);
                    __self_tag == __arg1_tag
                }
            }
            #[automatically_derived]
            impl ::core::marker::StructuralEq for GossipVersion {}
            #[automatically_derived]
            impl ::core::cmp::Eq for GossipVersion {
                #[inline]
                #[doc(hidden)]
                #[no_coverage]
                fn assert_receiver_is_total_eq(&self) -> () {}
            }
            #[automatically_derived]
            impl ::core::hash::Hash for GossipVersion {
                fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {
                    let __self_tag = ::core::intrinsics::discriminant_value(self);
                    ::core::hash::Hash::hash(&__self_tag, state)
                }
            }
            #[automatically_derived]
            impl ::core::cmp::PartialOrd for GossipVersion {
                #[inline]
                fn partial_cmp(
                    &self,
                    other: &GossipVersion,
                ) -> ::core::option::Option<::core::cmp::Ordering> {
                    let __self_tag = ::core::intrinsics::discriminant_value(self);
                    let __arg1_tag = ::core::intrinsics::discriminant_value(other);
                    ::core::cmp::PartialOrd::partial_cmp(&__self_tag, &__arg1_tag)
                }
            }
            #[automatically_derived]
            impl ::core::cmp::Ord for GossipVersion {
                #[inline]
                fn cmp(&self, other: &GossipVersion) -> ::core::cmp::Ordering {
                    let __self_tag = ::core::intrinsics::discriminant_value(self);
                    let __arg1_tag = ::core::intrinsics::discriminant_value(other);
                    ::core::cmp::Ord::cmp(&__self_tag, &__arg1_tag)
                }
            }
            impl GossipVersion {
                ///Returns `true` if `value` is a variant of `GossipVersion`.
                pub fn is_valid(value: i32) -> bool {
                    match value {
                        0 => true,
                        1 => true,
                        _ => false,
                    }
                }
                ///Converts an `i32` to a `GossipVersion`, or `None` if `value` is not a valid variant.
                pub fn from_i32(value: i32) -> ::core::option::Option<GossipVersion> {
                    match value {
                        0 => ::core::option::Option::Some(GossipVersion::V1),
                        1 => ::core::option::Option::Some(GossipVersion::V11),
                        _ => ::core::option::Option::None,
                    }
                }
            }
            impl ::core::default::Default for GossipVersion {
                fn default() -> GossipVersion {
                    GossipVersion::V1
                }
            }
            impl ::core::convert::From<GossipVersion> for i32 {
                fn from(value: GossipVersion) -> i32 {
                    value as i32
                }
            }
            impl GossipVersion {
                /// String value of the enum field names used in the ProtoBuf definition.
                ///
                /// The values are not transformed in any way and thus are considered stable
                /// (if the ProtoBuf definition does not change) and safe for programmatic use.
                pub fn as_str_name(&self) -> &'static str {
                    match self {
                        GossipVersion::V1 => "GOSSIP_VERSION_V1",
                        GossipVersion::V11 => "GOSSIP_VERSION_V1_1",
                    }
                }
                /// Creates an enum from field names used in the ProtoBuf definition.
                pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
                    match value {
                        "GOSSIP_VERSION_V1" => Some(Self::V1),
                        "GOSSIP_VERSION_V1_1" => Some(Self::V11),
                        _ => None,
                    }
                }
            }
            #[allow(clippy::derive_partial_eq_without_eq)]
            pub struct NameRegistryEvent {
                #[prost(uint32, tag = "1")]
                pub block_number: u32,
                #[prost(bytes = "vec", tag = "2")]
                pub block_hash: ::prost::alloc::vec::Vec<u8>,
                #[prost(bytes = "vec", tag = "3")]
                pub transaction_hash: ::prost::alloc::vec::Vec<u8>,
                #[prost(uint32, tag = "4")]
                pub log_index: u32,
                #[prost(bytes = "vec", tag = "5")]
                pub fname: ::prost::alloc::vec::Vec<u8>,
                #[prost(bytes = "vec", tag = "6")]
                pub from: ::prost::alloc::vec::Vec<u8>,
                #[prost(bytes = "vec", tag = "7")]
                pub to: ::prost::alloc::vec::Vec<u8>,
                #[prost(enumeration = "NameRegistryEventType", tag = "8")]
                pub r#type: i32,
                #[prost(uint32, tag = "9")]
                pub expiry: u32,
            }
            #[automatically_derived]
            #[allow(clippy::derive_partial_eq_without_eq)]
            impl ::core::clone::Clone for NameRegistryEvent {
                #[inline]
                fn clone(&self) -> NameRegistryEvent {
                    NameRegistryEvent {
                        block_number: ::core::clone::Clone::clone(&self.block_number),
                        block_hash: ::core::clone::Clone::clone(&self.block_hash),
                        transaction_hash: ::core::clone::Clone::clone(
                            &self.transaction_hash,
                        ),
                        log_index: ::core::clone::Clone::clone(&self.log_index),
                        fname: ::core::clone::Clone::clone(&self.fname),
                        from: ::core::clone::Clone::clone(&self.from),
                        to: ::core::clone::Clone::clone(&self.to),
                        r#type: ::core::clone::Clone::clone(&self.r#type),
                        expiry: ::core::clone::Clone::clone(&self.expiry),
                    }
                }
            }
            #[allow(clippy::derive_partial_eq_without_eq)]
            #[automatically_derived]
            impl ::core::marker::StructuralPartialEq for NameRegistryEvent {}
            #[automatically_derived]
            #[allow(clippy::derive_partial_eq_without_eq)]
            impl ::core::cmp::PartialEq for NameRegistryEvent {
                #[inline]
                fn eq(&self, other: &NameRegistryEvent) -> bool {
                    self.block_number == other.block_number
                        && self.block_hash == other.block_hash
                        && self.transaction_hash == other.transaction_hash
                        && self.log_index == other.log_index && self.fname == other.fname
                        && self.from == other.from && self.to == other.to
                        && self.r#type == other.r#type && self.expiry == other.expiry
                }
            }
            impl ::prost::Message for NameRegistryEvent {
                #[allow(unused_variables)]
                fn encode_raw<B>(&self, buf: &mut B)
                where
                    B: ::prost::bytes::BufMut,
                {
                    if self.block_number != 0u32 {
                        ::prost::encoding::uint32::encode(1u32, &self.block_number, buf);
                    }
                    if self.block_hash != b"" as &[u8] {
                        ::prost::encoding::bytes::encode(2u32, &self.block_hash, buf);
                    }
                    if self.transaction_hash != b"" as &[u8] {
                        ::prost::encoding::bytes::encode(
                            3u32,
                            &self.transaction_hash,
                            buf,
                        );
                    }
                    if self.log_index != 0u32 {
                        ::prost::encoding::uint32::encode(4u32, &self.log_index, buf);
                    }
                    if self.fname != b"" as &[u8] {
                        ::prost::encoding::bytes::encode(5u32, &self.fname, buf);
                    }
                    if self.from != b"" as &[u8] {
                        ::prost::encoding::bytes::encode(6u32, &self.from, buf);
                    }
                    if self.to != b"" as &[u8] {
                        ::prost::encoding::bytes::encode(7u32, &self.to, buf);
                    }
                    if self.r#type != NameRegistryEventType::default() as i32 {
                        ::prost::encoding::int32::encode(8u32, &self.r#type, buf);
                    }
                    if self.expiry != 0u32 {
                        ::prost::encoding::uint32::encode(9u32, &self.expiry, buf);
                    }
                }
                #[allow(unused_variables)]
                fn merge_field<B>(
                    &mut self,
                    tag: u32,
                    wire_type: ::prost::encoding::WireType,
                    buf: &mut B,
                    ctx: ::prost::encoding::DecodeContext,
                ) -> ::core::result::Result<(), ::prost::DecodeError>
                where
                    B: ::prost::bytes::Buf,
                {
                    const STRUCT_NAME: &'static str = "NameRegistryEvent";
                    match tag {
                        1u32 => {
                            let mut value = &mut self.block_number;
                            ::prost::encoding::uint32::merge(wire_type, value, buf, ctx)
                                .map_err(|mut error| {
                                    error.push(STRUCT_NAME, "block_number");
                                    error
                                })
                        }
                        2u32 => {
                            let mut value = &mut self.block_hash;
                            ::prost::encoding::bytes::merge(wire_type, value, buf, ctx)
                                .map_err(|mut error| {
                                    error.push(STRUCT_NAME, "block_hash");
                                    error
                                })
                        }
                        3u32 => {
                            let mut value = &mut self.transaction_hash;
                            ::prost::encoding::bytes::merge(wire_type, value, buf, ctx)
                                .map_err(|mut error| {
                                    error.push(STRUCT_NAME, "transaction_hash");
                                    error
                                })
                        }
                        4u32 => {
                            let mut value = &mut self.log_index;
                            ::prost::encoding::uint32::merge(wire_type, value, buf, ctx)
                                .map_err(|mut error| {
                                    error.push(STRUCT_NAME, "log_index");
                                    error
                                })
                        }
                        5u32 => {
                            let mut value = &mut self.fname;
                            ::prost::encoding::bytes::merge(wire_type, value, buf, ctx)
                                .map_err(|mut error| {
                                    error.push(STRUCT_NAME, "fname");
                                    error
                                })
                        }
                        6u32 => {
                            let mut value = &mut self.from;
                            ::prost::encoding::bytes::merge(wire_type, value, buf, ctx)
                                .map_err(|mut error| {
                                    error.push(STRUCT_NAME, "from");
                                    error
                                })
                        }
                        7u32 => {
                            let mut value = &mut self.to;
                            ::prost::encoding::bytes::merge(wire_type, value, buf, ctx)
                                .map_err(|mut error| {
                                    error.push(STRUCT_NAME, "to");
                                    error
                                })
                        }
                        8u32 => {
                            let mut value = &mut self.r#type;
                            ::prost::encoding::int32::merge(wire_type, value, buf, ctx)
                                .map_err(|mut error| {
                                    error.push(STRUCT_NAME, "r#type");
                                    error
                                })
                        }
                        9u32 => {
                            let mut value = &mut self.expiry;
                            ::prost::encoding::uint32::merge(wire_type, value, buf, ctx)
                                .map_err(|mut error| {
                                    error.push(STRUCT_NAME, "expiry");
                                    error
                                })
                        }
                        _ => ::prost::encoding::skip_field(wire_type, tag, buf, ctx),
                    }
                }
                #[inline]
                fn encoded_len(&self) -> usize {
                    0
                        + if self.block_number != 0u32 {
                            ::prost::encoding::uint32::encoded_len(
                                1u32,
                                &self.block_number,
                            )
                        } else {
                            0
                        }
                        + if self.block_hash != b"" as &[u8] {
                            ::prost::encoding::bytes::encoded_len(2u32, &self.block_hash)
                        } else {
                            0
                        }
                        + if self.transaction_hash != b"" as &[u8] {
                            ::prost::encoding::bytes::encoded_len(
                                3u32,
                                &self.transaction_hash,
                            )
                        } else {
                            0
                        }
                        + if self.log_index != 0u32 {
                            ::prost::encoding::uint32::encoded_len(4u32, &self.log_index)
                        } else {
                            0
                        }
                        + if self.fname != b"" as &[u8] {
                            ::prost::encoding::bytes::encoded_len(5u32, &self.fname)
                        } else {
                            0
                        }
                        + if self.from != b"" as &[u8] {
                            ::prost::encoding::bytes::encoded_len(6u32, &self.from)
                        } else {
                            0
                        }
                        + if self.to != b"" as &[u8] {
                            ::prost::encoding::bytes::encoded_len(7u32, &self.to)
                        } else {
                            0
                        }
                        + if self.r#type != NameRegistryEventType::default() as i32 {
                            ::prost::encoding::int32::encoded_len(8u32, &self.r#type)
                        } else {
                            0
                        }
                        + if self.expiry != 0u32 {
                            ::prost::encoding::uint32::encoded_len(9u32, &self.expiry)
                        } else {
                            0
                        }
                }
                fn clear(&mut self) {
                    self.block_number = 0u32;
                    self.block_hash.clear();
                    self.transaction_hash.clear();
                    self.log_index = 0u32;
                    self.fname.clear();
                    self.from.clear();
                    self.to.clear();
                    self.r#type = NameRegistryEventType::default() as i32;
                    self.expiry = 0u32;
                }
            }
            impl ::core::default::Default for NameRegistryEvent {
                fn default() -> Self {
                    NameRegistryEvent {
                        block_number: 0u32,
                        block_hash: ::core::default::Default::default(),
                        transaction_hash: ::core::default::Default::default(),
                        log_index: 0u32,
                        fname: ::core::default::Default::default(),
                        from: ::core::default::Default::default(),
                        to: ::core::default::Default::default(),
                        r#type: NameRegistryEventType::default() as i32,
                        expiry: 0u32,
                    }
                }
            }
            impl ::core::fmt::Debug for NameRegistryEvent {
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    let mut builder = f.debug_struct("NameRegistryEvent");
                    let builder = {
                        let wrapper = {
                            fn ScalarWrapper<T>(v: T) -> T {
                                v
                            }
                            ScalarWrapper(&self.block_number)
                        };
                        builder.field("block_number", &wrapper)
                    };
                    let builder = {
                        let wrapper = {
                            fn ScalarWrapper<T>(v: T) -> T {
                                v
                            }
                            ScalarWrapper(&self.block_hash)
                        };
                        builder.field("block_hash", &wrapper)
                    };
                    let builder = {
                        let wrapper = {
                            fn ScalarWrapper<T>(v: T) -> T {
                                v
                            }
                            ScalarWrapper(&self.transaction_hash)
                        };
                        builder.field("transaction_hash", &wrapper)
                    };
                    let builder = {
                        let wrapper = {
                            fn ScalarWrapper<T>(v: T) -> T {
                                v
                            }
                            ScalarWrapper(&self.log_index)
                        };
                        builder.field("log_index", &wrapper)
                    };
                    let builder = {
                        let wrapper = {
                            fn ScalarWrapper<T>(v: T) -> T {
                                v
                            }
                            ScalarWrapper(&self.fname)
                        };
                        builder.field("fname", &wrapper)
                    };
                    let builder = {
                        let wrapper = {
                            fn ScalarWrapper<T>(v: T) -> T {
                                v
                            }
                            ScalarWrapper(&self.from)
                        };
                        builder.field("from", &wrapper)
                    };
                    let builder = {
                        let wrapper = {
                            fn ScalarWrapper<T>(v: T) -> T {
                                v
                            }
                            ScalarWrapper(&self.to)
                        };
                        builder.field("to", &wrapper)
                    };
                    let builder = {
                        let wrapper = {
                            struct ScalarWrapper<'a>(&'a i32);
                            impl<'a> ::core::fmt::Debug for ScalarWrapper<'a> {
                                fn fmt(
                                    &self,
                                    f: &mut ::core::fmt::Formatter,
                                ) -> ::core::fmt::Result {
                                    match NameRegistryEventType::from_i32(*self.0) {
                                        None => ::core::fmt::Debug::fmt(&self.0, f),
                                        Some(en) => ::core::fmt::Debug::fmt(&en, f),
                                    }
                                }
                            }
                            ScalarWrapper(&self.r#type)
                        };
                        builder.field("r#type", &wrapper)
                    };
                    let builder = {
                        let wrapper = {
                            fn ScalarWrapper<T>(v: T) -> T {
                                v
                            }
                            ScalarWrapper(&self.expiry)
                        };
                        builder.field("expiry", &wrapper)
                    };
                    builder.finish()
                }
            }
            #[allow(dead_code)]
            impl NameRegistryEvent {
                ///Returns the enum value of `type`, or the default if the field is set to an invalid enum value.
                pub fn r#type(&self) -> NameRegistryEventType {
                    NameRegistryEventType::from_i32(self.r#type)
                        .unwrap_or(NameRegistryEventType::default())
                }
                ///Sets `type` to the provided enum value.
                pub fn set_type(&mut self, value: NameRegistryEventType) {
                    self.r#type = value as i32;
                }
            }
            #[repr(i32)]
            pub enum NameRegistryEventType {
                None = 0,
                Transfer = 1,
                Renew = 2,
            }
            #[automatically_derived]
            impl ::core::clone::Clone for NameRegistryEventType {
                #[inline]
                fn clone(&self) -> NameRegistryEventType {
                    *self
                }
            }
            #[automatically_derived]
            impl ::core::marker::Copy for NameRegistryEventType {}
            #[automatically_derived]
            impl ::core::fmt::Debug for NameRegistryEventType {
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    ::core::fmt::Formatter::write_str(
                        f,
                        match self {
                            NameRegistryEventType::None => "None",
                            NameRegistryEventType::Transfer => "Transfer",
                            NameRegistryEventType::Renew => "Renew",
                        },
                    )
                }
            }
            #[automatically_derived]
            impl ::core::marker::StructuralPartialEq for NameRegistryEventType {}
            #[automatically_derived]
            impl ::core::cmp::PartialEq for NameRegistryEventType {
                #[inline]
                fn eq(&self, other: &NameRegistryEventType) -> bool {
                    let __self_tag = ::core::intrinsics::discriminant_value(self);
                    let __arg1_tag = ::core::intrinsics::discriminant_value(other);
                    __self_tag == __arg1_tag
                }
            }
            #[automatically_derived]
            impl ::core::marker::StructuralEq for NameRegistryEventType {}
            #[automatically_derived]
            impl ::core::cmp::Eq for NameRegistryEventType {
                #[inline]
                #[doc(hidden)]
                #[no_coverage]
                fn assert_receiver_is_total_eq(&self) -> () {}
            }
            #[automatically_derived]
            impl ::core::hash::Hash for NameRegistryEventType {
                fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {
                    let __self_tag = ::core::intrinsics::discriminant_value(self);
                    ::core::hash::Hash::hash(&__self_tag, state)
                }
            }
            #[automatically_derived]
            impl ::core::cmp::PartialOrd for NameRegistryEventType {
                #[inline]
                fn partial_cmp(
                    &self,
                    other: &NameRegistryEventType,
                ) -> ::core::option::Option<::core::cmp::Ordering> {
                    let __self_tag = ::core::intrinsics::discriminant_value(self);
                    let __arg1_tag = ::core::intrinsics::discriminant_value(other);
                    ::core::cmp::PartialOrd::partial_cmp(&__self_tag, &__arg1_tag)
                }
            }
            #[automatically_derived]
            impl ::core::cmp::Ord for NameRegistryEventType {
                #[inline]
                fn cmp(&self, other: &NameRegistryEventType) -> ::core::cmp::Ordering {
                    let __self_tag = ::core::intrinsics::discriminant_value(self);
                    let __arg1_tag = ::core::intrinsics::discriminant_value(other);
                    ::core::cmp::Ord::cmp(&__self_tag, &__arg1_tag)
                }
            }
            impl NameRegistryEventType {
                ///Returns `true` if `value` is a variant of `NameRegistryEventType`.
                pub fn is_valid(value: i32) -> bool {
                    match value {
                        0 => true,
                        1 => true,
                        2 => true,
                        _ => false,
                    }
                }
                ///Converts an `i32` to a `NameRegistryEventType`, or `None` if `value` is not a valid variant.
                pub fn from_i32(
                    value: i32,
                ) -> ::core::option::Option<NameRegistryEventType> {
                    match value {
                        0 => ::core::option::Option::Some(NameRegistryEventType::None),
                        1 => {
                            ::core::option::Option::Some(NameRegistryEventType::Transfer)
                        }
                        2 => ::core::option::Option::Some(NameRegistryEventType::Renew),
                        _ => ::core::option::Option::None,
                    }
                }
            }
            impl ::core::default::Default for NameRegistryEventType {
                fn default() -> NameRegistryEventType {
                    NameRegistryEventType::None
                }
            }
            impl ::core::convert::From<NameRegistryEventType> for i32 {
                fn from(value: NameRegistryEventType) -> i32 {
                    value as i32
                }
            }
            impl NameRegistryEventType {
                /// String value of the enum field names used in the ProtoBuf definition.
                ///
                /// The values are not transformed in any way and thus are considered stable
                /// (if the ProtoBuf definition does not change) and safe for programmatic use.
                pub fn as_str_name(&self) -> &'static str {
                    match self {
                        NameRegistryEventType::None => "NAME_REGISTRY_EVENT_TYPE_NONE",
                        NameRegistryEventType::Transfer => {
                            "NAME_REGISTRY_EVENT_TYPE_TRANSFER"
                        }
                        NameRegistryEventType::Renew => "NAME_REGISTRY_EVENT_TYPE_RENEW",
                    }
                }
                /// Creates an enum from field names used in the ProtoBuf definition.
                pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
                    match value {
                        "NAME_REGISTRY_EVENT_TYPE_NONE" => Some(Self::None),
                        "NAME_REGISTRY_EVENT_TYPE_TRANSFER" => Some(Self::Transfer),
                        "NAME_REGISTRY_EVENT_TYPE_RENEW" => Some(Self::Renew),
                        _ => None,
                    }
                }
            }
            #[allow(clippy::derive_partial_eq_without_eq)]
            pub struct OnChainEvent {
                #[prost(enumeration = "OnChainEventType", tag = "1")]
                pub r#type: i32,
                #[prost(uint32, tag = "2")]
                pub chain_id: u32,
                #[prost(uint32, tag = "3")]
                pub block_number: u32,
                #[prost(bytes = "vec", tag = "4")]
                pub block_hash: ::prost::alloc::vec::Vec<u8>,
                #[prost(uint64, tag = "5")]
                pub block_timestamp: u64,
                #[prost(bytes = "vec", tag = "6")]
                pub transaction_hash: ::prost::alloc::vec::Vec<u8>,
                #[prost(uint32, tag = "7")]
                pub log_index: u32,
                #[prost(uint64, tag = "8")]
                pub fid: u64,
                #[prost(oneof = "on_chain_event::Body", tags = "9, 10, 11, 12")]
                pub body: ::core::option::Option<on_chain_event::Body>,
            }
            #[automatically_derived]
            #[allow(clippy::derive_partial_eq_without_eq)]
            impl ::core::clone::Clone for OnChainEvent {
                #[inline]
                fn clone(&self) -> OnChainEvent {
                    OnChainEvent {
                        r#type: ::core::clone::Clone::clone(&self.r#type),
                        chain_id: ::core::clone::Clone::clone(&self.chain_id),
                        block_number: ::core::clone::Clone::clone(&self.block_number),
                        block_hash: ::core::clone::Clone::clone(&self.block_hash),
                        block_timestamp: ::core::clone::Clone::clone(
                            &self.block_timestamp,
                        ),
                        transaction_hash: ::core::clone::Clone::clone(
                            &self.transaction_hash,
                        ),
                        log_index: ::core::clone::Clone::clone(&self.log_index),
                        fid: ::core::clone::Clone::clone(&self.fid),
                        body: ::core::clone::Clone::clone(&self.body),
                    }
                }
            }
            #[allow(clippy::derive_partial_eq_without_eq)]
            #[automatically_derived]
            impl ::core::marker::StructuralPartialEq for OnChainEvent {}
            #[automatically_derived]
            #[allow(clippy::derive_partial_eq_without_eq)]
            impl ::core::cmp::PartialEq for OnChainEvent {
                #[inline]
                fn eq(&self, other: &OnChainEvent) -> bool {
                    self.r#type == other.r#type && self.chain_id == other.chain_id
                        && self.block_number == other.block_number
                        && self.block_hash == other.block_hash
                        && self.block_timestamp == other.block_timestamp
                        && self.transaction_hash == other.transaction_hash
                        && self.log_index == other.log_index && self.fid == other.fid
                        && self.body == other.body
                }
            }
            impl ::prost::Message for OnChainEvent {
                #[allow(unused_variables)]
                fn encode_raw<B>(&self, buf: &mut B)
                where
                    B: ::prost::bytes::BufMut,
                {
                    if self.r#type != OnChainEventType::default() as i32 {
                        ::prost::encoding::int32::encode(1u32, &self.r#type, buf);
                    }
                    if self.chain_id != 0u32 {
                        ::prost::encoding::uint32::encode(2u32, &self.chain_id, buf);
                    }
                    if self.block_number != 0u32 {
                        ::prost::encoding::uint32::encode(3u32, &self.block_number, buf);
                    }
                    if self.block_hash != b"" as &[u8] {
                        ::prost::encoding::bytes::encode(4u32, &self.block_hash, buf);
                    }
                    if self.block_timestamp != 0u64 {
                        ::prost::encoding::uint64::encode(
                            5u32,
                            &self.block_timestamp,
                            buf,
                        );
                    }
                    if self.transaction_hash != b"" as &[u8] {
                        ::prost::encoding::bytes::encode(
                            6u32,
                            &self.transaction_hash,
                            buf,
                        );
                    }
                    if self.log_index != 0u32 {
                        ::prost::encoding::uint32::encode(7u32, &self.log_index, buf);
                    }
                    if self.fid != 0u64 {
                        ::prost::encoding::uint64::encode(8u32, &self.fid, buf);
                    }
                    if let Some(ref oneof) = self.body {
                        oneof.encode(buf)
                    }
                }
                #[allow(unused_variables)]
                fn merge_field<B>(
                    &mut self,
                    tag: u32,
                    wire_type: ::prost::encoding::WireType,
                    buf: &mut B,
                    ctx: ::prost::encoding::DecodeContext,
                ) -> ::core::result::Result<(), ::prost::DecodeError>
                where
                    B: ::prost::bytes::Buf,
                {
                    const STRUCT_NAME: &'static str = "OnChainEvent";
                    match tag {
                        1u32 => {
                            let mut value = &mut self.r#type;
                            ::prost::encoding::int32::merge(wire_type, value, buf, ctx)
                                .map_err(|mut error| {
                                    error.push(STRUCT_NAME, "r#type");
                                    error
                                })
                        }
                        2u32 => {
                            let mut value = &mut self.chain_id;
                            ::prost::encoding::uint32::merge(wire_type, value, buf, ctx)
                                .map_err(|mut error| {
                                    error.push(STRUCT_NAME, "chain_id");
                                    error
                                })
                        }
                        3u32 => {
                            let mut value = &mut self.block_number;
                            ::prost::encoding::uint32::merge(wire_type, value, buf, ctx)
                                .map_err(|mut error| {
                                    error.push(STRUCT_NAME, "block_number");
                                    error
                                })
                        }
                        4u32 => {
                            let mut value = &mut self.block_hash;
                            ::prost::encoding::bytes::merge(wire_type, value, buf, ctx)
                                .map_err(|mut error| {
                                    error.push(STRUCT_NAME, "block_hash");
                                    error
                                })
                        }
                        5u32 => {
                            let mut value = &mut self.block_timestamp;
                            ::prost::encoding::uint64::merge(wire_type, value, buf, ctx)
                                .map_err(|mut error| {
                                    error.push(STRUCT_NAME, "block_timestamp");
                                    error
                                })
                        }
                        6u32 => {
                            let mut value = &mut self.transaction_hash;
                            ::prost::encoding::bytes::merge(wire_type, value, buf, ctx)
                                .map_err(|mut error| {
                                    error.push(STRUCT_NAME, "transaction_hash");
                                    error
                                })
                        }
                        7u32 => {
                            let mut value = &mut self.log_index;
                            ::prost::encoding::uint32::merge(wire_type, value, buf, ctx)
                                .map_err(|mut error| {
                                    error.push(STRUCT_NAME, "log_index");
                                    error
                                })
                        }
                        8u32 => {
                            let mut value = &mut self.fid;
                            ::prost::encoding::uint64::merge(wire_type, value, buf, ctx)
                                .map_err(|mut error| {
                                    error.push(STRUCT_NAME, "fid");
                                    error
                                })
                        }
                        9u32 | 10u32 | 11u32 | 12u32 => {
                            let mut value = &mut self.body;
                            on_chain_event::Body::merge(value, tag, wire_type, buf, ctx)
                                .map_err(|mut error| {
                                    error.push(STRUCT_NAME, "body");
                                    error
                                })
                        }
                        _ => ::prost::encoding::skip_field(wire_type, tag, buf, ctx),
                    }
                }
                #[inline]
                fn encoded_len(&self) -> usize {
                    0
                        + if self.r#type != OnChainEventType::default() as i32 {
                            ::prost::encoding::int32::encoded_len(1u32, &self.r#type)
                        } else {
                            0
                        }
                        + if self.chain_id != 0u32 {
                            ::prost::encoding::uint32::encoded_len(2u32, &self.chain_id)
                        } else {
                            0
                        }
                        + if self.block_number != 0u32 {
                            ::prost::encoding::uint32::encoded_len(
                                3u32,
                                &self.block_number,
                            )
                        } else {
                            0
                        }
                        + if self.block_hash != b"" as &[u8] {
                            ::prost::encoding::bytes::encoded_len(4u32, &self.block_hash)
                        } else {
                            0
                        }
                        + if self.block_timestamp != 0u64 {
                            ::prost::encoding::uint64::encoded_len(
                                5u32,
                                &self.block_timestamp,
                            )
                        } else {
                            0
                        }
                        + if self.transaction_hash != b"" as &[u8] {
                            ::prost::encoding::bytes::encoded_len(
                                6u32,
                                &self.transaction_hash,
                            )
                        } else {
                            0
                        }
                        + if self.log_index != 0u32 {
                            ::prost::encoding::uint32::encoded_len(7u32, &self.log_index)
                        } else {
                            0
                        }
                        + if self.fid != 0u64 {
                            ::prost::encoding::uint64::encoded_len(8u32, &self.fid)
                        } else {
                            0
                        }
                        + self.body.as_ref().map_or(0, on_chain_event::Body::encoded_len)
                }
                fn clear(&mut self) {
                    self.r#type = OnChainEventType::default() as i32;
                    self.chain_id = 0u32;
                    self.block_number = 0u32;
                    self.block_hash.clear();
                    self.block_timestamp = 0u64;
                    self.transaction_hash.clear();
                    self.log_index = 0u32;
                    self.fid = 0u64;
                    self.body = ::core::option::Option::None;
                }
            }
            impl ::core::default::Default for OnChainEvent {
                fn default() -> Self {
                    OnChainEvent {
                        r#type: OnChainEventType::default() as i32,
                        chain_id: 0u32,
                        block_number: 0u32,
                        block_hash: ::core::default::Default::default(),
                        block_timestamp: 0u64,
                        transaction_hash: ::core::default::Default::default(),
                        log_index: 0u32,
                        fid: 0u64,
                        body: ::core::default::Default::default(),
                    }
                }
            }
            impl ::core::fmt::Debug for OnChainEvent {
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    let mut builder = f.debug_struct("OnChainEvent");
                    let builder = {
                        let wrapper = {
                            struct ScalarWrapper<'a>(&'a i32);
                            impl<'a> ::core::fmt::Debug for ScalarWrapper<'a> {
                                fn fmt(
                                    &self,
                                    f: &mut ::core::fmt::Formatter,
                                ) -> ::core::fmt::Result {
                                    match OnChainEventType::from_i32(*self.0) {
                                        None => ::core::fmt::Debug::fmt(&self.0, f),
                                        Some(en) => ::core::fmt::Debug::fmt(&en, f),
                                    }
                                }
                            }
                            ScalarWrapper(&self.r#type)
                        };
                        builder.field("r#type", &wrapper)
                    };
                    let builder = {
                        let wrapper = {
                            fn ScalarWrapper<T>(v: T) -> T {
                                v
                            }
                            ScalarWrapper(&self.chain_id)
                        };
                        builder.field("chain_id", &wrapper)
                    };
                    let builder = {
                        let wrapper = {
                            fn ScalarWrapper<T>(v: T) -> T {
                                v
                            }
                            ScalarWrapper(&self.block_number)
                        };
                        builder.field("block_number", &wrapper)
                    };
                    let builder = {
                        let wrapper = {
                            fn ScalarWrapper<T>(v: T) -> T {
                                v
                            }
                            ScalarWrapper(&self.block_hash)
                        };
                        builder.field("block_hash", &wrapper)
                    };
                    let builder = {
                        let wrapper = {
                            fn ScalarWrapper<T>(v: T) -> T {
                                v
                            }
                            ScalarWrapper(&self.block_timestamp)
                        };
                        builder.field("block_timestamp", &wrapper)
                    };
                    let builder = {
                        let wrapper = {
                            fn ScalarWrapper<T>(v: T) -> T {
                                v
                            }
                            ScalarWrapper(&self.transaction_hash)
                        };
                        builder.field("transaction_hash", &wrapper)
                    };
                    let builder = {
                        let wrapper = {
                            fn ScalarWrapper<T>(v: T) -> T {
                                v
                            }
                            ScalarWrapper(&self.log_index)
                        };
                        builder.field("log_index", &wrapper)
                    };
                    let builder = {
                        let wrapper = {
                            fn ScalarWrapper<T>(v: T) -> T {
                                v
                            }
                            ScalarWrapper(&self.fid)
                        };
                        builder.field("fid", &wrapper)
                    };
                    let builder = {
                        let wrapper = &self.body;
                        builder.field("body", &wrapper)
                    };
                    builder.finish()
                }
            }
            #[allow(dead_code)]
            impl OnChainEvent {
                ///Returns the enum value of `type`, or the default if the field is set to an invalid enum value.
                pub fn r#type(&self) -> OnChainEventType {
                    OnChainEventType::from_i32(self.r#type)
                        .unwrap_or(OnChainEventType::default())
                }
                ///Sets `type` to the provided enum value.
                pub fn set_type(&mut self, value: OnChainEventType) {
                    self.r#type = value as i32;
                }
            }
            /// Nested message and enum types in `OnChainEvent`.
            pub mod on_chain_event {
                #[allow(clippy::derive_partial_eq_without_eq)]
                pub enum Body {
                    #[prost(message, tag = "9")]
                    SignerEventBody(super::SignerEventBody),
                    #[prost(message, tag = "10")]
                    SignerMigratedEventBody(super::SignerMigratedEventBody),
                    #[prost(message, tag = "11")]
                    IdRegisterEventBody(super::IdRegisterEventBody),
                    #[prost(message, tag = "12")]
                    StorageRentEventBody(super::StorageRentEventBody),
                }
                #[automatically_derived]
                #[allow(clippy::derive_partial_eq_without_eq)]
                impl ::core::clone::Clone for Body {
                    #[inline]
                    fn clone(&self) -> Body {
                        match self {
                            Body::SignerEventBody(__self_0) => {
                                Body::SignerEventBody(::core::clone::Clone::clone(__self_0))
                            }
                            Body::SignerMigratedEventBody(__self_0) => {
                                Body::SignerMigratedEventBody(
                                    ::core::clone::Clone::clone(__self_0),
                                )
                            }
                            Body::IdRegisterEventBody(__self_0) => {
                                Body::IdRegisterEventBody(
                                    ::core::clone::Clone::clone(__self_0),
                                )
                            }
                            Body::StorageRentEventBody(__self_0) => {
                                Body::StorageRentEventBody(
                                    ::core::clone::Clone::clone(__self_0),
                                )
                            }
                        }
                    }
                }
                #[allow(clippy::derive_partial_eq_without_eq)]
                #[automatically_derived]
                impl ::core::marker::StructuralPartialEq for Body {}
                #[automatically_derived]
                #[allow(clippy::derive_partial_eq_without_eq)]
                impl ::core::cmp::PartialEq for Body {
                    #[inline]
                    fn eq(&self, other: &Body) -> bool {
                        let __self_tag = ::core::intrinsics::discriminant_value(self);
                        let __arg1_tag = ::core::intrinsics::discriminant_value(other);
                        __self_tag == __arg1_tag
                            && match (self, other) {
                                (
                                    Body::SignerEventBody(__self_0),
                                    Body::SignerEventBody(__arg1_0),
                                ) => *__self_0 == *__arg1_0,
                                (
                                    Body::SignerMigratedEventBody(__self_0),
                                    Body::SignerMigratedEventBody(__arg1_0),
                                ) => *__self_0 == *__arg1_0,
                                (
                                    Body::IdRegisterEventBody(__self_0),
                                    Body::IdRegisterEventBody(__arg1_0),
                                ) => *__self_0 == *__arg1_0,
                                (
                                    Body::StorageRentEventBody(__self_0),
                                    Body::StorageRentEventBody(__arg1_0),
                                ) => *__self_0 == *__arg1_0,
                                _ => unsafe { ::core::intrinsics::unreachable() }
                            }
                    }
                }
                impl Body {
                    /// Encodes the message to a buffer.
                    pub fn encode<B>(&self, buf: &mut B)
                    where
                        B: ::prost::bytes::BufMut,
                    {
                        match *self {
                            Body::SignerEventBody(ref value) => {
                                ::prost::encoding::message::encode(9u32, &*value, buf);
                            }
                            Body::SignerMigratedEventBody(ref value) => {
                                ::prost::encoding::message::encode(10u32, &*value, buf);
                            }
                            Body::IdRegisterEventBody(ref value) => {
                                ::prost::encoding::message::encode(11u32, &*value, buf);
                            }
                            Body::StorageRentEventBody(ref value) => {
                                ::prost::encoding::message::encode(12u32, &*value, buf);
                            }
                        }
                    }
                    /// Decodes an instance of the message from a buffer, and merges it into self.
                    pub fn merge<B>(
                        field: &mut ::core::option::Option<Body>,
                        tag: u32,
                        wire_type: ::prost::encoding::WireType,
                        buf: &mut B,
                        ctx: ::prost::encoding::DecodeContext,
                    ) -> ::core::result::Result<(), ::prost::DecodeError>
                    where
                        B: ::prost::bytes::Buf,
                    {
                        match tag {
                            9u32 => {
                                match field {
                                    ::core::option::Option::Some(
                                        Body::SignerEventBody(ref mut value),
                                    ) => {
                                        ::prost::encoding::message::merge(
                                            wire_type,
                                            value,
                                            buf,
                                            ctx,
                                        )
                                    }
                                    _ => {
                                        let mut owned_value = ::core::default::Default::default();
                                        let value = &mut owned_value;
                                        ::prost::encoding::message::merge(
                                                wire_type,
                                                value,
                                                buf,
                                                ctx,
                                            )
                                            .map(|_| {
                                                *field = ::core::option::Option::Some(
                                                    Body::SignerEventBody(owned_value),
                                                );
                                            })
                                    }
                                }
                            }
                            10u32 => {
                                match field {
                                    ::core::option::Option::Some(
                                        Body::SignerMigratedEventBody(ref mut value),
                                    ) => {
                                        ::prost::encoding::message::merge(
                                            wire_type,
                                            value,
                                            buf,
                                            ctx,
                                        )
                                    }
                                    _ => {
                                        let mut owned_value = ::core::default::Default::default();
                                        let value = &mut owned_value;
                                        ::prost::encoding::message::merge(
                                                wire_type,
                                                value,
                                                buf,
                                                ctx,
                                            )
                                            .map(|_| {
                                                *field = ::core::option::Option::Some(
                                                    Body::SignerMigratedEventBody(owned_value),
                                                );
                                            })
                                    }
                                }
                            }
                            11u32 => {
                                match field {
                                    ::core::option::Option::Some(
                                        Body::IdRegisterEventBody(ref mut value),
                                    ) => {
                                        ::prost::encoding::message::merge(
                                            wire_type,
                                            value,
                                            buf,
                                            ctx,
                                        )
                                    }
                                    _ => {
                                        let mut owned_value = ::core::default::Default::default();
                                        let value = &mut owned_value;
                                        ::prost::encoding::message::merge(
                                                wire_type,
                                                value,
                                                buf,
                                                ctx,
                                            )
                                            .map(|_| {
                                                *field = ::core::option::Option::Some(
                                                    Body::IdRegisterEventBody(owned_value),
                                                );
                                            })
                                    }
                                }
                            }
                            12u32 => {
                                match field {
                                    ::core::option::Option::Some(
                                        Body::StorageRentEventBody(ref mut value),
                                    ) => {
                                        ::prost::encoding::message::merge(
                                            wire_type,
                                            value,
                                            buf,
                                            ctx,
                                        )
                                    }
                                    _ => {
                                        let mut owned_value = ::core::default::Default::default();
                                        let value = &mut owned_value;
                                        ::prost::encoding::message::merge(
                                                wire_type,
                                                value,
                                                buf,
                                                ctx,
                                            )
                                            .map(|_| {
                                                *field = ::core::option::Option::Some(
                                                    Body::StorageRentEventBody(owned_value),
                                                );
                                            })
                                    }
                                }
                            }
                            _ => {
                                ::core::panicking::panic_fmt(
                                    format_args!(
                                        "internal error: entered unreachable code: {0}",
                                        format_args!("invalid Body tag: {0}", tag),
                                    ),
                                );
                            }
                        }
                    }
                    /// Returns the encoded length of the message without a length delimiter.
                    #[inline]
                    pub fn encoded_len(&self) -> usize {
                        match *self {
                            Body::SignerEventBody(ref value) => {
                                ::prost::encoding::message::encoded_len(9u32, &*value)
                            }
                            Body::SignerMigratedEventBody(ref value) => {
                                ::prost::encoding::message::encoded_len(10u32, &*value)
                            }
                            Body::IdRegisterEventBody(ref value) => {
                                ::prost::encoding::message::encoded_len(11u32, &*value)
                            }
                            Body::StorageRentEventBody(ref value) => {
                                ::prost::encoding::message::encoded_len(12u32, &*value)
                            }
                        }
                    }
                }
                impl ::core::fmt::Debug for Body {
                    fn fmt(
                        &self,
                        f: &mut ::core::fmt::Formatter,
                    ) -> ::core::fmt::Result {
                        match *self {
                            Body::SignerEventBody(ref value) => {
                                let wrapper = &*value;
                                f.debug_tuple("SignerEventBody").field(&wrapper).finish()
                            }
                            Body::SignerMigratedEventBody(ref value) => {
                                let wrapper = &*value;
                                f.debug_tuple("SignerMigratedEventBody")
                                    .field(&wrapper)
                                    .finish()
                            }
                            Body::IdRegisterEventBody(ref value) => {
                                let wrapper = &*value;
                                f.debug_tuple("IdRegisterEventBody")
                                    .field(&wrapper)
                                    .finish()
                            }
                            Body::StorageRentEventBody(ref value) => {
                                let wrapper = &*value;
                                f.debug_tuple("StorageRentEventBody")
                                    .field(&wrapper)
                                    .finish()
                            }
                        }
                    }
                }
            }
            #[allow(clippy::derive_partial_eq_without_eq)]
            pub struct SignerEventBody {
                #[prost(bytes = "vec", tag = "1")]
                pub key: ::prost::alloc::vec::Vec<u8>,
                #[prost(uint32, tag = "2")]
                pub scheme: u32,
                #[prost(enumeration = "SignerEventType", tag = "3")]
                pub event_type: i32,
            }
            #[automatically_derived]
            #[allow(clippy::derive_partial_eq_without_eq)]
            impl ::core::clone::Clone for SignerEventBody {
                #[inline]
                fn clone(&self) -> SignerEventBody {
                    SignerEventBody {
                        key: ::core::clone::Clone::clone(&self.key),
                        scheme: ::core::clone::Clone::clone(&self.scheme),
                        event_type: ::core::clone::Clone::clone(&self.event_type),
                    }
                }
            }
            #[allow(clippy::derive_partial_eq_without_eq)]
            #[automatically_derived]
            impl ::core::marker::StructuralPartialEq for SignerEventBody {}
            #[automatically_derived]
            #[allow(clippy::derive_partial_eq_without_eq)]
            impl ::core::cmp::PartialEq for SignerEventBody {
                #[inline]
                fn eq(&self, other: &SignerEventBody) -> bool {
                    self.key == other.key && self.scheme == other.scheme
                        && self.event_type == other.event_type
                }
            }
            impl ::prost::Message for SignerEventBody {
                #[allow(unused_variables)]
                fn encode_raw<B>(&self, buf: &mut B)
                where
                    B: ::prost::bytes::BufMut,
                {
                    if self.key != b"" as &[u8] {
                        ::prost::encoding::bytes::encode(1u32, &self.key, buf);
                    }
                    if self.scheme != 0u32 {
                        ::prost::encoding::uint32::encode(2u32, &self.scheme, buf);
                    }
                    if self.event_type != SignerEventType::default() as i32 {
                        ::prost::encoding::int32::encode(3u32, &self.event_type, buf);
                    }
                }
                #[allow(unused_variables)]
                fn merge_field<B>(
                    &mut self,
                    tag: u32,
                    wire_type: ::prost::encoding::WireType,
                    buf: &mut B,
                    ctx: ::prost::encoding::DecodeContext,
                ) -> ::core::result::Result<(), ::prost::DecodeError>
                where
                    B: ::prost::bytes::Buf,
                {
                    const STRUCT_NAME: &'static str = "SignerEventBody";
                    match tag {
                        1u32 => {
                            let mut value = &mut self.key;
                            ::prost::encoding::bytes::merge(wire_type, value, buf, ctx)
                                .map_err(|mut error| {
                                    error.push(STRUCT_NAME, "key");
                                    error
                                })
                        }
                        2u32 => {
                            let mut value = &mut self.scheme;
                            ::prost::encoding::uint32::merge(wire_type, value, buf, ctx)
                                .map_err(|mut error| {
                                    error.push(STRUCT_NAME, "scheme");
                                    error
                                })
                        }
                        3u32 => {
                            let mut value = &mut self.event_type;
                            ::prost::encoding::int32::merge(wire_type, value, buf, ctx)
                                .map_err(|mut error| {
                                    error.push(STRUCT_NAME, "event_type");
                                    error
                                })
                        }
                        _ => ::prost::encoding::skip_field(wire_type, tag, buf, ctx),
                    }
                }
                #[inline]
                fn encoded_len(&self) -> usize {
                    0
                        + if self.key != b"" as &[u8] {
                            ::prost::encoding::bytes::encoded_len(1u32, &self.key)
                        } else {
                            0
                        }
                        + if self.scheme != 0u32 {
                            ::prost::encoding::uint32::encoded_len(2u32, &self.scheme)
                        } else {
                            0
                        }
                        + if self.event_type != SignerEventType::default() as i32 {
                            ::prost::encoding::int32::encoded_len(3u32, &self.event_type)
                        } else {
                            0
                        }
                }
                fn clear(&mut self) {
                    self.key.clear();
                    self.scheme = 0u32;
                    self.event_type = SignerEventType::default() as i32;
                }
            }
            impl ::core::default::Default for SignerEventBody {
                fn default() -> Self {
                    SignerEventBody {
                        key: ::core::default::Default::default(),
                        scheme: 0u32,
                        event_type: SignerEventType::default() as i32,
                    }
                }
            }
            impl ::core::fmt::Debug for SignerEventBody {
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    let mut builder = f.debug_struct("SignerEventBody");
                    let builder = {
                        let wrapper = {
                            fn ScalarWrapper<T>(v: T) -> T {
                                v
                            }
                            ScalarWrapper(&self.key)
                        };
                        builder.field("key", &wrapper)
                    };
                    let builder = {
                        let wrapper = {
                            fn ScalarWrapper<T>(v: T) -> T {
                                v
                            }
                            ScalarWrapper(&self.scheme)
                        };
                        builder.field("scheme", &wrapper)
                    };
                    let builder = {
                        let wrapper = {
                            struct ScalarWrapper<'a>(&'a i32);
                            impl<'a> ::core::fmt::Debug for ScalarWrapper<'a> {
                                fn fmt(
                                    &self,
                                    f: &mut ::core::fmt::Formatter,
                                ) -> ::core::fmt::Result {
                                    match SignerEventType::from_i32(*self.0) {
                                        None => ::core::fmt::Debug::fmt(&self.0, f),
                                        Some(en) => ::core::fmt::Debug::fmt(&en, f),
                                    }
                                }
                            }
                            ScalarWrapper(&self.event_type)
                        };
                        builder.field("event_type", &wrapper)
                    };
                    builder.finish()
                }
            }
            #[allow(dead_code)]
            impl SignerEventBody {
                ///Returns the enum value of `event_type`, or the default if the field is set to an invalid enum value.
                pub fn event_type(&self) -> SignerEventType {
                    SignerEventType::from_i32(self.event_type)
                        .unwrap_or(SignerEventType::default())
                }
                ///Sets `event_type` to the provided enum value.
                pub fn set_event_type(&mut self, value: SignerEventType) {
                    self.event_type = value as i32;
                }
            }
            #[allow(clippy::derive_partial_eq_without_eq)]
            pub struct SignerMigratedEventBody {
                #[prost(uint32, tag = "1")]
                pub migrated_at: u32,
            }
            #[automatically_derived]
            #[allow(clippy::derive_partial_eq_without_eq)]
            impl ::core::clone::Clone for SignerMigratedEventBody {
                #[inline]
                fn clone(&self) -> SignerMigratedEventBody {
                    SignerMigratedEventBody {
                        migrated_at: ::core::clone::Clone::clone(&self.migrated_at),
                    }
                }
            }
            #[allow(clippy::derive_partial_eq_without_eq)]
            #[automatically_derived]
            impl ::core::marker::StructuralPartialEq for SignerMigratedEventBody {}
            #[automatically_derived]
            #[allow(clippy::derive_partial_eq_without_eq)]
            impl ::core::cmp::PartialEq for SignerMigratedEventBody {
                #[inline]
                fn eq(&self, other: &SignerMigratedEventBody) -> bool {
                    self.migrated_at == other.migrated_at
                }
            }
            impl ::prost::Message for SignerMigratedEventBody {
                #[allow(unused_variables)]
                fn encode_raw<B>(&self, buf: &mut B)
                where
                    B: ::prost::bytes::BufMut,
                {
                    if self.migrated_at != 0u32 {
                        ::prost::encoding::uint32::encode(1u32, &self.migrated_at, buf);
                    }
                }
                #[allow(unused_variables)]
                fn merge_field<B>(
                    &mut self,
                    tag: u32,
                    wire_type: ::prost::encoding::WireType,
                    buf: &mut B,
                    ctx: ::prost::encoding::DecodeContext,
                ) -> ::core::result::Result<(), ::prost::DecodeError>
                where
                    B: ::prost::bytes::Buf,
                {
                    const STRUCT_NAME: &'static str = "SignerMigratedEventBody";
                    match tag {
                        1u32 => {
                            let mut value = &mut self.migrated_at;
                            ::prost::encoding::uint32::merge(wire_type, value, buf, ctx)
                                .map_err(|mut error| {
                                    error.push(STRUCT_NAME, "migrated_at");
                                    error
                                })
                        }
                        _ => ::prost::encoding::skip_field(wire_type, tag, buf, ctx),
                    }
                }
                #[inline]
                fn encoded_len(&self) -> usize {
                    0
                        + if self.migrated_at != 0u32 {
                            ::prost::encoding::uint32::encoded_len(
                                1u32,
                                &self.migrated_at,
                            )
                        } else {
                            0
                        }
                }
                fn clear(&mut self) {
                    self.migrated_at = 0u32;
                }
            }
            impl ::core::default::Default for SignerMigratedEventBody {
                fn default() -> Self {
                    SignerMigratedEventBody {
                        migrated_at: 0u32,
                    }
                }
            }
            impl ::core::fmt::Debug for SignerMigratedEventBody {
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    let mut builder = f.debug_struct("SignerMigratedEventBody");
                    let builder = {
                        let wrapper = {
                            fn ScalarWrapper<T>(v: T) -> T {
                                v
                            }
                            ScalarWrapper(&self.migrated_at)
                        };
                        builder.field("migrated_at", &wrapper)
                    };
                    builder.finish()
                }
            }
            #[allow(clippy::derive_partial_eq_without_eq)]
            pub struct IdRegisterEventBody {
                #[prost(bytes = "vec", tag = "1")]
                pub to: ::prost::alloc::vec::Vec<u8>,
                #[prost(enumeration = "IdRegisterEventType", tag = "2")]
                pub event_type: i32,
                #[prost(bytes = "vec", tag = "3")]
                pub from: ::prost::alloc::vec::Vec<u8>,
            }
            #[automatically_derived]
            #[allow(clippy::derive_partial_eq_without_eq)]
            impl ::core::clone::Clone for IdRegisterEventBody {
                #[inline]
                fn clone(&self) -> IdRegisterEventBody {
                    IdRegisterEventBody {
                        to: ::core::clone::Clone::clone(&self.to),
                        event_type: ::core::clone::Clone::clone(&self.event_type),
                        from: ::core::clone::Clone::clone(&self.from),
                    }
                }
            }
            #[allow(clippy::derive_partial_eq_without_eq)]
            #[automatically_derived]
            impl ::core::marker::StructuralPartialEq for IdRegisterEventBody {}
            #[automatically_derived]
            #[allow(clippy::derive_partial_eq_without_eq)]
            impl ::core::cmp::PartialEq for IdRegisterEventBody {
                #[inline]
                fn eq(&self, other: &IdRegisterEventBody) -> bool {
                    self.to == other.to && self.event_type == other.event_type
                        && self.from == other.from
                }
            }
            impl ::prost::Message for IdRegisterEventBody {
                #[allow(unused_variables)]
                fn encode_raw<B>(&self, buf: &mut B)
                where
                    B: ::prost::bytes::BufMut,
                {
                    if self.to != b"" as &[u8] {
                        ::prost::encoding::bytes::encode(1u32, &self.to, buf);
                    }
                    if self.event_type != IdRegisterEventType::default() as i32 {
                        ::prost::encoding::int32::encode(2u32, &self.event_type, buf);
                    }
                    if self.from != b"" as &[u8] {
                        ::prost::encoding::bytes::encode(3u32, &self.from, buf);
                    }
                }
                #[allow(unused_variables)]
                fn merge_field<B>(
                    &mut self,
                    tag: u32,
                    wire_type: ::prost::encoding::WireType,
                    buf: &mut B,
                    ctx: ::prost::encoding::DecodeContext,
                ) -> ::core::result::Result<(), ::prost::DecodeError>
                where
                    B: ::prost::bytes::Buf,
                {
                    const STRUCT_NAME: &'static str = "IdRegisterEventBody";
                    match tag {
                        1u32 => {
                            let mut value = &mut self.to;
                            ::prost::encoding::bytes::merge(wire_type, value, buf, ctx)
                                .map_err(|mut error| {
                                    error.push(STRUCT_NAME, "to");
                                    error
                                })
                        }
                        2u32 => {
                            let mut value = &mut self.event_type;
                            ::prost::encoding::int32::merge(wire_type, value, buf, ctx)
                                .map_err(|mut error| {
                                    error.push(STRUCT_NAME, "event_type");
                                    error
                                })
                        }
                        3u32 => {
                            let mut value = &mut self.from;
                            ::prost::encoding::bytes::merge(wire_type, value, buf, ctx)
                                .map_err(|mut error| {
                                    error.push(STRUCT_NAME, "from");
                                    error
                                })
                        }
                        _ => ::prost::encoding::skip_field(wire_type, tag, buf, ctx),
                    }
                }
                #[inline]
                fn encoded_len(&self) -> usize {
                    0
                        + if self.to != b"" as &[u8] {
                            ::prost::encoding::bytes::encoded_len(1u32, &self.to)
                        } else {
                            0
                        }
                        + if self.event_type != IdRegisterEventType::default() as i32 {
                            ::prost::encoding::int32::encoded_len(2u32, &self.event_type)
                        } else {
                            0
                        }
                        + if self.from != b"" as &[u8] {
                            ::prost::encoding::bytes::encoded_len(3u32, &self.from)
                        } else {
                            0
                        }
                }
                fn clear(&mut self) {
                    self.to.clear();
                    self.event_type = IdRegisterEventType::default() as i32;
                    self.from.clear();
                }
            }
            impl ::core::default::Default for IdRegisterEventBody {
                fn default() -> Self {
                    IdRegisterEventBody {
                        to: ::core::default::Default::default(),
                        event_type: IdRegisterEventType::default() as i32,
                        from: ::core::default::Default::default(),
                    }
                }
            }
            impl ::core::fmt::Debug for IdRegisterEventBody {
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    let mut builder = f.debug_struct("IdRegisterEventBody");
                    let builder = {
                        let wrapper = {
                            fn ScalarWrapper<T>(v: T) -> T {
                                v
                            }
                            ScalarWrapper(&self.to)
                        };
                        builder.field("to", &wrapper)
                    };
                    let builder = {
                        let wrapper = {
                            struct ScalarWrapper<'a>(&'a i32);
                            impl<'a> ::core::fmt::Debug for ScalarWrapper<'a> {
                                fn fmt(
                                    &self,
                                    f: &mut ::core::fmt::Formatter,
                                ) -> ::core::fmt::Result {
                                    match IdRegisterEventType::from_i32(*self.0) {
                                        None => ::core::fmt::Debug::fmt(&self.0, f),
                                        Some(en) => ::core::fmt::Debug::fmt(&en, f),
                                    }
                                }
                            }
                            ScalarWrapper(&self.event_type)
                        };
                        builder.field("event_type", &wrapper)
                    };
                    let builder = {
                        let wrapper = {
                            fn ScalarWrapper<T>(v: T) -> T {
                                v
                            }
                            ScalarWrapper(&self.from)
                        };
                        builder.field("from", &wrapper)
                    };
                    builder.finish()
                }
            }
            #[allow(dead_code)]
            impl IdRegisterEventBody {
                ///Returns the enum value of `event_type`, or the default if the field is set to an invalid enum value.
                pub fn event_type(&self) -> IdRegisterEventType {
                    IdRegisterEventType::from_i32(self.event_type)
                        .unwrap_or(IdRegisterEventType::default())
                }
                ///Sets `event_type` to the provided enum value.
                pub fn set_event_type(&mut self, value: IdRegisterEventType) {
                    self.event_type = value as i32;
                }
            }
            #[allow(clippy::derive_partial_eq_without_eq)]
            pub struct StorageRentEventBody {
                #[prost(bytes = "vec", tag = "1")]
                pub payer: ::prost::alloc::vec::Vec<u8>,
                #[prost(uint32, tag = "2")]
                pub units: u32,
                #[prost(uint32, tag = "3")]
                pub expiry: u32,
            }
            #[automatically_derived]
            #[allow(clippy::derive_partial_eq_without_eq)]
            impl ::core::clone::Clone for StorageRentEventBody {
                #[inline]
                fn clone(&self) -> StorageRentEventBody {
                    StorageRentEventBody {
                        payer: ::core::clone::Clone::clone(&self.payer),
                        units: ::core::clone::Clone::clone(&self.units),
                        expiry: ::core::clone::Clone::clone(&self.expiry),
                    }
                }
            }
            #[allow(clippy::derive_partial_eq_without_eq)]
            #[automatically_derived]
            impl ::core::marker::StructuralPartialEq for StorageRentEventBody {}
            #[automatically_derived]
            #[allow(clippy::derive_partial_eq_without_eq)]
            impl ::core::cmp::PartialEq for StorageRentEventBody {
                #[inline]
                fn eq(&self, other: &StorageRentEventBody) -> bool {
                    self.payer == other.payer && self.units == other.units
                        && self.expiry == other.expiry
                }
            }
            impl ::prost::Message for StorageRentEventBody {
                #[allow(unused_variables)]
                fn encode_raw<B>(&self, buf: &mut B)
                where
                    B: ::prost::bytes::BufMut,
                {
                    if self.payer != b"" as &[u8] {
                        ::prost::encoding::bytes::encode(1u32, &self.payer, buf);
                    }
                    if self.units != 0u32 {
                        ::prost::encoding::uint32::encode(2u32, &self.units, buf);
                    }
                    if self.expiry != 0u32 {
                        ::prost::encoding::uint32::encode(3u32, &self.expiry, buf);
                    }
                }
                #[allow(unused_variables)]
                fn merge_field<B>(
                    &mut self,
                    tag: u32,
                    wire_type: ::prost::encoding::WireType,
                    buf: &mut B,
                    ctx: ::prost::encoding::DecodeContext,
                ) -> ::core::result::Result<(), ::prost::DecodeError>
                where
                    B: ::prost::bytes::Buf,
                {
                    const STRUCT_NAME: &'static str = "StorageRentEventBody";
                    match tag {
                        1u32 => {
                            let mut value = &mut self.payer;
                            ::prost::encoding::bytes::merge(wire_type, value, buf, ctx)
                                .map_err(|mut error| {
                                    error.push(STRUCT_NAME, "payer");
                                    error
                                })
                        }
                        2u32 => {
                            let mut value = &mut self.units;
                            ::prost::encoding::uint32::merge(wire_type, value, buf, ctx)
                                .map_err(|mut error| {
                                    error.push(STRUCT_NAME, "units");
                                    error
                                })
                        }
                        3u32 => {
                            let mut value = &mut self.expiry;
                            ::prost::encoding::uint32::merge(wire_type, value, buf, ctx)
                                .map_err(|mut error| {
                                    error.push(STRUCT_NAME, "expiry");
                                    error
                                })
                        }
                        _ => ::prost::encoding::skip_field(wire_type, tag, buf, ctx),
                    }
                }
                #[inline]
                fn encoded_len(&self) -> usize {
                    0
                        + if self.payer != b"" as &[u8] {
                            ::prost::encoding::bytes::encoded_len(1u32, &self.payer)
                        } else {
                            0
                        }
                        + if self.units != 0u32 {
                            ::prost::encoding::uint32::encoded_len(2u32, &self.units)
                        } else {
                            0
                        }
                        + if self.expiry != 0u32 {
                            ::prost::encoding::uint32::encoded_len(3u32, &self.expiry)
                        } else {
                            0
                        }
                }
                fn clear(&mut self) {
                    self.payer.clear();
                    self.units = 0u32;
                    self.expiry = 0u32;
                }
            }
            impl ::core::default::Default for StorageRentEventBody {
                fn default() -> Self {
                    StorageRentEventBody {
                        payer: ::core::default::Default::default(),
                        units: 0u32,
                        expiry: 0u32,
                    }
                }
            }
            impl ::core::fmt::Debug for StorageRentEventBody {
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    let mut builder = f.debug_struct("StorageRentEventBody");
                    let builder = {
                        let wrapper = {
                            fn ScalarWrapper<T>(v: T) -> T {
                                v
                            }
                            ScalarWrapper(&self.payer)
                        };
                        builder.field("payer", &wrapper)
                    };
                    let builder = {
                        let wrapper = {
                            fn ScalarWrapper<T>(v: T) -> T {
                                v
                            }
                            ScalarWrapper(&self.units)
                        };
                        builder.field("units", &wrapper)
                    };
                    let builder = {
                        let wrapper = {
                            fn ScalarWrapper<T>(v: T) -> T {
                                v
                            }
                            ScalarWrapper(&self.expiry)
                        };
                        builder.field("expiry", &wrapper)
                    };
                    builder.finish()
                }
            }
            #[repr(i32)]
            pub enum OnChainEventType {
                EventTypeNone = 0,
                EventTypeSigner = 1,
                EventTypeSignerMigrated = 2,
                EventTypeIdRegister = 3,
                EventTypeStorageRent = 4,
            }
            #[automatically_derived]
            impl ::core::clone::Clone for OnChainEventType {
                #[inline]
                fn clone(&self) -> OnChainEventType {
                    *self
                }
            }
            #[automatically_derived]
            impl ::core::marker::Copy for OnChainEventType {}
            #[automatically_derived]
            impl ::core::fmt::Debug for OnChainEventType {
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    ::core::fmt::Formatter::write_str(
                        f,
                        match self {
                            OnChainEventType::EventTypeNone => "EventTypeNone",
                            OnChainEventType::EventTypeSigner => "EventTypeSigner",
                            OnChainEventType::EventTypeSignerMigrated => {
                                "EventTypeSignerMigrated"
                            }
                            OnChainEventType::EventTypeIdRegister => {
                                "EventTypeIdRegister"
                            }
                            OnChainEventType::EventTypeStorageRent => {
                                "EventTypeStorageRent"
                            }
                        },
                    )
                }
            }
            #[automatically_derived]
            impl ::core::marker::StructuralPartialEq for OnChainEventType {}
            #[automatically_derived]
            impl ::core::cmp::PartialEq for OnChainEventType {
                #[inline]
                fn eq(&self, other: &OnChainEventType) -> bool {
                    let __self_tag = ::core::intrinsics::discriminant_value(self);
                    let __arg1_tag = ::core::intrinsics::discriminant_value(other);
                    __self_tag == __arg1_tag
                }
            }
            #[automatically_derived]
            impl ::core::marker::StructuralEq for OnChainEventType {}
            #[automatically_derived]
            impl ::core::cmp::Eq for OnChainEventType {
                #[inline]
                #[doc(hidden)]
                #[no_coverage]
                fn assert_receiver_is_total_eq(&self) -> () {}
            }
            #[automatically_derived]
            impl ::core::hash::Hash for OnChainEventType {
                fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {
                    let __self_tag = ::core::intrinsics::discriminant_value(self);
                    ::core::hash::Hash::hash(&__self_tag, state)
                }
            }
            #[automatically_derived]
            impl ::core::cmp::PartialOrd for OnChainEventType {
                #[inline]
                fn partial_cmp(
                    &self,
                    other: &OnChainEventType,
                ) -> ::core::option::Option<::core::cmp::Ordering> {
                    let __self_tag = ::core::intrinsics::discriminant_value(self);
                    let __arg1_tag = ::core::intrinsics::discriminant_value(other);
                    ::core::cmp::PartialOrd::partial_cmp(&__self_tag, &__arg1_tag)
                }
            }
            #[automatically_derived]
            impl ::core::cmp::Ord for OnChainEventType {
                #[inline]
                fn cmp(&self, other: &OnChainEventType) -> ::core::cmp::Ordering {
                    let __self_tag = ::core::intrinsics::discriminant_value(self);
                    let __arg1_tag = ::core::intrinsics::discriminant_value(other);
                    ::core::cmp::Ord::cmp(&__self_tag, &__arg1_tag)
                }
            }
            impl OnChainEventType {
                ///Returns `true` if `value` is a variant of `OnChainEventType`.
                pub fn is_valid(value: i32) -> bool {
                    match value {
                        0 => true,
                        1 => true,
                        2 => true,
                        3 => true,
                        4 => true,
                        _ => false,
                    }
                }
                ///Converts an `i32` to a `OnChainEventType`, or `None` if `value` is not a valid variant.
                pub fn from_i32(value: i32) -> ::core::option::Option<OnChainEventType> {
                    match value {
                        0 => {
                            ::core::option::Option::Some(OnChainEventType::EventTypeNone)
                        }
                        1 => {
                            ::core::option::Option::Some(
                                OnChainEventType::EventTypeSigner,
                            )
                        }
                        2 => {
                            ::core::option::Option::Some(
                                OnChainEventType::EventTypeSignerMigrated,
                            )
                        }
                        3 => {
                            ::core::option::Option::Some(
                                OnChainEventType::EventTypeIdRegister,
                            )
                        }
                        4 => {
                            ::core::option::Option::Some(
                                OnChainEventType::EventTypeStorageRent,
                            )
                        }
                        _ => ::core::option::Option::None,
                    }
                }
            }
            impl ::core::default::Default for OnChainEventType {
                fn default() -> OnChainEventType {
                    OnChainEventType::EventTypeNone
                }
            }
            impl ::core::convert::From<OnChainEventType> for i32 {
                fn from(value: OnChainEventType) -> i32 {
                    value as i32
                }
            }
            impl OnChainEventType {
                /// String value of the enum field names used in the ProtoBuf definition.
                ///
                /// The values are not transformed in any way and thus are considered stable
                /// (if the ProtoBuf definition does not change) and safe for programmatic use.
                pub fn as_str_name(&self) -> &'static str {
                    match self {
                        OnChainEventType::EventTypeNone => "EVENT_TYPE_NONE",
                        OnChainEventType::EventTypeSigner => "EVENT_TYPE_SIGNER",
                        OnChainEventType::EventTypeSignerMigrated => {
                            "EVENT_TYPE_SIGNER_MIGRATED"
                        }
                        OnChainEventType::EventTypeIdRegister => "EVENT_TYPE_ID_REGISTER",
                        OnChainEventType::EventTypeStorageRent => {
                            "EVENT_TYPE_STORAGE_RENT"
                        }
                    }
                }
                /// Creates an enum from field names used in the ProtoBuf definition.
                pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
                    match value {
                        "EVENT_TYPE_NONE" => Some(Self::EventTypeNone),
                        "EVENT_TYPE_SIGNER" => Some(Self::EventTypeSigner),
                        "EVENT_TYPE_SIGNER_MIGRATED" => {
                            Some(Self::EventTypeSignerMigrated)
                        }
                        "EVENT_TYPE_ID_REGISTER" => Some(Self::EventTypeIdRegister),
                        "EVENT_TYPE_STORAGE_RENT" => Some(Self::EventTypeStorageRent),
                        _ => None,
                    }
                }
            }
            #[repr(i32)]
            pub enum SignerEventType {
                None = 0,
                Add = 1,
                Remove = 2,
                AdminReset = 3,
            }
            #[automatically_derived]
            impl ::core::clone::Clone for SignerEventType {
                #[inline]
                fn clone(&self) -> SignerEventType {
                    *self
                }
            }
            #[automatically_derived]
            impl ::core::marker::Copy for SignerEventType {}
            #[automatically_derived]
            impl ::core::fmt::Debug for SignerEventType {
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    ::core::fmt::Formatter::write_str(
                        f,
                        match self {
                            SignerEventType::None => "None",
                            SignerEventType::Add => "Add",
                            SignerEventType::Remove => "Remove",
                            SignerEventType::AdminReset => "AdminReset",
                        },
                    )
                }
            }
            #[automatically_derived]
            impl ::core::marker::StructuralPartialEq for SignerEventType {}
            #[automatically_derived]
            impl ::core::cmp::PartialEq for SignerEventType {
                #[inline]
                fn eq(&self, other: &SignerEventType) -> bool {
                    let __self_tag = ::core::intrinsics::discriminant_value(self);
                    let __arg1_tag = ::core::intrinsics::discriminant_value(other);
                    __self_tag == __arg1_tag
                }
            }
            #[automatically_derived]
            impl ::core::marker::StructuralEq for SignerEventType {}
            #[automatically_derived]
            impl ::core::cmp::Eq for SignerEventType {
                #[inline]
                #[doc(hidden)]
                #[no_coverage]
                fn assert_receiver_is_total_eq(&self) -> () {}
            }
            #[automatically_derived]
            impl ::core::hash::Hash for SignerEventType {
                fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {
                    let __self_tag = ::core::intrinsics::discriminant_value(self);
                    ::core::hash::Hash::hash(&__self_tag, state)
                }
            }
            #[automatically_derived]
            impl ::core::cmp::PartialOrd for SignerEventType {
                #[inline]
                fn partial_cmp(
                    &self,
                    other: &SignerEventType,
                ) -> ::core::option::Option<::core::cmp::Ordering> {
                    let __self_tag = ::core::intrinsics::discriminant_value(self);
                    let __arg1_tag = ::core::intrinsics::discriminant_value(other);
                    ::core::cmp::PartialOrd::partial_cmp(&__self_tag, &__arg1_tag)
                }
            }
            #[automatically_derived]
            impl ::core::cmp::Ord for SignerEventType {
                #[inline]
                fn cmp(&self, other: &SignerEventType) -> ::core::cmp::Ordering {
                    let __self_tag = ::core::intrinsics::discriminant_value(self);
                    let __arg1_tag = ::core::intrinsics::discriminant_value(other);
                    ::core::cmp::Ord::cmp(&__self_tag, &__arg1_tag)
                }
            }
            impl SignerEventType {
                ///Returns `true` if `value` is a variant of `SignerEventType`.
                pub fn is_valid(value: i32) -> bool {
                    match value {
                        0 => true,
                        1 => true,
                        2 => true,
                        3 => true,
                        _ => false,
                    }
                }
                ///Converts an `i32` to a `SignerEventType`, or `None` if `value` is not a valid variant.
                pub fn from_i32(value: i32) -> ::core::option::Option<SignerEventType> {
                    match value {
                        0 => ::core::option::Option::Some(SignerEventType::None),
                        1 => ::core::option::Option::Some(SignerEventType::Add),
                        2 => ::core::option::Option::Some(SignerEventType::Remove),
                        3 => ::core::option::Option::Some(SignerEventType::AdminReset),
                        _ => ::core::option::Option::None,
                    }
                }
            }
            impl ::core::default::Default for SignerEventType {
                fn default() -> SignerEventType {
                    SignerEventType::None
                }
            }
            impl ::core::convert::From<SignerEventType> for i32 {
                fn from(value: SignerEventType) -> i32 {
                    value as i32
                }
            }
            impl SignerEventType {
                /// String value of the enum field names used in the ProtoBuf definition.
                ///
                /// The values are not transformed in any way and thus are considered stable
                /// (if the ProtoBuf definition does not change) and safe for programmatic use.
                pub fn as_str_name(&self) -> &'static str {
                    match self {
                        SignerEventType::None => "SIGNER_EVENT_TYPE_NONE",
                        SignerEventType::Add => "SIGNER_EVENT_TYPE_ADD",
                        SignerEventType::Remove => "SIGNER_EVENT_TYPE_REMOVE",
                        SignerEventType::AdminReset => "SIGNER_EVENT_TYPE_ADMIN_RESET",
                    }
                }
                /// Creates an enum from field names used in the ProtoBuf definition.
                pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
                    match value {
                        "SIGNER_EVENT_TYPE_NONE" => Some(Self::None),
                        "SIGNER_EVENT_TYPE_ADD" => Some(Self::Add),
                        "SIGNER_EVENT_TYPE_REMOVE" => Some(Self::Remove),
                        "SIGNER_EVENT_TYPE_ADMIN_RESET" => Some(Self::AdminReset),
                        _ => None,
                    }
                }
            }
            #[repr(i32)]
            pub enum IdRegisterEventType {
                None = 0,
                Register = 1,
                Transfer = 2,
            }
            #[automatically_derived]
            impl ::core::clone::Clone for IdRegisterEventType {
                #[inline]
                fn clone(&self) -> IdRegisterEventType {
                    *self
                }
            }
            #[automatically_derived]
            impl ::core::marker::Copy for IdRegisterEventType {}
            #[automatically_derived]
            impl ::core::fmt::Debug for IdRegisterEventType {
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    ::core::fmt::Formatter::write_str(
                        f,
                        match self {
                            IdRegisterEventType::None => "None",
                            IdRegisterEventType::Register => "Register",
                            IdRegisterEventType::Transfer => "Transfer",
                        },
                    )
                }
            }
            #[automatically_derived]
            impl ::core::marker::StructuralPartialEq for IdRegisterEventType {}
            #[automatically_derived]
            impl ::core::cmp::PartialEq for IdRegisterEventType {
                #[inline]
                fn eq(&self, other: &IdRegisterEventType) -> bool {
                    let __self_tag = ::core::intrinsics::discriminant_value(self);
                    let __arg1_tag = ::core::intrinsics::discriminant_value(other);
                    __self_tag == __arg1_tag
                }
            }
            #[automatically_derived]
            impl ::core::marker::StructuralEq for IdRegisterEventType {}
            #[automatically_derived]
            impl ::core::cmp::Eq for IdRegisterEventType {
                #[inline]
                #[doc(hidden)]
                #[no_coverage]
                fn assert_receiver_is_total_eq(&self) -> () {}
            }
            #[automatically_derived]
            impl ::core::hash::Hash for IdRegisterEventType {
                fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {
                    let __self_tag = ::core::intrinsics::discriminant_value(self);
                    ::core::hash::Hash::hash(&__self_tag, state)
                }
            }
            #[automatically_derived]
            impl ::core::cmp::PartialOrd for IdRegisterEventType {
                #[inline]
                fn partial_cmp(
                    &self,
                    other: &IdRegisterEventType,
                ) -> ::core::option::Option<::core::cmp::Ordering> {
                    let __self_tag = ::core::intrinsics::discriminant_value(self);
                    let __arg1_tag = ::core::intrinsics::discriminant_value(other);
                    ::core::cmp::PartialOrd::partial_cmp(&__self_tag, &__arg1_tag)
                }
            }
            #[automatically_derived]
            impl ::core::cmp::Ord for IdRegisterEventType {
                #[inline]
                fn cmp(&self, other: &IdRegisterEventType) -> ::core::cmp::Ordering {
                    let __self_tag = ::core::intrinsics::discriminant_value(self);
                    let __arg1_tag = ::core::intrinsics::discriminant_value(other);
                    ::core::cmp::Ord::cmp(&__self_tag, &__arg1_tag)
                }
            }
            impl IdRegisterEventType {
                ///Returns `true` if `value` is a variant of `IdRegisterEventType`.
                pub fn is_valid(value: i32) -> bool {
                    match value {
                        0 => true,
                        1 => true,
                        2 => true,
                        _ => false,
                    }
                }
                ///Converts an `i32` to a `IdRegisterEventType`, or `None` if `value` is not a valid variant.
                pub fn from_i32(
                    value: i32,
                ) -> ::core::option::Option<IdRegisterEventType> {
                    match value {
                        0 => ::core::option::Option::Some(IdRegisterEventType::None),
                        1 => ::core::option::Option::Some(IdRegisterEventType::Register),
                        2 => ::core::option::Option::Some(IdRegisterEventType::Transfer),
                        _ => ::core::option::Option::None,
                    }
                }
            }
            impl ::core::default::Default for IdRegisterEventType {
                fn default() -> IdRegisterEventType {
                    IdRegisterEventType::None
                }
            }
            impl ::core::convert::From<IdRegisterEventType> for i32 {
                fn from(value: IdRegisterEventType) -> i32 {
                    value as i32
                }
            }
            impl IdRegisterEventType {
                /// String value of the enum field names used in the ProtoBuf definition.
                ///
                /// The values are not transformed in any way and thus are considered stable
                /// (if the ProtoBuf definition does not change) and safe for programmatic use.
                pub fn as_str_name(&self) -> &'static str {
                    match self {
                        IdRegisterEventType::None => "ID_REGISTER_EVENT_TYPE_NONE",
                        IdRegisterEventType::Register => {
                            "ID_REGISTER_EVENT_TYPE_REGISTER"
                        }
                        IdRegisterEventType::Transfer => {
                            "ID_REGISTER_EVENT_TYPE_TRANSFER"
                        }
                    }
                }
                /// Creates an enum from field names used in the ProtoBuf definition.
                pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
                    match value {
                        "ID_REGISTER_EVENT_TYPE_NONE" => Some(Self::None),
                        "ID_REGISTER_EVENT_TYPE_REGISTER" => Some(Self::Register),
                        "ID_REGISTER_EVENT_TYPE_TRANSFER" => Some(Self::Transfer),
                        _ => None,
                    }
                }
            }
            #[allow(clippy::derive_partial_eq_without_eq)]
            pub struct MergeMessageBody {
                #[prost(message, optional, tag = "1")]
                pub message: ::core::option::Option<Message>,
                #[prost(message, repeated, tag = "2")]
                pub deleted_messages: ::prost::alloc::vec::Vec<Message>,
            }
            #[automatically_derived]
            #[allow(clippy::derive_partial_eq_without_eq)]
            impl ::core::clone::Clone for MergeMessageBody {
                #[inline]
                fn clone(&self) -> MergeMessageBody {
                    MergeMessageBody {
                        message: ::core::clone::Clone::clone(&self.message),
                        deleted_messages: ::core::clone::Clone::clone(
                            &self.deleted_messages,
                        ),
                    }
                }
            }
            #[allow(clippy::derive_partial_eq_without_eq)]
            #[automatically_derived]
            impl ::core::marker::StructuralPartialEq for MergeMessageBody {}
            #[automatically_derived]
            #[allow(clippy::derive_partial_eq_without_eq)]
            impl ::core::cmp::PartialEq for MergeMessageBody {
                #[inline]
                fn eq(&self, other: &MergeMessageBody) -> bool {
                    self.message == other.message
                        && self.deleted_messages == other.deleted_messages
                }
            }
            impl ::prost::Message for MergeMessageBody {
                #[allow(unused_variables)]
                fn encode_raw<B>(&self, buf: &mut B)
                where
                    B: ::prost::bytes::BufMut,
                {
                    if let Some(ref msg) = self.message {
                        ::prost::encoding::message::encode(1u32, msg, buf);
                    }
                    for msg in &self.deleted_messages {
                        ::prost::encoding::message::encode(2u32, msg, buf);
                    }
                }
                #[allow(unused_variables)]
                fn merge_field<B>(
                    &mut self,
                    tag: u32,
                    wire_type: ::prost::encoding::WireType,
                    buf: &mut B,
                    ctx: ::prost::encoding::DecodeContext,
                ) -> ::core::result::Result<(), ::prost::DecodeError>
                where
                    B: ::prost::bytes::Buf,
                {
                    const STRUCT_NAME: &'static str = "MergeMessageBody";
                    match tag {
                        1u32 => {
                            let mut value = &mut self.message;
                            ::prost::encoding::message::merge(
                                    wire_type,
                                    value.get_or_insert_with(::core::default::Default::default),
                                    buf,
                                    ctx,
                                )
                                .map_err(|mut error| {
                                    error.push(STRUCT_NAME, "message");
                                    error
                                })
                        }
                        2u32 => {
                            let mut value = &mut self.deleted_messages;
                            ::prost::encoding::message::merge_repeated(
                                    wire_type,
                                    value,
                                    buf,
                                    ctx,
                                )
                                .map_err(|mut error| {
                                    error.push(STRUCT_NAME, "deleted_messages");
                                    error
                                })
                        }
                        _ => ::prost::encoding::skip_field(wire_type, tag, buf, ctx),
                    }
                }
                #[inline]
                fn encoded_len(&self) -> usize {
                    0
                        + self
                            .message
                            .as_ref()
                            .map_or(
                                0,
                                |msg| ::prost::encoding::message::encoded_len(1u32, msg),
                            )
                        + ::prost::encoding::message::encoded_len_repeated(
                            2u32,
                            &self.deleted_messages,
                        )
                }
                fn clear(&mut self) {
                    self.message = ::core::option::Option::None;
                    self.deleted_messages.clear();
                }
            }
            impl ::core::default::Default for MergeMessageBody {
                fn default() -> Self {
                    MergeMessageBody {
                        message: ::core::default::Default::default(),
                        deleted_messages: ::core::default::Default::default(),
                    }
                }
            }
            impl ::core::fmt::Debug for MergeMessageBody {
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    let mut builder = f.debug_struct("MergeMessageBody");
                    let builder = {
                        let wrapper = &self.message;
                        builder.field("message", &wrapper)
                    };
                    let builder = {
                        let wrapper = &self.deleted_messages;
                        builder.field("deleted_messages", &wrapper)
                    };
                    builder.finish()
                }
            }
            #[allow(clippy::derive_partial_eq_without_eq)]
            pub struct PruneMessageBody {
                #[prost(message, optional, tag = "1")]
                pub message: ::core::option::Option<Message>,
            }
            #[automatically_derived]
            #[allow(clippy::derive_partial_eq_without_eq)]
            impl ::core::clone::Clone for PruneMessageBody {
                #[inline]
                fn clone(&self) -> PruneMessageBody {
                    PruneMessageBody {
                        message: ::core::clone::Clone::clone(&self.message),
                    }
                }
            }
            #[allow(clippy::derive_partial_eq_without_eq)]
            #[automatically_derived]
            impl ::core::marker::StructuralPartialEq for PruneMessageBody {}
            #[automatically_derived]
            #[allow(clippy::derive_partial_eq_without_eq)]
            impl ::core::cmp::PartialEq for PruneMessageBody {
                #[inline]
                fn eq(&self, other: &PruneMessageBody) -> bool {
                    self.message == other.message
                }
            }
            impl ::prost::Message for PruneMessageBody {
                #[allow(unused_variables)]
                fn encode_raw<B>(&self, buf: &mut B)
                where
                    B: ::prost::bytes::BufMut,
                {
                    if let Some(ref msg) = self.message {
                        ::prost::encoding::message::encode(1u32, msg, buf);
                    }
                }
                #[allow(unused_variables)]
                fn merge_field<B>(
                    &mut self,
                    tag: u32,
                    wire_type: ::prost::encoding::WireType,
                    buf: &mut B,
                    ctx: ::prost::encoding::DecodeContext,
                ) -> ::core::result::Result<(), ::prost::DecodeError>
                where
                    B: ::prost::bytes::Buf,
                {
                    const STRUCT_NAME: &'static str = "PruneMessageBody";
                    match tag {
                        1u32 => {
                            let mut value = &mut self.message;
                            ::prost::encoding::message::merge(
                                    wire_type,
                                    value.get_or_insert_with(::core::default::Default::default),
                                    buf,
                                    ctx,
                                )
                                .map_err(|mut error| {
                                    error.push(STRUCT_NAME, "message");
                                    error
                                })
                        }
                        _ => ::prost::encoding::skip_field(wire_type, tag, buf, ctx),
                    }
                }
                #[inline]
                fn encoded_len(&self) -> usize {
                    0
                        + self
                            .message
                            .as_ref()
                            .map_or(
                                0,
                                |msg| ::prost::encoding::message::encoded_len(1u32, msg),
                            )
                }
                fn clear(&mut self) {
                    self.message = ::core::option::Option::None;
                }
            }
            impl ::core::default::Default for PruneMessageBody {
                fn default() -> Self {
                    PruneMessageBody {
                        message: ::core::default::Default::default(),
                    }
                }
            }
            impl ::core::fmt::Debug for PruneMessageBody {
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    let mut builder = f.debug_struct("PruneMessageBody");
                    let builder = {
                        let wrapper = &self.message;
                        builder.field("message", &wrapper)
                    };
                    builder.finish()
                }
            }
            #[allow(clippy::derive_partial_eq_without_eq)]
            pub struct RevokeMessageBody {
                #[prost(message, optional, tag = "1")]
                pub message: ::core::option::Option<Message>,
            }
            #[automatically_derived]
            #[allow(clippy::derive_partial_eq_without_eq)]
            impl ::core::clone::Clone for RevokeMessageBody {
                #[inline]
                fn clone(&self) -> RevokeMessageBody {
                    RevokeMessageBody {
                        message: ::core::clone::Clone::clone(&self.message),
                    }
                }
            }
            #[allow(clippy::derive_partial_eq_without_eq)]
            #[automatically_derived]
            impl ::core::marker::StructuralPartialEq for RevokeMessageBody {}
            #[automatically_derived]
            #[allow(clippy::derive_partial_eq_without_eq)]
            impl ::core::cmp::PartialEq for RevokeMessageBody {
                #[inline]
                fn eq(&self, other: &RevokeMessageBody) -> bool {
                    self.message == other.message
                }
            }
            impl ::prost::Message for RevokeMessageBody {
                #[allow(unused_variables)]
                fn encode_raw<B>(&self, buf: &mut B)
                where
                    B: ::prost::bytes::BufMut,
                {
                    if let Some(ref msg) = self.message {
                        ::prost::encoding::message::encode(1u32, msg, buf);
                    }
                }
                #[allow(unused_variables)]
                fn merge_field<B>(
                    &mut self,
                    tag: u32,
                    wire_type: ::prost::encoding::WireType,
                    buf: &mut B,
                    ctx: ::prost::encoding::DecodeContext,
                ) -> ::core::result::Result<(), ::prost::DecodeError>
                where
                    B: ::prost::bytes::Buf,
                {
                    const STRUCT_NAME: &'static str = "RevokeMessageBody";
                    match tag {
                        1u32 => {
                            let mut value = &mut self.message;
                            ::prost::encoding::message::merge(
                                    wire_type,
                                    value.get_or_insert_with(::core::default::Default::default),
                                    buf,
                                    ctx,
                                )
                                .map_err(|mut error| {
                                    error.push(STRUCT_NAME, "message");
                                    error
                                })
                        }
                        _ => ::prost::encoding::skip_field(wire_type, tag, buf, ctx),
                    }
                }
                #[inline]
                fn encoded_len(&self) -> usize {
                    0
                        + self
                            .message
                            .as_ref()
                            .map_or(
                                0,
                                |msg| ::prost::encoding::message::encoded_len(1u32, msg),
                            )
                }
                fn clear(&mut self) {
                    self.message = ::core::option::Option::None;
                }
            }
            impl ::core::default::Default for RevokeMessageBody {
                fn default() -> Self {
                    RevokeMessageBody {
                        message: ::core::default::Default::default(),
                    }
                }
            }
            impl ::core::fmt::Debug for RevokeMessageBody {
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    let mut builder = f.debug_struct("RevokeMessageBody");
                    let builder = {
                        let wrapper = &self.message;
                        builder.field("message", &wrapper)
                    };
                    builder.finish()
                }
            }
            #[allow(clippy::derive_partial_eq_without_eq)]
            pub struct MergeIdRegistryEventBody {
                #[prost(message, optional, tag = "1")]
                pub id_registry_event: ::core::option::Option<IdRegistryEvent>,
            }
            #[automatically_derived]
            #[allow(clippy::derive_partial_eq_without_eq)]
            impl ::core::clone::Clone for MergeIdRegistryEventBody {
                #[inline]
                fn clone(&self) -> MergeIdRegistryEventBody {
                    MergeIdRegistryEventBody {
                        id_registry_event: ::core::clone::Clone::clone(
                            &self.id_registry_event,
                        ),
                    }
                }
            }
            #[allow(clippy::derive_partial_eq_without_eq)]
            #[automatically_derived]
            impl ::core::marker::StructuralPartialEq for MergeIdRegistryEventBody {}
            #[automatically_derived]
            #[allow(clippy::derive_partial_eq_without_eq)]
            impl ::core::cmp::PartialEq for MergeIdRegistryEventBody {
                #[inline]
                fn eq(&self, other: &MergeIdRegistryEventBody) -> bool {
                    self.id_registry_event == other.id_registry_event
                }
            }
            impl ::prost::Message for MergeIdRegistryEventBody {
                #[allow(unused_variables)]
                fn encode_raw<B>(&self, buf: &mut B)
                where
                    B: ::prost::bytes::BufMut,
                {
                    if let Some(ref msg) = self.id_registry_event {
                        ::prost::encoding::message::encode(1u32, msg, buf);
                    }
                }
                #[allow(unused_variables)]
                fn merge_field<B>(
                    &mut self,
                    tag: u32,
                    wire_type: ::prost::encoding::WireType,
                    buf: &mut B,
                    ctx: ::prost::encoding::DecodeContext,
                ) -> ::core::result::Result<(), ::prost::DecodeError>
                where
                    B: ::prost::bytes::Buf,
                {
                    const STRUCT_NAME: &'static str = "MergeIdRegistryEventBody";
                    match tag {
                        1u32 => {
                            let mut value = &mut self.id_registry_event;
                            ::prost::encoding::message::merge(
                                    wire_type,
                                    value.get_or_insert_with(::core::default::Default::default),
                                    buf,
                                    ctx,
                                )
                                .map_err(|mut error| {
                                    error.push(STRUCT_NAME, "id_registry_event");
                                    error
                                })
                        }
                        _ => ::prost::encoding::skip_field(wire_type, tag, buf, ctx),
                    }
                }
                #[inline]
                fn encoded_len(&self) -> usize {
                    0
                        + self
                            .id_registry_event
                            .as_ref()
                            .map_or(
                                0,
                                |msg| ::prost::encoding::message::encoded_len(1u32, msg),
                            )
                }
                fn clear(&mut self) {
                    self.id_registry_event = ::core::option::Option::None;
                }
            }
            impl ::core::default::Default for MergeIdRegistryEventBody {
                fn default() -> Self {
                    MergeIdRegistryEventBody {
                        id_registry_event: ::core::default::Default::default(),
                    }
                }
            }
            impl ::core::fmt::Debug for MergeIdRegistryEventBody {
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    let mut builder = f.debug_struct("MergeIdRegistryEventBody");
                    let builder = {
                        let wrapper = &self.id_registry_event;
                        builder.field("id_registry_event", &wrapper)
                    };
                    builder.finish()
                }
            }
            #[allow(clippy::derive_partial_eq_without_eq)]
            pub struct MergeNameRegistryEventBody {
                #[prost(message, optional, tag = "1")]
                pub name_registry_event: ::core::option::Option<NameRegistryEvent>,
            }
            #[automatically_derived]
            #[allow(clippy::derive_partial_eq_without_eq)]
            impl ::core::clone::Clone for MergeNameRegistryEventBody {
                #[inline]
                fn clone(&self) -> MergeNameRegistryEventBody {
                    MergeNameRegistryEventBody {
                        name_registry_event: ::core::clone::Clone::clone(
                            &self.name_registry_event,
                        ),
                    }
                }
            }
            #[allow(clippy::derive_partial_eq_without_eq)]
            #[automatically_derived]
            impl ::core::marker::StructuralPartialEq for MergeNameRegistryEventBody {}
            #[automatically_derived]
            #[allow(clippy::derive_partial_eq_without_eq)]
            impl ::core::cmp::PartialEq for MergeNameRegistryEventBody {
                #[inline]
                fn eq(&self, other: &MergeNameRegistryEventBody) -> bool {
                    self.name_registry_event == other.name_registry_event
                }
            }
            impl ::prost::Message for MergeNameRegistryEventBody {
                #[allow(unused_variables)]
                fn encode_raw<B>(&self, buf: &mut B)
                where
                    B: ::prost::bytes::BufMut,
                {
                    if let Some(ref msg) = self.name_registry_event {
                        ::prost::encoding::message::encode(1u32, msg, buf);
                    }
                }
                #[allow(unused_variables)]
                fn merge_field<B>(
                    &mut self,
                    tag: u32,
                    wire_type: ::prost::encoding::WireType,
                    buf: &mut B,
                    ctx: ::prost::encoding::DecodeContext,
                ) -> ::core::result::Result<(), ::prost::DecodeError>
                where
                    B: ::prost::bytes::Buf,
                {
                    const STRUCT_NAME: &'static str = "MergeNameRegistryEventBody";
                    match tag {
                        1u32 => {
                            let mut value = &mut self.name_registry_event;
                            ::prost::encoding::message::merge(
                                    wire_type,
                                    value.get_or_insert_with(::core::default::Default::default),
                                    buf,
                                    ctx,
                                )
                                .map_err(|mut error| {
                                    error.push(STRUCT_NAME, "name_registry_event");
                                    error
                                })
                        }
                        _ => ::prost::encoding::skip_field(wire_type, tag, buf, ctx),
                    }
                }
                #[inline]
                fn encoded_len(&self) -> usize {
                    0
                        + self
                            .name_registry_event
                            .as_ref()
                            .map_or(
                                0,
                                |msg| ::prost::encoding::message::encoded_len(1u32, msg),
                            )
                }
                fn clear(&mut self) {
                    self.name_registry_event = ::core::option::Option::None;
                }
            }
            impl ::core::default::Default for MergeNameRegistryEventBody {
                fn default() -> Self {
                    MergeNameRegistryEventBody {
                        name_registry_event: ::core::default::Default::default(),
                    }
                }
            }
            impl ::core::fmt::Debug for MergeNameRegistryEventBody {
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    let mut builder = f.debug_struct("MergeNameRegistryEventBody");
                    let builder = {
                        let wrapper = &self.name_registry_event;
                        builder.field("name_registry_event", &wrapper)
                    };
                    builder.finish()
                }
            }
            #[allow(clippy::derive_partial_eq_without_eq)]
            pub struct MergeOnChainEventBody {
                #[prost(message, optional, tag = "1")]
                pub on_chain_event: ::core::option::Option<OnChainEvent>,
            }
            #[automatically_derived]
            #[allow(clippy::derive_partial_eq_without_eq)]
            impl ::core::clone::Clone for MergeOnChainEventBody {
                #[inline]
                fn clone(&self) -> MergeOnChainEventBody {
                    MergeOnChainEventBody {
                        on_chain_event: ::core::clone::Clone::clone(&self.on_chain_event),
                    }
                }
            }
            #[allow(clippy::derive_partial_eq_without_eq)]
            #[automatically_derived]
            impl ::core::marker::StructuralPartialEq for MergeOnChainEventBody {}
            #[automatically_derived]
            #[allow(clippy::derive_partial_eq_without_eq)]
            impl ::core::cmp::PartialEq for MergeOnChainEventBody {
                #[inline]
                fn eq(&self, other: &MergeOnChainEventBody) -> bool {
                    self.on_chain_event == other.on_chain_event
                }
            }
            impl ::prost::Message for MergeOnChainEventBody {
                #[allow(unused_variables)]
                fn encode_raw<B>(&self, buf: &mut B)
                where
                    B: ::prost::bytes::BufMut,
                {
                    if let Some(ref msg) = self.on_chain_event {
                        ::prost::encoding::message::encode(1u32, msg, buf);
                    }
                }
                #[allow(unused_variables)]
                fn merge_field<B>(
                    &mut self,
                    tag: u32,
                    wire_type: ::prost::encoding::WireType,
                    buf: &mut B,
                    ctx: ::prost::encoding::DecodeContext,
                ) -> ::core::result::Result<(), ::prost::DecodeError>
                where
                    B: ::prost::bytes::Buf,
                {
                    const STRUCT_NAME: &'static str = "MergeOnChainEventBody";
                    match tag {
                        1u32 => {
                            let mut value = &mut self.on_chain_event;
                            ::prost::encoding::message::merge(
                                    wire_type,
                                    value.get_or_insert_with(::core::default::Default::default),
                                    buf,
                                    ctx,
                                )
                                .map_err(|mut error| {
                                    error.push(STRUCT_NAME, "on_chain_event");
                                    error
                                })
                        }
                        _ => ::prost::encoding::skip_field(wire_type, tag, buf, ctx),
                    }
                }
                #[inline]
                fn encoded_len(&self) -> usize {
                    0
                        + self
                            .on_chain_event
                            .as_ref()
                            .map_or(
                                0,
                                |msg| ::prost::encoding::message::encoded_len(1u32, msg),
                            )
                }
                fn clear(&mut self) {
                    self.on_chain_event = ::core::option::Option::None;
                }
            }
            impl ::core::default::Default for MergeOnChainEventBody {
                fn default() -> Self {
                    MergeOnChainEventBody {
                        on_chain_event: ::core::default::Default::default(),
                    }
                }
            }
            impl ::core::fmt::Debug for MergeOnChainEventBody {
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    let mut builder = f.debug_struct("MergeOnChainEventBody");
                    let builder = {
                        let wrapper = &self.on_chain_event;
                        builder.field("on_chain_event", &wrapper)
                    };
                    builder.finish()
                }
            }
            #[allow(clippy::derive_partial_eq_without_eq)]
            pub struct MergeUserNameProofBody {
                #[prost(message, optional, tag = "1")]
                pub username_proof: ::core::option::Option<UserNameProof>,
                #[prost(message, optional, tag = "2")]
                pub deleted_username_proof: ::core::option::Option<UserNameProof>,
                #[prost(message, optional, tag = "3")]
                pub username_proof_message: ::core::option::Option<Message>,
                #[prost(message, optional, tag = "4")]
                pub deleted_username_proof_message: ::core::option::Option<Message>,
            }
            #[automatically_derived]
            #[allow(clippy::derive_partial_eq_without_eq)]
            impl ::core::clone::Clone for MergeUserNameProofBody {
                #[inline]
                fn clone(&self) -> MergeUserNameProofBody {
                    MergeUserNameProofBody {
                        username_proof: ::core::clone::Clone::clone(
                            &self.username_proof,
                        ),
                        deleted_username_proof: ::core::clone::Clone::clone(
                            &self.deleted_username_proof,
                        ),
                        username_proof_message: ::core::clone::Clone::clone(
                            &self.username_proof_message,
                        ),
                        deleted_username_proof_message: ::core::clone::Clone::clone(
                            &self.deleted_username_proof_message,
                        ),
                    }
                }
            }
            #[allow(clippy::derive_partial_eq_without_eq)]
            #[automatically_derived]
            impl ::core::marker::StructuralPartialEq for MergeUserNameProofBody {}
            #[automatically_derived]
            #[allow(clippy::derive_partial_eq_without_eq)]
            impl ::core::cmp::PartialEq for MergeUserNameProofBody {
                #[inline]
                fn eq(&self, other: &MergeUserNameProofBody) -> bool {
                    self.username_proof == other.username_proof
                        && self.deleted_username_proof == other.deleted_username_proof
                        && self.username_proof_message == other.username_proof_message
                        && self.deleted_username_proof_message
                            == other.deleted_username_proof_message
                }
            }
            impl ::prost::Message for MergeUserNameProofBody {
                #[allow(unused_variables)]
                fn encode_raw<B>(&self, buf: &mut B)
                where
                    B: ::prost::bytes::BufMut,
                {
                    if let Some(ref msg) = self.username_proof {
                        ::prost::encoding::message::encode(1u32, msg, buf);
                    }
                    if let Some(ref msg) = self.deleted_username_proof {
                        ::prost::encoding::message::encode(2u32, msg, buf);
                    }
                    if let Some(ref msg) = self.username_proof_message {
                        ::prost::encoding::message::encode(3u32, msg, buf);
                    }
                    if let Some(ref msg) = self.deleted_username_proof_message {
                        ::prost::encoding::message::encode(4u32, msg, buf);
                    }
                }
                #[allow(unused_variables)]
                fn merge_field<B>(
                    &mut self,
                    tag: u32,
                    wire_type: ::prost::encoding::WireType,
                    buf: &mut B,
                    ctx: ::prost::encoding::DecodeContext,
                ) -> ::core::result::Result<(), ::prost::DecodeError>
                where
                    B: ::prost::bytes::Buf,
                {
                    const STRUCT_NAME: &'static str = "MergeUserNameProofBody";
                    match tag {
                        1u32 => {
                            let mut value = &mut self.username_proof;
                            ::prost::encoding::message::merge(
                                    wire_type,
                                    value.get_or_insert_with(::core::default::Default::default),
                                    buf,
                                    ctx,
                                )
                                .map_err(|mut error| {
                                    error.push(STRUCT_NAME, "username_proof");
                                    error
                                })
                        }
                        2u32 => {
                            let mut value = &mut self.deleted_username_proof;
                            ::prost::encoding::message::merge(
                                    wire_type,
                                    value.get_or_insert_with(::core::default::Default::default),
                                    buf,
                                    ctx,
                                )
                                .map_err(|mut error| {
                                    error.push(STRUCT_NAME, "deleted_username_proof");
                                    error
                                })
                        }
                        3u32 => {
                            let mut value = &mut self.username_proof_message;
                            ::prost::encoding::message::merge(
                                    wire_type,
                                    value.get_or_insert_with(::core::default::Default::default),
                                    buf,
                                    ctx,
                                )
                                .map_err(|mut error| {
                                    error.push(STRUCT_NAME, "username_proof_message");
                                    error
                                })
                        }
                        4u32 => {
                            let mut value = &mut self.deleted_username_proof_message;
                            ::prost::encoding::message::merge(
                                    wire_type,
                                    value.get_or_insert_with(::core::default::Default::default),
                                    buf,
                                    ctx,
                                )
                                .map_err(|mut error| {
                                    error.push(STRUCT_NAME, "deleted_username_proof_message");
                                    error
                                })
                        }
                        _ => ::prost::encoding::skip_field(wire_type, tag, buf, ctx),
                    }
                }
                #[inline]
                fn encoded_len(&self) -> usize {
                    0
                        + self
                            .username_proof
                            .as_ref()
                            .map_or(
                                0,
                                |msg| ::prost::encoding::message::encoded_len(1u32, msg),
                            )
                        + self
                            .deleted_username_proof
                            .as_ref()
                            .map_or(
                                0,
                                |msg| ::prost::encoding::message::encoded_len(2u32, msg),
                            )
                        + self
                            .username_proof_message
                            .as_ref()
                            .map_or(
                                0,
                                |msg| ::prost::encoding::message::encoded_len(3u32, msg),
                            )
                        + self
                            .deleted_username_proof_message
                            .as_ref()
                            .map_or(
                                0,
                                |msg| ::prost::encoding::message::encoded_len(4u32, msg),
                            )
                }
                fn clear(&mut self) {
                    self.username_proof = ::core::option::Option::None;
                    self.deleted_username_proof = ::core::option::Option::None;
                    self.username_proof_message = ::core::option::Option::None;
                    self.deleted_username_proof_message = ::core::option::Option::None;
                }
            }
            impl ::core::default::Default for MergeUserNameProofBody {
                fn default() -> Self {
                    MergeUserNameProofBody {
                        username_proof: ::core::default::Default::default(),
                        deleted_username_proof: ::core::default::Default::default(),
                        username_proof_message: ::core::default::Default::default(),
                        deleted_username_proof_message: ::core::default::Default::default(),
                    }
                }
            }
            impl ::core::fmt::Debug for MergeUserNameProofBody {
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    let mut builder = f.debug_struct("MergeUserNameProofBody");
                    let builder = {
                        let wrapper = &self.username_proof;
                        builder.field("username_proof", &wrapper)
                    };
                    let builder = {
                        let wrapper = &self.deleted_username_proof;
                        builder.field("deleted_username_proof", &wrapper)
                    };
                    let builder = {
                        let wrapper = &self.username_proof_message;
                        builder.field("username_proof_message", &wrapper)
                    };
                    let builder = {
                        let wrapper = &self.deleted_username_proof_message;
                        builder.field("deleted_username_proof_message", &wrapper)
                    };
                    builder.finish()
                }
            }
            #[allow(clippy::derive_partial_eq_without_eq)]
            pub struct HubEvent {
                #[prost(enumeration = "HubEventType", tag = "1")]
                pub r#type: i32,
                #[prost(uint64, tag = "2")]
                pub id: u64,
                #[prost(oneof = "hub_event::Body", tags = "3, 4, 5, 6, 7, 8, 11")]
                pub body: ::core::option::Option<hub_event::Body>,
            }
            #[automatically_derived]
            #[allow(clippy::derive_partial_eq_without_eq)]
            impl ::core::clone::Clone for HubEvent {
                #[inline]
                fn clone(&self) -> HubEvent {
                    HubEvent {
                        r#type: ::core::clone::Clone::clone(&self.r#type),
                        id: ::core::clone::Clone::clone(&self.id),
                        body: ::core::clone::Clone::clone(&self.body),
                    }
                }
            }
            #[allow(clippy::derive_partial_eq_without_eq)]
            #[automatically_derived]
            impl ::core::marker::StructuralPartialEq for HubEvent {}
            #[automatically_derived]
            #[allow(clippy::derive_partial_eq_without_eq)]
            impl ::core::cmp::PartialEq for HubEvent {
                #[inline]
                fn eq(&self, other: &HubEvent) -> bool {
                    self.r#type == other.r#type && self.id == other.id
                        && self.body == other.body
                }
            }
            impl ::prost::Message for HubEvent {
                #[allow(unused_variables)]
                fn encode_raw<B>(&self, buf: &mut B)
                where
                    B: ::prost::bytes::BufMut,
                {
                    if self.r#type != HubEventType::default() as i32 {
                        ::prost::encoding::int32::encode(1u32, &self.r#type, buf);
                    }
                    if self.id != 0u64 {
                        ::prost::encoding::uint64::encode(2u32, &self.id, buf);
                    }
                    if let Some(ref oneof) = self.body {
                        oneof.encode(buf)
                    }
                }
                #[allow(unused_variables)]
                fn merge_field<B>(
                    &mut self,
                    tag: u32,
                    wire_type: ::prost::encoding::WireType,
                    buf: &mut B,
                    ctx: ::prost::encoding::DecodeContext,
                ) -> ::core::result::Result<(), ::prost::DecodeError>
                where
                    B: ::prost::bytes::Buf,
                {
                    const STRUCT_NAME: &'static str = "HubEvent";
                    match tag {
                        1u32 => {
                            let mut value = &mut self.r#type;
                            ::prost::encoding::int32::merge(wire_type, value, buf, ctx)
                                .map_err(|mut error| {
                                    error.push(STRUCT_NAME, "r#type");
                                    error
                                })
                        }
                        2u32 => {
                            let mut value = &mut self.id;
                            ::prost::encoding::uint64::merge(wire_type, value, buf, ctx)
                                .map_err(|mut error| {
                                    error.push(STRUCT_NAME, "id");
                                    error
                                })
                        }
                        3u32 | 4u32 | 5u32 | 6u32 | 7u32 | 8u32 | 11u32 => {
                            let mut value = &mut self.body;
                            hub_event::Body::merge(value, tag, wire_type, buf, ctx)
                                .map_err(|mut error| {
                                    error.push(STRUCT_NAME, "body");
                                    error
                                })
                        }
                        _ => ::prost::encoding::skip_field(wire_type, tag, buf, ctx),
                    }
                }
                #[inline]
                fn encoded_len(&self) -> usize {
                    0
                        + if self.r#type != HubEventType::default() as i32 {
                            ::prost::encoding::int32::encoded_len(1u32, &self.r#type)
                        } else {
                            0
                        }
                        + if self.id != 0u64 {
                            ::prost::encoding::uint64::encoded_len(2u32, &self.id)
                        } else {
                            0
                        } + self.body.as_ref().map_or(0, hub_event::Body::encoded_len)
                }
                fn clear(&mut self) {
                    self.r#type = HubEventType::default() as i32;
                    self.id = 0u64;
                    self.body = ::core::option::Option::None;
                }
            }
            impl ::core::default::Default for HubEvent {
                fn default() -> Self {
                    HubEvent {
                        r#type: HubEventType::default() as i32,
                        id: 0u64,
                        body: ::core::default::Default::default(),
                    }
                }
            }
            impl ::core::fmt::Debug for HubEvent {
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    let mut builder = f.debug_struct("HubEvent");
                    let builder = {
                        let wrapper = {
                            struct ScalarWrapper<'a>(&'a i32);
                            impl<'a> ::core::fmt::Debug for ScalarWrapper<'a> {
                                fn fmt(
                                    &self,
                                    f: &mut ::core::fmt::Formatter,
                                ) -> ::core::fmt::Result {
                                    match HubEventType::from_i32(*self.0) {
                                        None => ::core::fmt::Debug::fmt(&self.0, f),
                                        Some(en) => ::core::fmt::Debug::fmt(&en, f),
                                    }
                                }
                            }
                            ScalarWrapper(&self.r#type)
                        };
                        builder.field("r#type", &wrapper)
                    };
                    let builder = {
                        let wrapper = {
                            fn ScalarWrapper<T>(v: T) -> T {
                                v
                            }
                            ScalarWrapper(&self.id)
                        };
                        builder.field("id", &wrapper)
                    };
                    let builder = {
                        let wrapper = &self.body;
                        builder.field("body", &wrapper)
                    };
                    builder.finish()
                }
            }
            #[allow(dead_code)]
            impl HubEvent {
                ///Returns the enum value of `type`, or the default if the field is set to an invalid enum value.
                pub fn r#type(&self) -> HubEventType {
                    HubEventType::from_i32(self.r#type)
                        .unwrap_or(HubEventType::default())
                }
                ///Sets `type` to the provided enum value.
                pub fn set_type(&mut self, value: HubEventType) {
                    self.r#type = value as i32;
                }
            }
            /// Nested message and enum types in `HubEvent`.
            pub mod hub_event {
                #[allow(clippy::derive_partial_eq_without_eq)]
                pub enum Body {
                    #[prost(message, tag = "3")]
                    MergeMessageBody(super::MergeMessageBody),
                    #[prost(message, tag = "4")]
                    PruneMessageBody(super::PruneMessageBody),
                    #[prost(message, tag = "5")]
                    RevokeMessageBody(super::RevokeMessageBody),
                    #[prost(message, tag = "6")]
                    MergeIdRegistryEventBody(super::MergeIdRegistryEventBody),
                    #[prost(message, tag = "7")]
                    MergeNameRegistryEventBody(super::MergeNameRegistryEventBody),
                    #[prost(message, tag = "8")]
                    MergeUsernameProofBody(super::MergeUserNameProofBody),
                    /// Deprecated
                    ///     MergeRentRegistryEventBody merge_rent_registry_event_body = 9;
                    ///     MergeStorageAdminRegistryEventBody merge_storage_admin_registry_event_body = 10;
                    #[prost(message, tag = "11")]
                    MergeOnChainEventBody(super::MergeOnChainEventBody),
                }
                #[automatically_derived]
                #[allow(clippy::derive_partial_eq_without_eq)]
                impl ::core::clone::Clone for Body {
                    #[inline]
                    fn clone(&self) -> Body {
                        match self {
                            Body::MergeMessageBody(__self_0) => {
                                Body::MergeMessageBody(
                                    ::core::clone::Clone::clone(__self_0),
                                )
                            }
                            Body::PruneMessageBody(__self_0) => {
                                Body::PruneMessageBody(
                                    ::core::clone::Clone::clone(__self_0),
                                )
                            }
                            Body::RevokeMessageBody(__self_0) => {
                                Body::RevokeMessageBody(
                                    ::core::clone::Clone::clone(__self_0),
                                )
                            }
                            Body::MergeIdRegistryEventBody(__self_0) => {
                                Body::MergeIdRegistryEventBody(
                                    ::core::clone::Clone::clone(__self_0),
                                )
                            }
                            Body::MergeNameRegistryEventBody(__self_0) => {
                                Body::MergeNameRegistryEventBody(
                                    ::core::clone::Clone::clone(__self_0),
                                )
                            }
                            Body::MergeUsernameProofBody(__self_0) => {
                                Body::MergeUsernameProofBody(
                                    ::core::clone::Clone::clone(__self_0),
                                )
                            }
                            Body::MergeOnChainEventBody(__self_0) => {
                                Body::MergeOnChainEventBody(
                                    ::core::clone::Clone::clone(__self_0),
                                )
                            }
                        }
                    }
                }
                #[allow(clippy::derive_partial_eq_without_eq)]
                #[automatically_derived]
                impl ::core::marker::StructuralPartialEq for Body {}
                #[automatically_derived]
                #[allow(clippy::derive_partial_eq_without_eq)]
                impl ::core::cmp::PartialEq for Body {
                    #[inline]
                    fn eq(&self, other: &Body) -> bool {
                        let __self_tag = ::core::intrinsics::discriminant_value(self);
                        let __arg1_tag = ::core::intrinsics::discriminant_value(other);
                        __self_tag == __arg1_tag
                            && match (self, other) {
                                (
                                    Body::MergeMessageBody(__self_0),
                                    Body::MergeMessageBody(__arg1_0),
                                ) => *__self_0 == *__arg1_0,
                                (
                                    Body::PruneMessageBody(__self_0),
                                    Body::PruneMessageBody(__arg1_0),
                                ) => *__self_0 == *__arg1_0,
                                (
                                    Body::RevokeMessageBody(__self_0),
                                    Body::RevokeMessageBody(__arg1_0),
                                ) => *__self_0 == *__arg1_0,
                                (
                                    Body::MergeIdRegistryEventBody(__self_0),
                                    Body::MergeIdRegistryEventBody(__arg1_0),
                                ) => *__self_0 == *__arg1_0,
                                (
                                    Body::MergeNameRegistryEventBody(__self_0),
                                    Body::MergeNameRegistryEventBody(__arg1_0),
                                ) => *__self_0 == *__arg1_0,
                                (
                                    Body::MergeUsernameProofBody(__self_0),
                                    Body::MergeUsernameProofBody(__arg1_0),
                                ) => *__self_0 == *__arg1_0,
                                (
                                    Body::MergeOnChainEventBody(__self_0),
                                    Body::MergeOnChainEventBody(__arg1_0),
                                ) => *__self_0 == *__arg1_0,
                                _ => unsafe { ::core::intrinsics::unreachable() }
                            }
                    }
                }
                impl Body {
                    /// Encodes the message to a buffer.
                    pub fn encode<B>(&self, buf: &mut B)
                    where
                        B: ::prost::bytes::BufMut,
                    {
                        match *self {
                            Body::MergeMessageBody(ref value) => {
                                ::prost::encoding::message::encode(3u32, &*value, buf);
                            }
                            Body::PruneMessageBody(ref value) => {
                                ::prost::encoding::message::encode(4u32, &*value, buf);
                            }
                            Body::RevokeMessageBody(ref value) => {
                                ::prost::encoding::message::encode(5u32, &*value, buf);
                            }
                            Body::MergeIdRegistryEventBody(ref value) => {
                                ::prost::encoding::message::encode(6u32, &*value, buf);
                            }
                            Body::MergeNameRegistryEventBody(ref value) => {
                                ::prost::encoding::message::encode(7u32, &*value, buf);
                            }
                            Body::MergeUsernameProofBody(ref value) => {
                                ::prost::encoding::message::encode(8u32, &*value, buf);
                            }
                            Body::MergeOnChainEventBody(ref value) => {
                                ::prost::encoding::message::encode(11u32, &*value, buf);
                            }
                        }
                    }
                    /// Decodes an instance of the message from a buffer, and merges it into self.
                    pub fn merge<B>(
                        field: &mut ::core::option::Option<Body>,
                        tag: u32,
                        wire_type: ::prost::encoding::WireType,
                        buf: &mut B,
                        ctx: ::prost::encoding::DecodeContext,
                    ) -> ::core::result::Result<(), ::prost::DecodeError>
                    where
                        B: ::prost::bytes::Buf,
                    {
                        match tag {
                            3u32 => {
                                match field {
                                    ::core::option::Option::Some(
                                        Body::MergeMessageBody(ref mut value),
                                    ) => {
                                        ::prost::encoding::message::merge(
                                            wire_type,
                                            value,
                                            buf,
                                            ctx,
                                        )
                                    }
                                    _ => {
                                        let mut owned_value = ::core::default::Default::default();
                                        let value = &mut owned_value;
                                        ::prost::encoding::message::merge(
                                                wire_type,
                                                value,
                                                buf,
                                                ctx,
                                            )
                                            .map(|_| {
                                                *field = ::core::option::Option::Some(
                                                    Body::MergeMessageBody(owned_value),
                                                );
                                            })
                                    }
                                }
                            }
                            4u32 => {
                                match field {
                                    ::core::option::Option::Some(
                                        Body::PruneMessageBody(ref mut value),
                                    ) => {
                                        ::prost::encoding::message::merge(
                                            wire_type,
                                            value,
                                            buf,
                                            ctx,
                                        )
                                    }
                                    _ => {
                                        let mut owned_value = ::core::default::Default::default();
                                        let value = &mut owned_value;
                                        ::prost::encoding::message::merge(
                                                wire_type,
                                                value,
                                                buf,
                                                ctx,
                                            )
                                            .map(|_| {
                                                *field = ::core::option::Option::Some(
                                                    Body::PruneMessageBody(owned_value),
                                                );
                                            })
                                    }
                                }
                            }
                            5u32 => {
                                match field {
                                    ::core::option::Option::Some(
                                        Body::RevokeMessageBody(ref mut value),
                                    ) => {
                                        ::prost::encoding::message::merge(
                                            wire_type,
                                            value,
                                            buf,
                                            ctx,
                                        )
                                    }
                                    _ => {
                                        let mut owned_value = ::core::default::Default::default();
                                        let value = &mut owned_value;
                                        ::prost::encoding::message::merge(
                                                wire_type,
                                                value,
                                                buf,
                                                ctx,
                                            )
                                            .map(|_| {
                                                *field = ::core::option::Option::Some(
                                                    Body::RevokeMessageBody(owned_value),
                                                );
                                            })
                                    }
                                }
                            }
                            6u32 => {
                                match field {
                                    ::core::option::Option::Some(
                                        Body::MergeIdRegistryEventBody(ref mut value),
                                    ) => {
                                        ::prost::encoding::message::merge(
                                            wire_type,
                                            value,
                                            buf,
                                            ctx,
                                        )
                                    }
                                    _ => {
                                        let mut owned_value = ::core::default::Default::default();
                                        let value = &mut owned_value;
                                        ::prost::encoding::message::merge(
                                                wire_type,
                                                value,
                                                buf,
                                                ctx,
                                            )
                                            .map(|_| {
                                                *field = ::core::option::Option::Some(
                                                    Body::MergeIdRegistryEventBody(owned_value),
                                                );
                                            })
                                    }
                                }
                            }
                            7u32 => {
                                match field {
                                    ::core::option::Option::Some(
                                        Body::MergeNameRegistryEventBody(ref mut value),
                                    ) => {
                                        ::prost::encoding::message::merge(
                                            wire_type,
                                            value,
                                            buf,
                                            ctx,
                                        )
                                    }
                                    _ => {
                                        let mut owned_value = ::core::default::Default::default();
                                        let value = &mut owned_value;
                                        ::prost::encoding::message::merge(
                                                wire_type,
                                                value,
                                                buf,
                                                ctx,
                                            )
                                            .map(|_| {
                                                *field = ::core::option::Option::Some(
                                                    Body::MergeNameRegistryEventBody(owned_value),
                                                );
                                            })
                                    }
                                }
                            }
                            8u32 => {
                                match field {
                                    ::core::option::Option::Some(
                                        Body::MergeUsernameProofBody(ref mut value),
                                    ) => {
                                        ::prost::encoding::message::merge(
                                            wire_type,
                                            value,
                                            buf,
                                            ctx,
                                        )
                                    }
                                    _ => {
                                        let mut owned_value = ::core::default::Default::default();
                                        let value = &mut owned_value;
                                        ::prost::encoding::message::merge(
                                                wire_type,
                                                value,
                                                buf,
                                                ctx,
                                            )
                                            .map(|_| {
                                                *field = ::core::option::Option::Some(
                                                    Body::MergeUsernameProofBody(owned_value),
                                                );
                                            })
                                    }
                                }
                            }
                            11u32 => {
                                match field {
                                    ::core::option::Option::Some(
                                        Body::MergeOnChainEventBody(ref mut value),
                                    ) => {
                                        ::prost::encoding::message::merge(
                                            wire_type,
                                            value,
                                            buf,
                                            ctx,
                                        )
                                    }
                                    _ => {
                                        let mut owned_value = ::core::default::Default::default();
                                        let value = &mut owned_value;
                                        ::prost::encoding::message::merge(
                                                wire_type,
                                                value,
                                                buf,
                                                ctx,
                                            )
                                            .map(|_| {
                                                *field = ::core::option::Option::Some(
                                                    Body::MergeOnChainEventBody(owned_value),
                                                );
                                            })
                                    }
                                }
                            }
                            _ => {
                                ::core::panicking::panic_fmt(
                                    format_args!(
                                        "internal error: entered unreachable code: {0}",
                                        format_args!("invalid Body tag: {0}", tag),
                                    ),
                                );
                            }
                        }
                    }
                    /// Returns the encoded length of the message without a length delimiter.
                    #[inline]
                    pub fn encoded_len(&self) -> usize {
                        match *self {
                            Body::MergeMessageBody(ref value) => {
                                ::prost::encoding::message::encoded_len(3u32, &*value)
                            }
                            Body::PruneMessageBody(ref value) => {
                                ::prost::encoding::message::encoded_len(4u32, &*value)
                            }
                            Body::RevokeMessageBody(ref value) => {
                                ::prost::encoding::message::encoded_len(5u32, &*value)
                            }
                            Body::MergeIdRegistryEventBody(ref value) => {
                                ::prost::encoding::message::encoded_len(6u32, &*value)
                            }
                            Body::MergeNameRegistryEventBody(ref value) => {
                                ::prost::encoding::message::encoded_len(7u32, &*value)
                            }
                            Body::MergeUsernameProofBody(ref value) => {
                                ::prost::encoding::message::encoded_len(8u32, &*value)
                            }
                            Body::MergeOnChainEventBody(ref value) => {
                                ::prost::encoding::message::encoded_len(11u32, &*value)
                            }
                        }
                    }
                }
                impl ::core::fmt::Debug for Body {
                    fn fmt(
                        &self,
                        f: &mut ::core::fmt::Formatter,
                    ) -> ::core::fmt::Result {
                        match *self {
                            Body::MergeMessageBody(ref value) => {
                                let wrapper = &*value;
                                f.debug_tuple("MergeMessageBody").field(&wrapper).finish()
                            }
                            Body::PruneMessageBody(ref value) => {
                                let wrapper = &*value;
                                f.debug_tuple("PruneMessageBody").field(&wrapper).finish()
                            }
                            Body::RevokeMessageBody(ref value) => {
                                let wrapper = &*value;
                                f.debug_tuple("RevokeMessageBody").field(&wrapper).finish()
                            }
                            Body::MergeIdRegistryEventBody(ref value) => {
                                let wrapper = &*value;
                                f.debug_tuple("MergeIdRegistryEventBody")
                                    .field(&wrapper)
                                    .finish()
                            }
                            Body::MergeNameRegistryEventBody(ref value) => {
                                let wrapper = &*value;
                                f.debug_tuple("MergeNameRegistryEventBody")
                                    .field(&wrapper)
                                    .finish()
                            }
                            Body::MergeUsernameProofBody(ref value) => {
                                let wrapper = &*value;
                                f.debug_tuple("MergeUsernameProofBody")
                                    .field(&wrapper)
                                    .finish()
                            }
                            Body::MergeOnChainEventBody(ref value) => {
                                let wrapper = &*value;
                                f.debug_tuple("MergeOnChainEventBody")
                                    .field(&wrapper)
                                    .finish()
                            }
                        }
                    }
                }
            }
            #[repr(i32)]
            pub enum HubEventType {
                None = 0,
                MergeMessage = 1,
                PruneMessage = 2,
                RevokeMessage = 3,
                MergeIdRegistryEvent = 4,
                MergeNameRegistryEvent = 5,
                MergeUsernameProof = 6,
                /// Deprecated
                ///   HUB_EVENT_TYPE_MERGE_RENT_REGISTRY_EVENT = 7;
                ///   HUB_EVENT_TYPE_MERGE_STORAGE_ADMIN_REGISTRY_EVENT = 8;
                MergeOnChainEvent = 9,
            }
            #[automatically_derived]
            impl ::core::clone::Clone for HubEventType {
                #[inline]
                fn clone(&self) -> HubEventType {
                    *self
                }
            }
            #[automatically_derived]
            impl ::core::marker::Copy for HubEventType {}
            #[automatically_derived]
            impl ::core::fmt::Debug for HubEventType {
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    ::core::fmt::Formatter::write_str(
                        f,
                        match self {
                            HubEventType::None => "None",
                            HubEventType::MergeMessage => "MergeMessage",
                            HubEventType::PruneMessage => "PruneMessage",
                            HubEventType::RevokeMessage => "RevokeMessage",
                            HubEventType::MergeIdRegistryEvent => "MergeIdRegistryEvent",
                            HubEventType::MergeNameRegistryEvent => {
                                "MergeNameRegistryEvent"
                            }
                            HubEventType::MergeUsernameProof => "MergeUsernameProof",
                            HubEventType::MergeOnChainEvent => "MergeOnChainEvent",
                        },
                    )
                }
            }
            #[automatically_derived]
            impl ::core::marker::StructuralPartialEq for HubEventType {}
            #[automatically_derived]
            impl ::core::cmp::PartialEq for HubEventType {
                #[inline]
                fn eq(&self, other: &HubEventType) -> bool {
                    let __self_tag = ::core::intrinsics::discriminant_value(self);
                    let __arg1_tag = ::core::intrinsics::discriminant_value(other);
                    __self_tag == __arg1_tag
                }
            }
            #[automatically_derived]
            impl ::core::marker::StructuralEq for HubEventType {}
            #[automatically_derived]
            impl ::core::cmp::Eq for HubEventType {
                #[inline]
                #[doc(hidden)]
                #[no_coverage]
                fn assert_receiver_is_total_eq(&self) -> () {}
            }
            #[automatically_derived]
            impl ::core::hash::Hash for HubEventType {
                fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {
                    let __self_tag = ::core::intrinsics::discriminant_value(self);
                    ::core::hash::Hash::hash(&__self_tag, state)
                }
            }
            #[automatically_derived]
            impl ::core::cmp::PartialOrd for HubEventType {
                #[inline]
                fn partial_cmp(
                    &self,
                    other: &HubEventType,
                ) -> ::core::option::Option<::core::cmp::Ordering> {
                    let __self_tag = ::core::intrinsics::discriminant_value(self);
                    let __arg1_tag = ::core::intrinsics::discriminant_value(other);
                    ::core::cmp::PartialOrd::partial_cmp(&__self_tag, &__arg1_tag)
                }
            }
            #[automatically_derived]
            impl ::core::cmp::Ord for HubEventType {
                #[inline]
                fn cmp(&self, other: &HubEventType) -> ::core::cmp::Ordering {
                    let __self_tag = ::core::intrinsics::discriminant_value(self);
                    let __arg1_tag = ::core::intrinsics::discriminant_value(other);
                    ::core::cmp::Ord::cmp(&__self_tag, &__arg1_tag)
                }
            }
            impl HubEventType {
                ///Returns `true` if `value` is a variant of `HubEventType`.
                pub fn is_valid(value: i32) -> bool {
                    match value {
                        0 => true,
                        1 => true,
                        2 => true,
                        3 => true,
                        4 => true,
                        5 => true,
                        6 => true,
                        9 => true,
                        _ => false,
                    }
                }
                ///Converts an `i32` to a `HubEventType`, or `None` if `value` is not a valid variant.
                pub fn from_i32(value: i32) -> ::core::option::Option<HubEventType> {
                    match value {
                        0 => ::core::option::Option::Some(HubEventType::None),
                        1 => ::core::option::Option::Some(HubEventType::MergeMessage),
                        2 => ::core::option::Option::Some(HubEventType::PruneMessage),
                        3 => ::core::option::Option::Some(HubEventType::RevokeMessage),
                        4 => {
                            ::core::option::Option::Some(
                                HubEventType::MergeIdRegistryEvent,
                            )
                        }
                        5 => {
                            ::core::option::Option::Some(
                                HubEventType::MergeNameRegistryEvent,
                            )
                        }
                        6 => {
                            ::core::option::Option::Some(
                                HubEventType::MergeUsernameProof,
                            )
                        }
                        9 => {
                            ::core::option::Option::Some(HubEventType::MergeOnChainEvent)
                        }
                        _ => ::core::option::Option::None,
                    }
                }
            }
            impl ::core::default::Default for HubEventType {
                fn default() -> HubEventType {
                    HubEventType::None
                }
            }
            impl ::core::convert::From<HubEventType> for i32 {
                fn from(value: HubEventType) -> i32 {
                    value as i32
                }
            }
            impl HubEventType {
                /// String value of the enum field names used in the ProtoBuf definition.
                ///
                /// The values are not transformed in any way and thus are considered stable
                /// (if the ProtoBuf definition does not change) and safe for programmatic use.
                pub fn as_str_name(&self) -> &'static str {
                    match self {
                        HubEventType::None => "HUB_EVENT_TYPE_NONE",
                        HubEventType::MergeMessage => "HUB_EVENT_TYPE_MERGE_MESSAGE",
                        HubEventType::PruneMessage => "HUB_EVENT_TYPE_PRUNE_MESSAGE",
                        HubEventType::RevokeMessage => "HUB_EVENT_TYPE_REVOKE_MESSAGE",
                        HubEventType::MergeIdRegistryEvent => {
                            "HUB_EVENT_TYPE_MERGE_ID_REGISTRY_EVENT"
                        }
                        HubEventType::MergeNameRegistryEvent => {
                            "HUB_EVENT_TYPE_MERGE_NAME_REGISTRY_EVENT"
                        }
                        HubEventType::MergeUsernameProof => {
                            "HUB_EVENT_TYPE_MERGE_USERNAME_PROOF"
                        }
                        HubEventType::MergeOnChainEvent => {
                            "HUB_EVENT_TYPE_MERGE_ON_CHAIN_EVENT"
                        }
                    }
                }
                /// Creates an enum from field names used in the ProtoBuf definition.
                pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
                    match value {
                        "HUB_EVENT_TYPE_NONE" => Some(Self::None),
                        "HUB_EVENT_TYPE_MERGE_MESSAGE" => Some(Self::MergeMessage),
                        "HUB_EVENT_TYPE_PRUNE_MESSAGE" => Some(Self::PruneMessage),
                        "HUB_EVENT_TYPE_REVOKE_MESSAGE" => Some(Self::RevokeMessage),
                        "HUB_EVENT_TYPE_MERGE_ID_REGISTRY_EVENT" => {
                            Some(Self::MergeIdRegistryEvent)
                        }
                        "HUB_EVENT_TYPE_MERGE_NAME_REGISTRY_EVENT" => {
                            Some(Self::MergeNameRegistryEvent)
                        }
                        "HUB_EVENT_TYPE_MERGE_USERNAME_PROOF" => {
                            Some(Self::MergeUsernameProof)
                        }
                        "HUB_EVENT_TYPE_MERGE_ON_CHAIN_EVENT" => {
                            Some(Self::MergeOnChainEvent)
                        }
                        _ => None,
                    }
                }
            }
            #[allow(clippy::derive_partial_eq_without_eq)]
            pub struct HubState {
                #[prost(uint32, tag = "1")]
                pub last_eth_block: u32,
                #[prost(uint64, tag = "2")]
                pub last_fname_proof: u64,
            }
            #[automatically_derived]
            #[allow(clippy::derive_partial_eq_without_eq)]
            impl ::core::clone::Clone for HubState {
                #[inline]
                fn clone(&self) -> HubState {
                    HubState {
                        last_eth_block: ::core::clone::Clone::clone(
                            &self.last_eth_block,
                        ),
                        last_fname_proof: ::core::clone::Clone::clone(
                            &self.last_fname_proof,
                        ),
                    }
                }
            }
            #[allow(clippy::derive_partial_eq_without_eq)]
            #[automatically_derived]
            impl ::core::marker::StructuralPartialEq for HubState {}
            #[automatically_derived]
            #[allow(clippy::derive_partial_eq_without_eq)]
            impl ::core::cmp::PartialEq for HubState {
                #[inline]
                fn eq(&self, other: &HubState) -> bool {
                    self.last_eth_block == other.last_eth_block
                        && self.last_fname_proof == other.last_fname_proof
                }
            }
            impl ::prost::Message for HubState {
                #[allow(unused_variables)]
                fn encode_raw<B>(&self, buf: &mut B)
                where
                    B: ::prost::bytes::BufMut,
                {
                    if self.last_eth_block != 0u32 {
                        ::prost::encoding::uint32::encode(
                            1u32,
                            &self.last_eth_block,
                            buf,
                        );
                    }
                    if self.last_fname_proof != 0u64 {
                        ::prost::encoding::uint64::encode(
                            2u32,
                            &self.last_fname_proof,
                            buf,
                        );
                    }
                }
                #[allow(unused_variables)]
                fn merge_field<B>(
                    &mut self,
                    tag: u32,
                    wire_type: ::prost::encoding::WireType,
                    buf: &mut B,
                    ctx: ::prost::encoding::DecodeContext,
                ) -> ::core::result::Result<(), ::prost::DecodeError>
                where
                    B: ::prost::bytes::Buf,
                {
                    const STRUCT_NAME: &'static str = "HubState";
                    match tag {
                        1u32 => {
                            let mut value = &mut self.last_eth_block;
                            ::prost::encoding::uint32::merge(wire_type, value, buf, ctx)
                                .map_err(|mut error| {
                                    error.push(STRUCT_NAME, "last_eth_block");
                                    error
                                })
                        }
                        2u32 => {
                            let mut value = &mut self.last_fname_proof;
                            ::prost::encoding::uint64::merge(wire_type, value, buf, ctx)
                                .map_err(|mut error| {
                                    error.push(STRUCT_NAME, "last_fname_proof");
                                    error
                                })
                        }
                        _ => ::prost::encoding::skip_field(wire_type, tag, buf, ctx),
                    }
                }
                #[inline]
                fn encoded_len(&self) -> usize {
                    0
                        + if self.last_eth_block != 0u32 {
                            ::prost::encoding::uint32::encoded_len(
                                1u32,
                                &self.last_eth_block,
                            )
                        } else {
                            0
                        }
                        + if self.last_fname_proof != 0u64 {
                            ::prost::encoding::uint64::encoded_len(
                                2u32,
                                &self.last_fname_proof,
                            )
                        } else {
                            0
                        }
                }
                fn clear(&mut self) {
                    self.last_eth_block = 0u32;
                    self.last_fname_proof = 0u64;
                }
            }
            impl ::core::default::Default for HubState {
                fn default() -> Self {
                    HubState {
                        last_eth_block: 0u32,
                        last_fname_proof: 0u64,
                    }
                }
            }
            impl ::core::fmt::Debug for HubState {
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    let mut builder = f.debug_struct("HubState");
                    let builder = {
                        let wrapper = {
                            fn ScalarWrapper<T>(v: T) -> T {
                                v
                            }
                            ScalarWrapper(&self.last_eth_block)
                        };
                        builder.field("last_eth_block", &wrapper)
                    };
                    let builder = {
                        let wrapper = {
                            fn ScalarWrapper<T>(v: T) -> T {
                                v
                            }
                            ScalarWrapper(&self.last_fname_proof)
                        };
                        builder.field("last_fname_proof", &wrapper)
                    };
                    builder.finish()
                }
            }
            #[allow(clippy::derive_partial_eq_without_eq)]
            pub struct RevokeMessagesBySignerJobPayload {
                #[prost(uint32, tag = "1")]
                pub fid: u32,
                #[prost(bytes = "vec", tag = "2")]
                pub signer: ::prost::alloc::vec::Vec<u8>,
            }
            #[automatically_derived]
            #[allow(clippy::derive_partial_eq_without_eq)]
            impl ::core::clone::Clone for RevokeMessagesBySignerJobPayload {
                #[inline]
                fn clone(&self) -> RevokeMessagesBySignerJobPayload {
                    RevokeMessagesBySignerJobPayload {
                        fid: ::core::clone::Clone::clone(&self.fid),
                        signer: ::core::clone::Clone::clone(&self.signer),
                    }
                }
            }
            #[allow(clippy::derive_partial_eq_without_eq)]
            #[automatically_derived]
            impl ::core::marker::StructuralPartialEq
            for RevokeMessagesBySignerJobPayload {}
            #[automatically_derived]
            #[allow(clippy::derive_partial_eq_without_eq)]
            impl ::core::cmp::PartialEq for RevokeMessagesBySignerJobPayload {
                #[inline]
                fn eq(&self, other: &RevokeMessagesBySignerJobPayload) -> bool {
                    self.fid == other.fid && self.signer == other.signer
                }
            }
            impl ::prost::Message for RevokeMessagesBySignerJobPayload {
                #[allow(unused_variables)]
                fn encode_raw<B>(&self, buf: &mut B)
                where
                    B: ::prost::bytes::BufMut,
                {
                    if self.fid != 0u32 {
                        ::prost::encoding::uint32::encode(1u32, &self.fid, buf);
                    }
                    if self.signer != b"" as &[u8] {
                        ::prost::encoding::bytes::encode(2u32, &self.signer, buf);
                    }
                }
                #[allow(unused_variables)]
                fn merge_field<B>(
                    &mut self,
                    tag: u32,
                    wire_type: ::prost::encoding::WireType,
                    buf: &mut B,
                    ctx: ::prost::encoding::DecodeContext,
                ) -> ::core::result::Result<(), ::prost::DecodeError>
                where
                    B: ::prost::bytes::Buf,
                {
                    const STRUCT_NAME: &'static str = "RevokeMessagesBySignerJobPayload";
                    match tag {
                        1u32 => {
                            let mut value = &mut self.fid;
                            ::prost::encoding::uint32::merge(wire_type, value, buf, ctx)
                                .map_err(|mut error| {
                                    error.push(STRUCT_NAME, "fid");
                                    error
                                })
                        }
                        2u32 => {
                            let mut value = &mut self.signer;
                            ::prost::encoding::bytes::merge(wire_type, value, buf, ctx)
                                .map_err(|mut error| {
                                    error.push(STRUCT_NAME, "signer");
                                    error
                                })
                        }
                        _ => ::prost::encoding::skip_field(wire_type, tag, buf, ctx),
                    }
                }
                #[inline]
                fn encoded_len(&self) -> usize {
                    0
                        + if self.fid != 0u32 {
                            ::prost::encoding::uint32::encoded_len(1u32, &self.fid)
                        } else {
                            0
                        }
                        + if self.signer != b"" as &[u8] {
                            ::prost::encoding::bytes::encoded_len(2u32, &self.signer)
                        } else {
                            0
                        }
                }
                fn clear(&mut self) {
                    self.fid = 0u32;
                    self.signer.clear();
                }
            }
            impl ::core::default::Default for RevokeMessagesBySignerJobPayload {
                fn default() -> Self {
                    RevokeMessagesBySignerJobPayload {
                        fid: 0u32,
                        signer: ::core::default::Default::default(),
                    }
                }
            }
            impl ::core::fmt::Debug for RevokeMessagesBySignerJobPayload {
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    let mut builder = f.debug_struct("RevokeMessagesBySignerJobPayload");
                    let builder = {
                        let wrapper = {
                            fn ScalarWrapper<T>(v: T) -> T {
                                v
                            }
                            ScalarWrapper(&self.fid)
                        };
                        builder.field("fid", &wrapper)
                    };
                    let builder = {
                        let wrapper = {
                            fn ScalarWrapper<T>(v: T) -> T {
                                v
                            }
                            ScalarWrapper(&self.signer)
                        };
                        builder.field("signer", &wrapper)
                    };
                    builder.finish()
                }
            }
            #[allow(clippy::derive_partial_eq_without_eq)]
            pub struct UpdateNameRegistryEventExpiryJobPayload {
                #[prost(bytes = "vec", tag = "1")]
                pub fname: ::prost::alloc::vec::Vec<u8>,
            }
            #[automatically_derived]
            #[allow(clippy::derive_partial_eq_without_eq)]
            impl ::core::clone::Clone for UpdateNameRegistryEventExpiryJobPayload {
                #[inline]
                fn clone(&self) -> UpdateNameRegistryEventExpiryJobPayload {
                    UpdateNameRegistryEventExpiryJobPayload {
                        fname: ::core::clone::Clone::clone(&self.fname),
                    }
                }
            }
            #[allow(clippy::derive_partial_eq_without_eq)]
            #[automatically_derived]
            impl ::core::marker::StructuralPartialEq
            for UpdateNameRegistryEventExpiryJobPayload {}
            #[automatically_derived]
            #[allow(clippy::derive_partial_eq_without_eq)]
            impl ::core::cmp::PartialEq for UpdateNameRegistryEventExpiryJobPayload {
                #[inline]
                fn eq(&self, other: &UpdateNameRegistryEventExpiryJobPayload) -> bool {
                    self.fname == other.fname
                }
            }
            impl ::prost::Message for UpdateNameRegistryEventExpiryJobPayload {
                #[allow(unused_variables)]
                fn encode_raw<B>(&self, buf: &mut B)
                where
                    B: ::prost::bytes::BufMut,
                {
                    if self.fname != b"" as &[u8] {
                        ::prost::encoding::bytes::encode(1u32, &self.fname, buf);
                    }
                }
                #[allow(unused_variables)]
                fn merge_field<B>(
                    &mut self,
                    tag: u32,
                    wire_type: ::prost::encoding::WireType,
                    buf: &mut B,
                    ctx: ::prost::encoding::DecodeContext,
                ) -> ::core::result::Result<(), ::prost::DecodeError>
                where
                    B: ::prost::bytes::Buf,
                {
                    const STRUCT_NAME: &'static str = "UpdateNameRegistryEventExpiryJobPayload";
                    match tag {
                        1u32 => {
                            let mut value = &mut self.fname;
                            ::prost::encoding::bytes::merge(wire_type, value, buf, ctx)
                                .map_err(|mut error| {
                                    error.push(STRUCT_NAME, "fname");
                                    error
                                })
                        }
                        _ => ::prost::encoding::skip_field(wire_type, tag, buf, ctx),
                    }
                }
                #[inline]
                fn encoded_len(&self) -> usize {
                    0
                        + if self.fname != b"" as &[u8] {
                            ::prost::encoding::bytes::encoded_len(1u32, &self.fname)
                        } else {
                            0
                        }
                }
                fn clear(&mut self) {
                    self.fname.clear();
                }
            }
            impl ::core::default::Default for UpdateNameRegistryEventExpiryJobPayload {
                fn default() -> Self {
                    UpdateNameRegistryEventExpiryJobPayload {
                        fname: ::core::default::Default::default(),
                    }
                }
            }
            impl ::core::fmt::Debug for UpdateNameRegistryEventExpiryJobPayload {
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    let mut builder = f
                        .debug_struct("UpdateNameRegistryEventExpiryJobPayload");
                    let builder = {
                        let wrapper = {
                            fn ScalarWrapper<T>(v: T) -> T {
                                v
                            }
                            ScalarWrapper(&self.fname)
                        };
                        builder.field("fname", &wrapper)
                    };
                    builder.finish()
                }
            }
            #[allow(clippy::derive_partial_eq_without_eq)]
            pub struct Empty {}
            #[automatically_derived]
            #[allow(clippy::derive_partial_eq_without_eq)]
            impl ::core::clone::Clone for Empty {
                #[inline]
                fn clone(&self) -> Empty {
                    Empty {}
                }
            }
            #[allow(clippy::derive_partial_eq_without_eq)]
            #[automatically_derived]
            impl ::core::marker::StructuralPartialEq for Empty {}
            #[automatically_derived]
            #[allow(clippy::derive_partial_eq_without_eq)]
            impl ::core::cmp::PartialEq for Empty {
                #[inline]
                fn eq(&self, other: &Empty) -> bool {
                    true
                }
            }
            impl ::prost::Message for Empty {
                #[allow(unused_variables)]
                fn encode_raw<B>(&self, buf: &mut B)
                where
                    B: ::prost::bytes::BufMut,
                {}
                #[allow(unused_variables)]
                fn merge_field<B>(
                    &mut self,
                    tag: u32,
                    wire_type: ::prost::encoding::WireType,
                    buf: &mut B,
                    ctx: ::prost::encoding::DecodeContext,
                ) -> ::core::result::Result<(), ::prost::DecodeError>
                where
                    B: ::prost::bytes::Buf,
                {
                    match tag {
                        _ => ::prost::encoding::skip_field(wire_type, tag, buf, ctx),
                    }
                }
                #[inline]
                fn encoded_len(&self) -> usize {
                    0
                }
                fn clear(&mut self) {}
            }
            impl ::core::default::Default for Empty {
                fn default() -> Self {
                    Empty {}
                }
            }
            impl ::core::fmt::Debug for Empty {
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    let mut builder = f.debug_struct("Empty");
                    builder.finish()
                }
            }
            #[allow(clippy::derive_partial_eq_without_eq)]
            pub struct SubscribeRequest {
                #[prost(enumeration = "HubEventType", repeated, tag = "1")]
                pub event_types: ::prost::alloc::vec::Vec<i32>,
                #[prost(uint64, optional, tag = "2")]
                pub from_id: ::core::option::Option<u64>,
            }
            #[automatically_derived]
            #[allow(clippy::derive_partial_eq_without_eq)]
            impl ::core::clone::Clone for SubscribeRequest {
                #[inline]
                fn clone(&self) -> SubscribeRequest {
                    SubscribeRequest {
                        event_types: ::core::clone::Clone::clone(&self.event_types),
                        from_id: ::core::clone::Clone::clone(&self.from_id),
                    }
                }
            }
            #[allow(clippy::derive_partial_eq_without_eq)]
            #[automatically_derived]
            impl ::core::marker::StructuralPartialEq for SubscribeRequest {}
            #[automatically_derived]
            #[allow(clippy::derive_partial_eq_without_eq)]
            impl ::core::cmp::PartialEq for SubscribeRequest {
                #[inline]
                fn eq(&self, other: &SubscribeRequest) -> bool {
                    self.event_types == other.event_types
                        && self.from_id == other.from_id
                }
            }
            impl ::prost::Message for SubscribeRequest {
                #[allow(unused_variables)]
                fn encode_raw<B>(&self, buf: &mut B)
                where
                    B: ::prost::bytes::BufMut,
                {
                    ::prost::encoding::int32::encode_packed(
                        1u32,
                        &self.event_types,
                        buf,
                    );
                    if let ::core::option::Option::Some(ref value) = self.from_id {
                        ::prost::encoding::uint64::encode(2u32, value, buf);
                    }
                }
                #[allow(unused_variables)]
                fn merge_field<B>(
                    &mut self,
                    tag: u32,
                    wire_type: ::prost::encoding::WireType,
                    buf: &mut B,
                    ctx: ::prost::encoding::DecodeContext,
                ) -> ::core::result::Result<(), ::prost::DecodeError>
                where
                    B: ::prost::bytes::Buf,
                {
                    const STRUCT_NAME: &'static str = "SubscribeRequest";
                    match tag {
                        1u32 => {
                            let mut value = &mut self.event_types;
                            ::prost::encoding::int32::merge_repeated(
                                    wire_type,
                                    value,
                                    buf,
                                    ctx,
                                )
                                .map_err(|mut error| {
                                    error.push(STRUCT_NAME, "event_types");
                                    error
                                })
                        }
                        2u32 => {
                            let mut value = &mut self.from_id;
                            ::prost::encoding::uint64::merge(
                                    wire_type,
                                    value.get_or_insert_with(::core::default::Default::default),
                                    buf,
                                    ctx,
                                )
                                .map_err(|mut error| {
                                    error.push(STRUCT_NAME, "from_id");
                                    error
                                })
                        }
                        _ => ::prost::encoding::skip_field(wire_type, tag, buf, ctx),
                    }
                }
                #[inline]
                fn encoded_len(&self) -> usize {
                    0
                        + ::prost::encoding::int32::encoded_len_packed(
                            1u32,
                            &self.event_types,
                        )
                        + self
                            .from_id
                            .as_ref()
                            .map_or(
                                0,
                                |value| ::prost::encoding::uint64::encoded_len(2u32, value),
                            )
                }
                fn clear(&mut self) {
                    self.event_types.clear();
                    self.from_id = ::core::option::Option::None;
                }
            }
            impl ::core::default::Default for SubscribeRequest {
                fn default() -> Self {
                    SubscribeRequest {
                        event_types: ::prost::alloc::vec::Vec::new(),
                        from_id: ::core::option::Option::None,
                    }
                }
            }
            impl ::core::fmt::Debug for SubscribeRequest {
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    let mut builder = f.debug_struct("SubscribeRequest");
                    let builder = {
                        let wrapper = {
                            struct ScalarWrapper<'a>(&'a ::prost::alloc::vec::Vec<i32>);
                            impl<'a> ::core::fmt::Debug for ScalarWrapper<'a> {
                                fn fmt(
                                    &self,
                                    f: &mut ::core::fmt::Formatter,
                                ) -> ::core::fmt::Result {
                                    let mut vec_builder = f.debug_list();
                                    for v in self.0 {
                                        struct Inner<'a>(&'a i32);
                                        impl<'a> ::core::fmt::Debug for Inner<'a> {
                                            fn fmt(
                                                &self,
                                                f: &mut ::core::fmt::Formatter,
                                            ) -> ::core::fmt::Result {
                                                match HubEventType::from_i32(*self.0) {
                                                    None => ::core::fmt::Debug::fmt(&self.0, f),
                                                    Some(en) => ::core::fmt::Debug::fmt(&en, f),
                                                }
                                            }
                                        }
                                        vec_builder.entry(&Inner(v));
                                    }
                                    vec_builder.finish()
                                }
                            }
                            ScalarWrapper(&self.event_types)
                        };
                        builder.field("event_types", &wrapper)
                    };
                    let builder = {
                        let wrapper = {
                            struct ScalarWrapper<'a>(&'a ::core::option::Option<u64>);
                            impl<'a> ::core::fmt::Debug for ScalarWrapper<'a> {
                                fn fmt(
                                    &self,
                                    f: &mut ::core::fmt::Formatter,
                                ) -> ::core::fmt::Result {
                                    fn Inner<T>(v: T) -> T {
                                        v
                                    }
                                    ::core::fmt::Debug::fmt(&self.0.as_ref().map(Inner), f)
                                }
                            }
                            ScalarWrapper(&self.from_id)
                        };
                        builder.field("from_id", &wrapper)
                    };
                    builder.finish()
                }
            }
            #[allow(dead_code)]
            impl SubscribeRequest {
                ///Returns an iterator which yields the valid enum values contained in `event_types`.
                pub fn event_types(
                    &self,
                ) -> ::core::iter::FilterMap<
                    ::core::iter::Cloned<::core::slice::Iter<i32>>,
                    fn(i32) -> ::core::option::Option<HubEventType>,
                > {
                    self.event_types.iter().cloned().filter_map(HubEventType::from_i32)
                }
                ///Appends the provided enum value to `event_types`.
                pub fn push_event_types(&mut self, value: HubEventType) {
                    self.event_types.push(value as i32);
                }
                ///Returns the value of `from_id`, or the default value if `from_id` is unset.
                pub fn from_id(&self) -> u64 {
                    match self.from_id {
                        ::core::option::Option::Some(val) => val,
                        ::core::option::Option::None => 0u64,
                    }
                }
            }
            #[allow(clippy::derive_partial_eq_without_eq)]
            pub struct EventRequest {
                #[prost(uint64, tag = "1")]
                pub id: u64,
            }
            #[automatically_derived]
            #[allow(clippy::derive_partial_eq_without_eq)]
            impl ::core::clone::Clone for EventRequest {
                #[inline]
                fn clone(&self) -> EventRequest {
                    EventRequest {
                        id: ::core::clone::Clone::clone(&self.id),
                    }
                }
            }
            #[allow(clippy::derive_partial_eq_without_eq)]
            #[automatically_derived]
            impl ::core::marker::StructuralPartialEq for EventRequest {}
            #[automatically_derived]
            #[allow(clippy::derive_partial_eq_without_eq)]
            impl ::core::cmp::PartialEq for EventRequest {
                #[inline]
                fn eq(&self, other: &EventRequest) -> bool {
                    self.id == other.id
                }
            }
            impl ::prost::Message for EventRequest {
                #[allow(unused_variables)]
                fn encode_raw<B>(&self, buf: &mut B)
                where
                    B: ::prost::bytes::BufMut,
                {
                    if self.id != 0u64 {
                        ::prost::encoding::uint64::encode(1u32, &self.id, buf);
                    }
                }
                #[allow(unused_variables)]
                fn merge_field<B>(
                    &mut self,
                    tag: u32,
                    wire_type: ::prost::encoding::WireType,
                    buf: &mut B,
                    ctx: ::prost::encoding::DecodeContext,
                ) -> ::core::result::Result<(), ::prost::DecodeError>
                where
                    B: ::prost::bytes::Buf,
                {
                    const STRUCT_NAME: &'static str = "EventRequest";
                    match tag {
                        1u32 => {
                            let mut value = &mut self.id;
                            ::prost::encoding::uint64::merge(wire_type, value, buf, ctx)
                                .map_err(|mut error| {
                                    error.push(STRUCT_NAME, "id");
                                    error
                                })
                        }
                        _ => ::prost::encoding::skip_field(wire_type, tag, buf, ctx),
                    }
                }
                #[inline]
                fn encoded_len(&self) -> usize {
                    0
                        + if self.id != 0u64 {
                            ::prost::encoding::uint64::encoded_len(1u32, &self.id)
                        } else {
                            0
                        }
                }
                fn clear(&mut self) {
                    self.id = 0u64;
                }
            }
            impl ::core::default::Default for EventRequest {
                fn default() -> Self {
                    EventRequest { id: 0u64 }
                }
            }
            impl ::core::fmt::Debug for EventRequest {
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    let mut builder = f.debug_struct("EventRequest");
                    let builder = {
                        let wrapper = {
                            fn ScalarWrapper<T>(v: T) -> T {
                                v
                            }
                            ScalarWrapper(&self.id)
                        };
                        builder.field("id", &wrapper)
                    };
                    builder.finish()
                }
            }
            #[allow(clippy::derive_partial_eq_without_eq)]
            pub struct HubInfoRequest {
                #[prost(bool, tag = "1")]
                pub db_stats: bool,
            }
            #[automatically_derived]
            #[allow(clippy::derive_partial_eq_without_eq)]
            impl ::core::clone::Clone for HubInfoRequest {
                #[inline]
                fn clone(&self) -> HubInfoRequest {
                    HubInfoRequest {
                        db_stats: ::core::clone::Clone::clone(&self.db_stats),
                    }
                }
            }
            #[allow(clippy::derive_partial_eq_without_eq)]
            #[automatically_derived]
            impl ::core::marker::StructuralPartialEq for HubInfoRequest {}
            #[automatically_derived]
            #[allow(clippy::derive_partial_eq_without_eq)]
            impl ::core::cmp::PartialEq for HubInfoRequest {
                #[inline]
                fn eq(&self, other: &HubInfoRequest) -> bool {
                    self.db_stats == other.db_stats
                }
            }
            impl ::prost::Message for HubInfoRequest {
                #[allow(unused_variables)]
                fn encode_raw<B>(&self, buf: &mut B)
                where
                    B: ::prost::bytes::BufMut,
                {
                    if self.db_stats != false {
                        ::prost::encoding::bool::encode(1u32, &self.db_stats, buf);
                    }
                }
                #[allow(unused_variables)]
                fn merge_field<B>(
                    &mut self,
                    tag: u32,
                    wire_type: ::prost::encoding::WireType,
                    buf: &mut B,
                    ctx: ::prost::encoding::DecodeContext,
                ) -> ::core::result::Result<(), ::prost::DecodeError>
                where
                    B: ::prost::bytes::Buf,
                {
                    const STRUCT_NAME: &'static str = "HubInfoRequest";
                    match tag {
                        1u32 => {
                            let mut value = &mut self.db_stats;
                            ::prost::encoding::bool::merge(wire_type, value, buf, ctx)
                                .map_err(|mut error| {
                                    error.push(STRUCT_NAME, "db_stats");
                                    error
                                })
                        }
                        _ => ::prost::encoding::skip_field(wire_type, tag, buf, ctx),
                    }
                }
                #[inline]
                fn encoded_len(&self) -> usize {
                    0
                        + if self.db_stats != false {
                            ::prost::encoding::bool::encoded_len(1u32, &self.db_stats)
                        } else {
                            0
                        }
                }
                fn clear(&mut self) {
                    self.db_stats = false;
                }
            }
            impl ::core::default::Default for HubInfoRequest {
                fn default() -> Self {
                    HubInfoRequest { db_stats: false }
                }
            }
            impl ::core::fmt::Debug for HubInfoRequest {
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    let mut builder = f.debug_struct("HubInfoRequest");
                    let builder = {
                        let wrapper = {
                            fn ScalarWrapper<T>(v: T) -> T {
                                v
                            }
                            ScalarWrapper(&self.db_stats)
                        };
                        builder.field("db_stats", &wrapper)
                    };
                    builder.finish()
                }
            }
            /// Response Types for the Sync RPC Methods
            #[allow(clippy::derive_partial_eq_without_eq)]
            pub struct HubInfoResponse {
                #[prost(string, tag = "1")]
                pub version: ::prost::alloc::string::String,
                #[prost(bool, tag = "2")]
                pub is_syncing: bool,
                #[prost(string, tag = "3")]
                pub nickname: ::prost::alloc::string::String,
                #[prost(string, tag = "4")]
                pub root_hash: ::prost::alloc::string::String,
                #[prost(message, optional, tag = "5")]
                pub db_stats: ::core::option::Option<DbStats>,
            }
            #[automatically_derived]
            #[allow(clippy::derive_partial_eq_without_eq)]
            impl ::core::clone::Clone for HubInfoResponse {
                #[inline]
                fn clone(&self) -> HubInfoResponse {
                    HubInfoResponse {
                        version: ::core::clone::Clone::clone(&self.version),
                        is_syncing: ::core::clone::Clone::clone(&self.is_syncing),
                        nickname: ::core::clone::Clone::clone(&self.nickname),
                        root_hash: ::core::clone::Clone::clone(&self.root_hash),
                        db_stats: ::core::clone::Clone::clone(&self.db_stats),
                    }
                }
            }
            #[allow(clippy::derive_partial_eq_without_eq)]
            #[automatically_derived]
            impl ::core::marker::StructuralPartialEq for HubInfoResponse {}
            #[automatically_derived]
            #[allow(clippy::derive_partial_eq_without_eq)]
            impl ::core::cmp::PartialEq for HubInfoResponse {
                #[inline]
                fn eq(&self, other: &HubInfoResponse) -> bool {
                    self.version == other.version && self.is_syncing == other.is_syncing
                        && self.nickname == other.nickname
                        && self.root_hash == other.root_hash
                        && self.db_stats == other.db_stats
                }
            }
            impl ::prost::Message for HubInfoResponse {
                #[allow(unused_variables)]
                fn encode_raw<B>(&self, buf: &mut B)
                where
                    B: ::prost::bytes::BufMut,
                {
                    if self.version != "" {
                        ::prost::encoding::string::encode(1u32, &self.version, buf);
                    }
                    if self.is_syncing != false {
                        ::prost::encoding::bool::encode(2u32, &self.is_syncing, buf);
                    }
                    if self.nickname != "" {
                        ::prost::encoding::string::encode(3u32, &self.nickname, buf);
                    }
                    if self.root_hash != "" {
                        ::prost::encoding::string::encode(4u32, &self.root_hash, buf);
                    }
                    if let Some(ref msg) = self.db_stats {
                        ::prost::encoding::message::encode(5u32, msg, buf);
                    }
                }
                #[allow(unused_variables)]
                fn merge_field<B>(
                    &mut self,
                    tag: u32,
                    wire_type: ::prost::encoding::WireType,
                    buf: &mut B,
                    ctx: ::prost::encoding::DecodeContext,
                ) -> ::core::result::Result<(), ::prost::DecodeError>
                where
                    B: ::prost::bytes::Buf,
                {
                    const STRUCT_NAME: &'static str = "HubInfoResponse";
                    match tag {
                        1u32 => {
                            let mut value = &mut self.version;
                            ::prost::encoding::string::merge(wire_type, value, buf, ctx)
                                .map_err(|mut error| {
                                    error.push(STRUCT_NAME, "version");
                                    error
                                })
                        }
                        2u32 => {
                            let mut value = &mut self.is_syncing;
                            ::prost::encoding::bool::merge(wire_type, value, buf, ctx)
                                .map_err(|mut error| {
                                    error.push(STRUCT_NAME, "is_syncing");
                                    error
                                })
                        }
                        3u32 => {
                            let mut value = &mut self.nickname;
                            ::prost::encoding::string::merge(wire_type, value, buf, ctx)
                                .map_err(|mut error| {
                                    error.push(STRUCT_NAME, "nickname");
                                    error
                                })
                        }
                        4u32 => {
                            let mut value = &mut self.root_hash;
                            ::prost::encoding::string::merge(wire_type, value, buf, ctx)
                                .map_err(|mut error| {
                                    error.push(STRUCT_NAME, "root_hash");
                                    error
                                })
                        }
                        5u32 => {
                            let mut value = &mut self.db_stats;
                            ::prost::encoding::message::merge(
                                    wire_type,
                                    value.get_or_insert_with(::core::default::Default::default),
                                    buf,
                                    ctx,
                                )
                                .map_err(|mut error| {
                                    error.push(STRUCT_NAME, "db_stats");
                                    error
                                })
                        }
                        _ => ::prost::encoding::skip_field(wire_type, tag, buf, ctx),
                    }
                }
                #[inline]
                fn encoded_len(&self) -> usize {
                    0
                        + if self.version != "" {
                            ::prost::encoding::string::encoded_len(1u32, &self.version)
                        } else {
                            0
                        }
                        + if self.is_syncing != false {
                            ::prost::encoding::bool::encoded_len(2u32, &self.is_syncing)
                        } else {
                            0
                        }
                        + if self.nickname != "" {
                            ::prost::encoding::string::encoded_len(3u32, &self.nickname)
                        } else {
                            0
                        }
                        + if self.root_hash != "" {
                            ::prost::encoding::string::encoded_len(4u32, &self.root_hash)
                        } else {
                            0
                        }
                        + self
                            .db_stats
                            .as_ref()
                            .map_or(
                                0,
                                |msg| ::prost::encoding::message::encoded_len(5u32, msg),
                            )
                }
                fn clear(&mut self) {
                    self.version.clear();
                    self.is_syncing = false;
                    self.nickname.clear();
                    self.root_hash.clear();
                    self.db_stats = ::core::option::Option::None;
                }
            }
            impl ::core::default::Default for HubInfoResponse {
                fn default() -> Self {
                    HubInfoResponse {
                        version: ::prost::alloc::string::String::new(),
                        is_syncing: false,
                        nickname: ::prost::alloc::string::String::new(),
                        root_hash: ::prost::alloc::string::String::new(),
                        db_stats: ::core::default::Default::default(),
                    }
                }
            }
            impl ::core::fmt::Debug for HubInfoResponse {
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    let mut builder = f.debug_struct("HubInfoResponse");
                    let builder = {
                        let wrapper = {
                            fn ScalarWrapper<T>(v: T) -> T {
                                v
                            }
                            ScalarWrapper(&self.version)
                        };
                        builder.field("version", &wrapper)
                    };
                    let builder = {
                        let wrapper = {
                            fn ScalarWrapper<T>(v: T) -> T {
                                v
                            }
                            ScalarWrapper(&self.is_syncing)
                        };
                        builder.field("is_syncing", &wrapper)
                    };
                    let builder = {
                        let wrapper = {
                            fn ScalarWrapper<T>(v: T) -> T {
                                v
                            }
                            ScalarWrapper(&self.nickname)
                        };
                        builder.field("nickname", &wrapper)
                    };
                    let builder = {
                        let wrapper = {
                            fn ScalarWrapper<T>(v: T) -> T {
                                v
                            }
                            ScalarWrapper(&self.root_hash)
                        };
                        builder.field("root_hash", &wrapper)
                    };
                    let builder = {
                        let wrapper = &self.db_stats;
                        builder.field("db_stats", &wrapper)
                    };
                    builder.finish()
                }
            }
            #[allow(clippy::derive_partial_eq_without_eq)]
            pub struct DbStats {
                #[prost(uint64, tag = "1")]
                pub num_messages: u64,
                #[prost(uint64, tag = "2")]
                pub num_fid_events: u64,
                #[prost(uint64, tag = "3")]
                pub num_fname_events: u64,
            }
            #[automatically_derived]
            #[allow(clippy::derive_partial_eq_without_eq)]
            impl ::core::clone::Clone for DbStats {
                #[inline]
                fn clone(&self) -> DbStats {
                    DbStats {
                        num_messages: ::core::clone::Clone::clone(&self.num_messages),
                        num_fid_events: ::core::clone::Clone::clone(
                            &self.num_fid_events,
                        ),
                        num_fname_events: ::core::clone::Clone::clone(
                            &self.num_fname_events,
                        ),
                    }
                }
            }
            #[allow(clippy::derive_partial_eq_without_eq)]
            #[automatically_derived]
            impl ::core::marker::StructuralPartialEq for DbStats {}
            #[automatically_derived]
            #[allow(clippy::derive_partial_eq_without_eq)]
            impl ::core::cmp::PartialEq for DbStats {
                #[inline]
                fn eq(&self, other: &DbStats) -> bool {
                    self.num_messages == other.num_messages
                        && self.num_fid_events == other.num_fid_events
                        && self.num_fname_events == other.num_fname_events
                }
            }
            impl ::prost::Message for DbStats {
                #[allow(unused_variables)]
                fn encode_raw<B>(&self, buf: &mut B)
                where
                    B: ::prost::bytes::BufMut,
                {
                    if self.num_messages != 0u64 {
                        ::prost::encoding::uint64::encode(1u32, &self.num_messages, buf);
                    }
                    if self.num_fid_events != 0u64 {
                        ::prost::encoding::uint64::encode(
                            2u32,
                            &self.num_fid_events,
                            buf,
                        );
                    }
                    if self.num_fname_events != 0u64 {
                        ::prost::encoding::uint64::encode(
                            3u32,
                            &self.num_fname_events,
                            buf,
                        );
                    }
                }
                #[allow(unused_variables)]
                fn merge_field<B>(
                    &mut self,
                    tag: u32,
                    wire_type: ::prost::encoding::WireType,
                    buf: &mut B,
                    ctx: ::prost::encoding::DecodeContext,
                ) -> ::core::result::Result<(), ::prost::DecodeError>
                where
                    B: ::prost::bytes::Buf,
                {
                    const STRUCT_NAME: &'static str = "DbStats";
                    match tag {
                        1u32 => {
                            let mut value = &mut self.num_messages;
                            ::prost::encoding::uint64::merge(wire_type, value, buf, ctx)
                                .map_err(|mut error| {
                                    error.push(STRUCT_NAME, "num_messages");
                                    error
                                })
                        }
                        2u32 => {
                            let mut value = &mut self.num_fid_events;
                            ::prost::encoding::uint64::merge(wire_type, value, buf, ctx)
                                .map_err(|mut error| {
                                    error.push(STRUCT_NAME, "num_fid_events");
                                    error
                                })
                        }
                        3u32 => {
                            let mut value = &mut self.num_fname_events;
                            ::prost::encoding::uint64::merge(wire_type, value, buf, ctx)
                                .map_err(|mut error| {
                                    error.push(STRUCT_NAME, "num_fname_events");
                                    error
                                })
                        }
                        _ => ::prost::encoding::skip_field(wire_type, tag, buf, ctx),
                    }
                }
                #[inline]
                fn encoded_len(&self) -> usize {
                    0
                        + if self.num_messages != 0u64 {
                            ::prost::encoding::uint64::encoded_len(
                                1u32,
                                &self.num_messages,
                            )
                        } else {
                            0
                        }
                        + if self.num_fid_events != 0u64 {
                            ::prost::encoding::uint64::encoded_len(
                                2u32,
                                &self.num_fid_events,
                            )
                        } else {
                            0
                        }
                        + if self.num_fname_events != 0u64 {
                            ::prost::encoding::uint64::encoded_len(
                                3u32,
                                &self.num_fname_events,
                            )
                        } else {
                            0
                        }
                }
                fn clear(&mut self) {
                    self.num_messages = 0u64;
                    self.num_fid_events = 0u64;
                    self.num_fname_events = 0u64;
                }
            }
            impl ::core::default::Default for DbStats {
                fn default() -> Self {
                    DbStats {
                        num_messages: 0u64,
                        num_fid_events: 0u64,
                        num_fname_events: 0u64,
                    }
                }
            }
            impl ::core::fmt::Debug for DbStats {
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    let mut builder = f.debug_struct("DbStats");
                    let builder = {
                        let wrapper = {
                            fn ScalarWrapper<T>(v: T) -> T {
                                v
                            }
                            ScalarWrapper(&self.num_messages)
                        };
                        builder.field("num_messages", &wrapper)
                    };
                    let builder = {
                        let wrapper = {
                            fn ScalarWrapper<T>(v: T) -> T {
                                v
                            }
                            ScalarWrapper(&self.num_fid_events)
                        };
                        builder.field("num_fid_events", &wrapper)
                    };
                    let builder = {
                        let wrapper = {
                            fn ScalarWrapper<T>(v: T) -> T {
                                v
                            }
                            ScalarWrapper(&self.num_fname_events)
                        };
                        builder.field("num_fname_events", &wrapper)
                    };
                    builder.finish()
                }
            }
            #[allow(clippy::derive_partial_eq_without_eq)]
            pub struct SyncStatusRequest {
                #[prost(string, optional, tag = "1")]
                pub peer_id: ::core::option::Option<::prost::alloc::string::String>,
            }
            #[automatically_derived]
            #[allow(clippy::derive_partial_eq_without_eq)]
            impl ::core::clone::Clone for SyncStatusRequest {
                #[inline]
                fn clone(&self) -> SyncStatusRequest {
                    SyncStatusRequest {
                        peer_id: ::core::clone::Clone::clone(&self.peer_id),
                    }
                }
            }
            #[allow(clippy::derive_partial_eq_without_eq)]
            #[automatically_derived]
            impl ::core::marker::StructuralPartialEq for SyncStatusRequest {}
            #[automatically_derived]
            #[allow(clippy::derive_partial_eq_without_eq)]
            impl ::core::cmp::PartialEq for SyncStatusRequest {
                #[inline]
                fn eq(&self, other: &SyncStatusRequest) -> bool {
                    self.peer_id == other.peer_id
                }
            }
            impl ::prost::Message for SyncStatusRequest {
                #[allow(unused_variables)]
                fn encode_raw<B>(&self, buf: &mut B)
                where
                    B: ::prost::bytes::BufMut,
                {
                    if let ::core::option::Option::Some(ref value) = self.peer_id {
                        ::prost::encoding::string::encode(1u32, value, buf);
                    }
                }
                #[allow(unused_variables)]
                fn merge_field<B>(
                    &mut self,
                    tag: u32,
                    wire_type: ::prost::encoding::WireType,
                    buf: &mut B,
                    ctx: ::prost::encoding::DecodeContext,
                ) -> ::core::result::Result<(), ::prost::DecodeError>
                where
                    B: ::prost::bytes::Buf,
                {
                    const STRUCT_NAME: &'static str = "SyncStatusRequest";
                    match tag {
                        1u32 => {
                            let mut value = &mut self.peer_id;
                            ::prost::encoding::string::merge(
                                    wire_type,
                                    value.get_or_insert_with(::core::default::Default::default),
                                    buf,
                                    ctx,
                                )
                                .map_err(|mut error| {
                                    error.push(STRUCT_NAME, "peer_id");
                                    error
                                })
                        }
                        _ => ::prost::encoding::skip_field(wire_type, tag, buf, ctx),
                    }
                }
                #[inline]
                fn encoded_len(&self) -> usize {
                    0
                        + self
                            .peer_id
                            .as_ref()
                            .map_or(
                                0,
                                |value| ::prost::encoding::string::encoded_len(1u32, value),
                            )
                }
                fn clear(&mut self) {
                    self.peer_id = ::core::option::Option::None;
                }
            }
            impl ::core::default::Default for SyncStatusRequest {
                fn default() -> Self {
                    SyncStatusRequest {
                        peer_id: ::core::option::Option::None,
                    }
                }
            }
            impl ::core::fmt::Debug for SyncStatusRequest {
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    let mut builder = f.debug_struct("SyncStatusRequest");
                    let builder = {
                        let wrapper = {
                            struct ScalarWrapper<'a>(
                                &'a ::core::option::Option<::prost::alloc::string::String>,
                            );
                            impl<'a> ::core::fmt::Debug for ScalarWrapper<'a> {
                                fn fmt(
                                    &self,
                                    f: &mut ::core::fmt::Formatter,
                                ) -> ::core::fmt::Result {
                                    fn Inner<T>(v: T) -> T {
                                        v
                                    }
                                    ::core::fmt::Debug::fmt(&self.0.as_ref().map(Inner), f)
                                }
                            }
                            ScalarWrapper(&self.peer_id)
                        };
                        builder.field("peer_id", &wrapper)
                    };
                    builder.finish()
                }
            }
            #[allow(dead_code)]
            impl SyncStatusRequest {
                ///Returns the value of `peer_id`, or the default value if `peer_id` is unset.
                pub fn peer_id(&self) -> &str {
                    match self.peer_id {
                        ::core::option::Option::Some(ref val) => &val[..],
                        ::core::option::Option::None => "",
                    }
                }
            }
            #[allow(clippy::derive_partial_eq_without_eq)]
            pub struct SyncStatusResponse {
                #[prost(bool, tag = "1")]
                pub is_syncing: bool,
                #[prost(message, repeated, tag = "2")]
                pub sync_status: ::prost::alloc::vec::Vec<SyncStatus>,
            }
            #[automatically_derived]
            #[allow(clippy::derive_partial_eq_without_eq)]
            impl ::core::clone::Clone for SyncStatusResponse {
                #[inline]
                fn clone(&self) -> SyncStatusResponse {
                    SyncStatusResponse {
                        is_syncing: ::core::clone::Clone::clone(&self.is_syncing),
                        sync_status: ::core::clone::Clone::clone(&self.sync_status),
                    }
                }
            }
            #[allow(clippy::derive_partial_eq_without_eq)]
            #[automatically_derived]
            impl ::core::marker::StructuralPartialEq for SyncStatusResponse {}
            #[automatically_derived]
            #[allow(clippy::derive_partial_eq_without_eq)]
            impl ::core::cmp::PartialEq for SyncStatusResponse {
                #[inline]
                fn eq(&self, other: &SyncStatusResponse) -> bool {
                    self.is_syncing == other.is_syncing
                        && self.sync_status == other.sync_status
                }
            }
            impl ::prost::Message for SyncStatusResponse {
                #[allow(unused_variables)]
                fn encode_raw<B>(&self, buf: &mut B)
                where
                    B: ::prost::bytes::BufMut,
                {
                    if self.is_syncing != false {
                        ::prost::encoding::bool::encode(1u32, &self.is_syncing, buf);
                    }
                    for msg in &self.sync_status {
                        ::prost::encoding::message::encode(2u32, msg, buf);
                    }
                }
                #[allow(unused_variables)]
                fn merge_field<B>(
                    &mut self,
                    tag: u32,
                    wire_type: ::prost::encoding::WireType,
                    buf: &mut B,
                    ctx: ::prost::encoding::DecodeContext,
                ) -> ::core::result::Result<(), ::prost::DecodeError>
                where
                    B: ::prost::bytes::Buf,
                {
                    const STRUCT_NAME: &'static str = "SyncStatusResponse";
                    match tag {
                        1u32 => {
                            let mut value = &mut self.is_syncing;
                            ::prost::encoding::bool::merge(wire_type, value, buf, ctx)
                                .map_err(|mut error| {
                                    error.push(STRUCT_NAME, "is_syncing");
                                    error
                                })
                        }
                        2u32 => {
                            let mut value = &mut self.sync_status;
                            ::prost::encoding::message::merge_repeated(
                                    wire_type,
                                    value,
                                    buf,
                                    ctx,
                                )
                                .map_err(|mut error| {
                                    error.push(STRUCT_NAME, "sync_status");
                                    error
                                })
                        }
                        _ => ::prost::encoding::skip_field(wire_type, tag, buf, ctx),
                    }
                }
                #[inline]
                fn encoded_len(&self) -> usize {
                    0
                        + if self.is_syncing != false {
                            ::prost::encoding::bool::encoded_len(1u32, &self.is_syncing)
                        } else {
                            0
                        }
                        + ::prost::encoding::message::encoded_len_repeated(
                            2u32,
                            &self.sync_status,
                        )
                }
                fn clear(&mut self) {
                    self.is_syncing = false;
                    self.sync_status.clear();
                }
            }
            impl ::core::default::Default for SyncStatusResponse {
                fn default() -> Self {
                    SyncStatusResponse {
                        is_syncing: false,
                        sync_status: ::core::default::Default::default(),
                    }
                }
            }
            impl ::core::fmt::Debug for SyncStatusResponse {
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    let mut builder = f.debug_struct("SyncStatusResponse");
                    let builder = {
                        let wrapper = {
                            fn ScalarWrapper<T>(v: T) -> T {
                                v
                            }
                            ScalarWrapper(&self.is_syncing)
                        };
                        builder.field("is_syncing", &wrapper)
                    };
                    let builder = {
                        let wrapper = &self.sync_status;
                        builder.field("sync_status", &wrapper)
                    };
                    builder.finish()
                }
            }
            #[allow(clippy::derive_partial_eq_without_eq)]
            pub struct SyncStatus {
                #[prost(string, tag = "1")]
                pub peer_id: ::prost::alloc::string::String,
                #[prost(string, tag = "2")]
                pub in_sync: ::prost::alloc::string::String,
                #[prost(bool, tag = "3")]
                pub should_sync: bool,
                #[prost(string, tag = "4")]
                pub divergence_prefix: ::prost::alloc::string::String,
                #[prost(int32, tag = "5")]
                pub divergence_seconds_ago: i32,
                #[prost(uint64, tag = "6")]
                pub their_messages: u64,
                #[prost(uint64, tag = "7")]
                pub our_messages: u64,
                #[prost(int64, tag = "8")]
                pub last_bad_sync: i64,
            }
            #[automatically_derived]
            #[allow(clippy::derive_partial_eq_without_eq)]
            impl ::core::clone::Clone for SyncStatus {
                #[inline]
                fn clone(&self) -> SyncStatus {
                    SyncStatus {
                        peer_id: ::core::clone::Clone::clone(&self.peer_id),
                        in_sync: ::core::clone::Clone::clone(&self.in_sync),
                        should_sync: ::core::clone::Clone::clone(&self.should_sync),
                        divergence_prefix: ::core::clone::Clone::clone(
                            &self.divergence_prefix,
                        ),
                        divergence_seconds_ago: ::core::clone::Clone::clone(
                            &self.divergence_seconds_ago,
                        ),
                        their_messages: ::core::clone::Clone::clone(
                            &self.their_messages,
                        ),
                        our_messages: ::core::clone::Clone::clone(&self.our_messages),
                        last_bad_sync: ::core::clone::Clone::clone(&self.last_bad_sync),
                    }
                }
            }
            #[allow(clippy::derive_partial_eq_without_eq)]
            #[automatically_derived]
            impl ::core::marker::StructuralPartialEq for SyncStatus {}
            #[automatically_derived]
            #[allow(clippy::derive_partial_eq_without_eq)]
            impl ::core::cmp::PartialEq for SyncStatus {
                #[inline]
                fn eq(&self, other: &SyncStatus) -> bool {
                    self.peer_id == other.peer_id && self.in_sync == other.in_sync
                        && self.should_sync == other.should_sync
                        && self.divergence_prefix == other.divergence_prefix
                        && self.divergence_seconds_ago == other.divergence_seconds_ago
                        && self.their_messages == other.their_messages
                        && self.our_messages == other.our_messages
                        && self.last_bad_sync == other.last_bad_sync
                }
            }
            impl ::prost::Message for SyncStatus {
                #[allow(unused_variables)]
                fn encode_raw<B>(&self, buf: &mut B)
                where
                    B: ::prost::bytes::BufMut,
                {
                    if self.peer_id != "" {
                        ::prost::encoding::string::encode(1u32, &self.peer_id, buf);
                    }
                    if self.in_sync != "" {
                        ::prost::encoding::string::encode(2u32, &self.in_sync, buf);
                    }
                    if self.should_sync != false {
                        ::prost::encoding::bool::encode(3u32, &self.should_sync, buf);
                    }
                    if self.divergence_prefix != "" {
                        ::prost::encoding::string::encode(
                            4u32,
                            &self.divergence_prefix,
                            buf,
                        );
                    }
                    if self.divergence_seconds_ago != 0i32 {
                        ::prost::encoding::int32::encode(
                            5u32,
                            &self.divergence_seconds_ago,
                            buf,
                        );
                    }
                    if self.their_messages != 0u64 {
                        ::prost::encoding::uint64::encode(
                            6u32,
                            &self.their_messages,
                            buf,
                        );
                    }
                    if self.our_messages != 0u64 {
                        ::prost::encoding::uint64::encode(7u32, &self.our_messages, buf);
                    }
                    if self.last_bad_sync != 0i64 {
                        ::prost::encoding::int64::encode(8u32, &self.last_bad_sync, buf);
                    }
                }
                #[allow(unused_variables)]
                fn merge_field<B>(
                    &mut self,
                    tag: u32,
                    wire_type: ::prost::encoding::WireType,
                    buf: &mut B,
                    ctx: ::prost::encoding::DecodeContext,
                ) -> ::core::result::Result<(), ::prost::DecodeError>
                where
                    B: ::prost::bytes::Buf,
                {
                    const STRUCT_NAME: &'static str = "SyncStatus";
                    match tag {
                        1u32 => {
                            let mut value = &mut self.peer_id;
                            ::prost::encoding::string::merge(wire_type, value, buf, ctx)
                                .map_err(|mut error| {
                                    error.push(STRUCT_NAME, "peer_id");
                                    error
                                })
                        }
                        2u32 => {
                            let mut value = &mut self.in_sync;
                            ::prost::encoding::string::merge(wire_type, value, buf, ctx)
                                .map_err(|mut error| {
                                    error.push(STRUCT_NAME, "in_sync");
                                    error
                                })
                        }
                        3u32 => {
                            let mut value = &mut self.should_sync;
                            ::prost::encoding::bool::merge(wire_type, value, buf, ctx)
                                .map_err(|mut error| {
                                    error.push(STRUCT_NAME, "should_sync");
                                    error
                                })
                        }
                        4u32 => {
                            let mut value = &mut self.divergence_prefix;
                            ::prost::encoding::string::merge(wire_type, value, buf, ctx)
                                .map_err(|mut error| {
                                    error.push(STRUCT_NAME, "divergence_prefix");
                                    error
                                })
                        }
                        5u32 => {
                            let mut value = &mut self.divergence_seconds_ago;
                            ::prost::encoding::int32::merge(wire_type, value, buf, ctx)
                                .map_err(|mut error| {
                                    error.push(STRUCT_NAME, "divergence_seconds_ago");
                                    error
                                })
                        }
                        6u32 => {
                            let mut value = &mut self.their_messages;
                            ::prost::encoding::uint64::merge(wire_type, value, buf, ctx)
                                .map_err(|mut error| {
                                    error.push(STRUCT_NAME, "their_messages");
                                    error
                                })
                        }
                        7u32 => {
                            let mut value = &mut self.our_messages;
                            ::prost::encoding::uint64::merge(wire_type, value, buf, ctx)
                                .map_err(|mut error| {
                                    error.push(STRUCT_NAME, "our_messages");
                                    error
                                })
                        }
                        8u32 => {
                            let mut value = &mut self.last_bad_sync;
                            ::prost::encoding::int64::merge(wire_type, value, buf, ctx)
                                .map_err(|mut error| {
                                    error.push(STRUCT_NAME, "last_bad_sync");
                                    error
                                })
                        }
                        _ => ::prost::encoding::skip_field(wire_type, tag, buf, ctx),
                    }
                }
                #[inline]
                fn encoded_len(&self) -> usize {
                    0
                        + if self.peer_id != "" {
                            ::prost::encoding::string::encoded_len(1u32, &self.peer_id)
                        } else {
                            0
                        }
                        + if self.in_sync != "" {
                            ::prost::encoding::string::encoded_len(2u32, &self.in_sync)
                        } else {
                            0
                        }
                        + if self.should_sync != false {
                            ::prost::encoding::bool::encoded_len(3u32, &self.should_sync)
                        } else {
                            0
                        }
                        + if self.divergence_prefix != "" {
                            ::prost::encoding::string::encoded_len(
                                4u32,
                                &self.divergence_prefix,
                            )
                        } else {
                            0
                        }
                        + if self.divergence_seconds_ago != 0i32 {
                            ::prost::encoding::int32::encoded_len(
                                5u32,
                                &self.divergence_seconds_ago,
                            )
                        } else {
                            0
                        }
                        + if self.their_messages != 0u64 {
                            ::prost::encoding::uint64::encoded_len(
                                6u32,
                                &self.their_messages,
                            )
                        } else {
                            0
                        }
                        + if self.our_messages != 0u64 {
                            ::prost::encoding::uint64::encoded_len(
                                7u32,
                                &self.our_messages,
                            )
                        } else {
                            0
                        }
                        + if self.last_bad_sync != 0i64 {
                            ::prost::encoding::int64::encoded_len(
                                8u32,
                                &self.last_bad_sync,
                            )
                        } else {
                            0
                        }
                }
                fn clear(&mut self) {
                    self.peer_id.clear();
                    self.in_sync.clear();
                    self.should_sync = false;
                    self.divergence_prefix.clear();
                    self.divergence_seconds_ago = 0i32;
                    self.their_messages = 0u64;
                    self.our_messages = 0u64;
                    self.last_bad_sync = 0i64;
                }
            }
            impl ::core::default::Default for SyncStatus {
                fn default() -> Self {
                    SyncStatus {
                        peer_id: ::prost::alloc::string::String::new(),
                        in_sync: ::prost::alloc::string::String::new(),
                        should_sync: false,
                        divergence_prefix: ::prost::alloc::string::String::new(),
                        divergence_seconds_ago: 0i32,
                        their_messages: 0u64,
                        our_messages: 0u64,
                        last_bad_sync: 0i64,
                    }
                }
            }
            impl ::core::fmt::Debug for SyncStatus {
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    let mut builder = f.debug_struct("SyncStatus");
                    let builder = {
                        let wrapper = {
                            fn ScalarWrapper<T>(v: T) -> T {
                                v
                            }
                            ScalarWrapper(&self.peer_id)
                        };
                        builder.field("peer_id", &wrapper)
                    };
                    let builder = {
                        let wrapper = {
                            fn ScalarWrapper<T>(v: T) -> T {
                                v
                            }
                            ScalarWrapper(&self.in_sync)
                        };
                        builder.field("in_sync", &wrapper)
                    };
                    let builder = {
                        let wrapper = {
                            fn ScalarWrapper<T>(v: T) -> T {
                                v
                            }
                            ScalarWrapper(&self.should_sync)
                        };
                        builder.field("should_sync", &wrapper)
                    };
                    let builder = {
                        let wrapper = {
                            fn ScalarWrapper<T>(v: T) -> T {
                                v
                            }
                            ScalarWrapper(&self.divergence_prefix)
                        };
                        builder.field("divergence_prefix", &wrapper)
                    };
                    let builder = {
                        let wrapper = {
                            fn ScalarWrapper<T>(v: T) -> T {
                                v
                            }
                            ScalarWrapper(&self.divergence_seconds_ago)
                        };
                        builder.field("divergence_seconds_ago", &wrapper)
                    };
                    let builder = {
                        let wrapper = {
                            fn ScalarWrapper<T>(v: T) -> T {
                                v
                            }
                            ScalarWrapper(&self.their_messages)
                        };
                        builder.field("their_messages", &wrapper)
                    };
                    let builder = {
                        let wrapper = {
                            fn ScalarWrapper<T>(v: T) -> T {
                                v
                            }
                            ScalarWrapper(&self.our_messages)
                        };
                        builder.field("our_messages", &wrapper)
                    };
                    let builder = {
                        let wrapper = {
                            fn ScalarWrapper<T>(v: T) -> T {
                                v
                            }
                            ScalarWrapper(&self.last_bad_sync)
                        };
                        builder.field("last_bad_sync", &wrapper)
                    };
                    builder.finish()
                }
            }
            #[allow(clippy::derive_partial_eq_without_eq)]
            pub struct TrieNodeMetadataResponse {
                #[prost(bytes = "vec", tag = "1")]
                pub prefix: ::prost::alloc::vec::Vec<u8>,
                #[prost(uint64, tag = "2")]
                pub num_messages: u64,
                #[prost(string, tag = "3")]
                pub hash: ::prost::alloc::string::String,
                #[prost(message, repeated, tag = "4")]
                pub children: ::prost::alloc::vec::Vec<TrieNodeMetadataResponse>,
            }
            #[automatically_derived]
            #[allow(clippy::derive_partial_eq_without_eq)]
            impl ::core::clone::Clone for TrieNodeMetadataResponse {
                #[inline]
                fn clone(&self) -> TrieNodeMetadataResponse {
                    TrieNodeMetadataResponse {
                        prefix: ::core::clone::Clone::clone(&self.prefix),
                        num_messages: ::core::clone::Clone::clone(&self.num_messages),
                        hash: ::core::clone::Clone::clone(&self.hash),
                        children: ::core::clone::Clone::clone(&self.children),
                    }
                }
            }
            #[allow(clippy::derive_partial_eq_without_eq)]
            #[automatically_derived]
            impl ::core::marker::StructuralPartialEq for TrieNodeMetadataResponse {}
            #[automatically_derived]
            #[allow(clippy::derive_partial_eq_without_eq)]
            impl ::core::cmp::PartialEq for TrieNodeMetadataResponse {
                #[inline]
                fn eq(&self, other: &TrieNodeMetadataResponse) -> bool {
                    self.prefix == other.prefix
                        && self.num_messages == other.num_messages
                        && self.hash == other.hash && self.children == other.children
                }
            }
            impl ::prost::Message for TrieNodeMetadataResponse {
                #[allow(unused_variables)]
                fn encode_raw<B>(&self, buf: &mut B)
                where
                    B: ::prost::bytes::BufMut,
                {
                    if self.prefix != b"" as &[u8] {
                        ::prost::encoding::bytes::encode(1u32, &self.prefix, buf);
                    }
                    if self.num_messages != 0u64 {
                        ::prost::encoding::uint64::encode(2u32, &self.num_messages, buf);
                    }
                    if self.hash != "" {
                        ::prost::encoding::string::encode(3u32, &self.hash, buf);
                    }
                    for msg in &self.children {
                        ::prost::encoding::message::encode(4u32, msg, buf);
                    }
                }
                #[allow(unused_variables)]
                fn merge_field<B>(
                    &mut self,
                    tag: u32,
                    wire_type: ::prost::encoding::WireType,
                    buf: &mut B,
                    ctx: ::prost::encoding::DecodeContext,
                ) -> ::core::result::Result<(), ::prost::DecodeError>
                where
                    B: ::prost::bytes::Buf,
                {
                    const STRUCT_NAME: &'static str = "TrieNodeMetadataResponse";
                    match tag {
                        1u32 => {
                            let mut value = &mut self.prefix;
                            ::prost::encoding::bytes::merge(wire_type, value, buf, ctx)
                                .map_err(|mut error| {
                                    error.push(STRUCT_NAME, "prefix");
                                    error
                                })
                        }
                        2u32 => {
                            let mut value = &mut self.num_messages;
                            ::prost::encoding::uint64::merge(wire_type, value, buf, ctx)
                                .map_err(|mut error| {
                                    error.push(STRUCT_NAME, "num_messages");
                                    error
                                })
                        }
                        3u32 => {
                            let mut value = &mut self.hash;
                            ::prost::encoding::string::merge(wire_type, value, buf, ctx)
                                .map_err(|mut error| {
                                    error.push(STRUCT_NAME, "hash");
                                    error
                                })
                        }
                        4u32 => {
                            let mut value = &mut self.children;
                            ::prost::encoding::message::merge_repeated(
                                    wire_type,
                                    value,
                                    buf,
                                    ctx,
                                )
                                .map_err(|mut error| {
                                    error.push(STRUCT_NAME, "children");
                                    error
                                })
                        }
                        _ => ::prost::encoding::skip_field(wire_type, tag, buf, ctx),
                    }
                }
                #[inline]
                fn encoded_len(&self) -> usize {
                    0
                        + if self.prefix != b"" as &[u8] {
                            ::prost::encoding::bytes::encoded_len(1u32, &self.prefix)
                        } else {
                            0
                        }
                        + if self.num_messages != 0u64 {
                            ::prost::encoding::uint64::encoded_len(
                                2u32,
                                &self.num_messages,
                            )
                        } else {
                            0
                        }
                        + if self.hash != "" {
                            ::prost::encoding::string::encoded_len(3u32, &self.hash)
                        } else {
                            0
                        }
                        + ::prost::encoding::message::encoded_len_repeated(
                            4u32,
                            &self.children,
                        )
                }
                fn clear(&mut self) {
                    self.prefix.clear();
                    self.num_messages = 0u64;
                    self.hash.clear();
                    self.children.clear();
                }
            }
            impl ::core::default::Default for TrieNodeMetadataResponse {
                fn default() -> Self {
                    TrieNodeMetadataResponse {
                        prefix: ::core::default::Default::default(),
                        num_messages: 0u64,
                        hash: ::prost::alloc::string::String::new(),
                        children: ::core::default::Default::default(),
                    }
                }
            }
            impl ::core::fmt::Debug for TrieNodeMetadataResponse {
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    let mut builder = f.debug_struct("TrieNodeMetadataResponse");
                    let builder = {
                        let wrapper = {
                            fn ScalarWrapper<T>(v: T) -> T {
                                v
                            }
                            ScalarWrapper(&self.prefix)
                        };
                        builder.field("prefix", &wrapper)
                    };
                    let builder = {
                        let wrapper = {
                            fn ScalarWrapper<T>(v: T) -> T {
                                v
                            }
                            ScalarWrapper(&self.num_messages)
                        };
                        builder.field("num_messages", &wrapper)
                    };
                    let builder = {
                        let wrapper = {
                            fn ScalarWrapper<T>(v: T) -> T {
                                v
                            }
                            ScalarWrapper(&self.hash)
                        };
                        builder.field("hash", &wrapper)
                    };
                    let builder = {
                        let wrapper = &self.children;
                        builder.field("children", &wrapper)
                    };
                    builder.finish()
                }
            }
            #[allow(clippy::derive_partial_eq_without_eq)]
            pub struct TrieNodeSnapshotResponse {
                #[prost(bytes = "vec", tag = "1")]
                pub prefix: ::prost::alloc::vec::Vec<u8>,
                #[prost(string, repeated, tag = "2")]
                pub excluded_hashes: ::prost::alloc::vec::Vec<
                    ::prost::alloc::string::String,
                >,
                #[prost(uint64, tag = "3")]
                pub num_messages: u64,
                #[prost(string, tag = "4")]
                pub root_hash: ::prost::alloc::string::String,
            }
            #[automatically_derived]
            #[allow(clippy::derive_partial_eq_without_eq)]
            impl ::core::clone::Clone for TrieNodeSnapshotResponse {
                #[inline]
                fn clone(&self) -> TrieNodeSnapshotResponse {
                    TrieNodeSnapshotResponse {
                        prefix: ::core::clone::Clone::clone(&self.prefix),
                        excluded_hashes: ::core::clone::Clone::clone(
                            &self.excluded_hashes,
                        ),
                        num_messages: ::core::clone::Clone::clone(&self.num_messages),
                        root_hash: ::core::clone::Clone::clone(&self.root_hash),
                    }
                }
            }
            #[allow(clippy::derive_partial_eq_without_eq)]
            #[automatically_derived]
            impl ::core::marker::StructuralPartialEq for TrieNodeSnapshotResponse {}
            #[automatically_derived]
            #[allow(clippy::derive_partial_eq_without_eq)]
            impl ::core::cmp::PartialEq for TrieNodeSnapshotResponse {
                #[inline]
                fn eq(&self, other: &TrieNodeSnapshotResponse) -> bool {
                    self.prefix == other.prefix
                        && self.excluded_hashes == other.excluded_hashes
                        && self.num_messages == other.num_messages
                        && self.root_hash == other.root_hash
                }
            }
            impl ::prost::Message for TrieNodeSnapshotResponse {
                #[allow(unused_variables)]
                fn encode_raw<B>(&self, buf: &mut B)
                where
                    B: ::prost::bytes::BufMut,
                {
                    if self.prefix != b"" as &[u8] {
                        ::prost::encoding::bytes::encode(1u32, &self.prefix, buf);
                    }
                    ::prost::encoding::string::encode_repeated(
                        2u32,
                        &self.excluded_hashes,
                        buf,
                    );
                    if self.num_messages != 0u64 {
                        ::prost::encoding::uint64::encode(3u32, &self.num_messages, buf);
                    }
                    if self.root_hash != "" {
                        ::prost::encoding::string::encode(4u32, &self.root_hash, buf);
                    }
                }
                #[allow(unused_variables)]
                fn merge_field<B>(
                    &mut self,
                    tag: u32,
                    wire_type: ::prost::encoding::WireType,
                    buf: &mut B,
                    ctx: ::prost::encoding::DecodeContext,
                ) -> ::core::result::Result<(), ::prost::DecodeError>
                where
                    B: ::prost::bytes::Buf,
                {
                    const STRUCT_NAME: &'static str = "TrieNodeSnapshotResponse";
                    match tag {
                        1u32 => {
                            let mut value = &mut self.prefix;
                            ::prost::encoding::bytes::merge(wire_type, value, buf, ctx)
                                .map_err(|mut error| {
                                    error.push(STRUCT_NAME, "prefix");
                                    error
                                })
                        }
                        2u32 => {
                            let mut value = &mut self.excluded_hashes;
                            ::prost::encoding::string::merge_repeated(
                                    wire_type,
                                    value,
                                    buf,
                                    ctx,
                                )
                                .map_err(|mut error| {
                                    error.push(STRUCT_NAME, "excluded_hashes");
                                    error
                                })
                        }
                        3u32 => {
                            let mut value = &mut self.num_messages;
                            ::prost::encoding::uint64::merge(wire_type, value, buf, ctx)
                                .map_err(|mut error| {
                                    error.push(STRUCT_NAME, "num_messages");
                                    error
                                })
                        }
                        4u32 => {
                            let mut value = &mut self.root_hash;
                            ::prost::encoding::string::merge(wire_type, value, buf, ctx)
                                .map_err(|mut error| {
                                    error.push(STRUCT_NAME, "root_hash");
                                    error
                                })
                        }
                        _ => ::prost::encoding::skip_field(wire_type, tag, buf, ctx),
                    }
                }
                #[inline]
                fn encoded_len(&self) -> usize {
                    0
                        + if self.prefix != b"" as &[u8] {
                            ::prost::encoding::bytes::encoded_len(1u32, &self.prefix)
                        } else {
                            0
                        }
                        + ::prost::encoding::string::encoded_len_repeated(
                            2u32,
                            &self.excluded_hashes,
                        )
                        + if self.num_messages != 0u64 {
                            ::prost::encoding::uint64::encoded_len(
                                3u32,
                                &self.num_messages,
                            )
                        } else {
                            0
                        }
                        + if self.root_hash != "" {
                            ::prost::encoding::string::encoded_len(4u32, &self.root_hash)
                        } else {
                            0
                        }
                }
                fn clear(&mut self) {
                    self.prefix.clear();
                    self.excluded_hashes.clear();
                    self.num_messages = 0u64;
                    self.root_hash.clear();
                }
            }
            impl ::core::default::Default for TrieNodeSnapshotResponse {
                fn default() -> Self {
                    TrieNodeSnapshotResponse {
                        prefix: ::core::default::Default::default(),
                        excluded_hashes: ::prost::alloc::vec::Vec::new(),
                        num_messages: 0u64,
                        root_hash: ::prost::alloc::string::String::new(),
                    }
                }
            }
            impl ::core::fmt::Debug for TrieNodeSnapshotResponse {
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    let mut builder = f.debug_struct("TrieNodeSnapshotResponse");
                    let builder = {
                        let wrapper = {
                            fn ScalarWrapper<T>(v: T) -> T {
                                v
                            }
                            ScalarWrapper(&self.prefix)
                        };
                        builder.field("prefix", &wrapper)
                    };
                    let builder = {
                        let wrapper = {
                            struct ScalarWrapper<'a>(
                                &'a ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
                            );
                            impl<'a> ::core::fmt::Debug for ScalarWrapper<'a> {
                                fn fmt(
                                    &self,
                                    f: &mut ::core::fmt::Formatter,
                                ) -> ::core::fmt::Result {
                                    let mut vec_builder = f.debug_list();
                                    for v in self.0 {
                                        fn Inner<T>(v: T) -> T {
                                            v
                                        }
                                        vec_builder.entry(&Inner(v));
                                    }
                                    vec_builder.finish()
                                }
                            }
                            ScalarWrapper(&self.excluded_hashes)
                        };
                        builder.field("excluded_hashes", &wrapper)
                    };
                    let builder = {
                        let wrapper = {
                            fn ScalarWrapper<T>(v: T) -> T {
                                v
                            }
                            ScalarWrapper(&self.num_messages)
                        };
                        builder.field("num_messages", &wrapper)
                    };
                    let builder = {
                        let wrapper = {
                            fn ScalarWrapper<T>(v: T) -> T {
                                v
                            }
                            ScalarWrapper(&self.root_hash)
                        };
                        builder.field("root_hash", &wrapper)
                    };
                    builder.finish()
                }
            }
            #[allow(clippy::derive_partial_eq_without_eq)]
            pub struct TrieNodePrefix {
                #[prost(bytes = "vec", tag = "1")]
                pub prefix: ::prost::alloc::vec::Vec<u8>,
            }
            #[automatically_derived]
            #[allow(clippy::derive_partial_eq_without_eq)]
            impl ::core::clone::Clone for TrieNodePrefix {
                #[inline]
                fn clone(&self) -> TrieNodePrefix {
                    TrieNodePrefix {
                        prefix: ::core::clone::Clone::clone(&self.prefix),
                    }
                }
            }
            #[allow(clippy::derive_partial_eq_without_eq)]
            #[automatically_derived]
            impl ::core::marker::StructuralPartialEq for TrieNodePrefix {}
            #[automatically_derived]
            #[allow(clippy::derive_partial_eq_without_eq)]
            impl ::core::cmp::PartialEq for TrieNodePrefix {
                #[inline]
                fn eq(&self, other: &TrieNodePrefix) -> bool {
                    self.prefix == other.prefix
                }
            }
            impl ::prost::Message for TrieNodePrefix {
                #[allow(unused_variables)]
                fn encode_raw<B>(&self, buf: &mut B)
                where
                    B: ::prost::bytes::BufMut,
                {
                    if self.prefix != b"" as &[u8] {
                        ::prost::encoding::bytes::encode(1u32, &self.prefix, buf);
                    }
                }
                #[allow(unused_variables)]
                fn merge_field<B>(
                    &mut self,
                    tag: u32,
                    wire_type: ::prost::encoding::WireType,
                    buf: &mut B,
                    ctx: ::prost::encoding::DecodeContext,
                ) -> ::core::result::Result<(), ::prost::DecodeError>
                where
                    B: ::prost::bytes::Buf,
                {
                    const STRUCT_NAME: &'static str = "TrieNodePrefix";
                    match tag {
                        1u32 => {
                            let mut value = &mut self.prefix;
                            ::prost::encoding::bytes::merge(wire_type, value, buf, ctx)
                                .map_err(|mut error| {
                                    error.push(STRUCT_NAME, "prefix");
                                    error
                                })
                        }
                        _ => ::prost::encoding::skip_field(wire_type, tag, buf, ctx),
                    }
                }
                #[inline]
                fn encoded_len(&self) -> usize {
                    0
                        + if self.prefix != b"" as &[u8] {
                            ::prost::encoding::bytes::encoded_len(1u32, &self.prefix)
                        } else {
                            0
                        }
                }
                fn clear(&mut self) {
                    self.prefix.clear();
                }
            }
            impl ::core::default::Default for TrieNodePrefix {
                fn default() -> Self {
                    TrieNodePrefix {
                        prefix: ::core::default::Default::default(),
                    }
                }
            }
            impl ::core::fmt::Debug for TrieNodePrefix {
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    let mut builder = f.debug_struct("TrieNodePrefix");
                    let builder = {
                        let wrapper = {
                            fn ScalarWrapper<T>(v: T) -> T {
                                v
                            }
                            ScalarWrapper(&self.prefix)
                        };
                        builder.field("prefix", &wrapper)
                    };
                    builder.finish()
                }
            }
            #[allow(clippy::derive_partial_eq_without_eq)]
            pub struct SyncIds {
                #[prost(bytes = "vec", repeated, tag = "1")]
                pub sync_ids: ::prost::alloc::vec::Vec<::prost::alloc::vec::Vec<u8>>,
            }
            #[automatically_derived]
            #[allow(clippy::derive_partial_eq_without_eq)]
            impl ::core::clone::Clone for SyncIds {
                #[inline]
                fn clone(&self) -> SyncIds {
                    SyncIds {
                        sync_ids: ::core::clone::Clone::clone(&self.sync_ids),
                    }
                }
            }
            #[allow(clippy::derive_partial_eq_without_eq)]
            #[automatically_derived]
            impl ::core::marker::StructuralPartialEq for SyncIds {}
            #[automatically_derived]
            #[allow(clippy::derive_partial_eq_without_eq)]
            impl ::core::cmp::PartialEq for SyncIds {
                #[inline]
                fn eq(&self, other: &SyncIds) -> bool {
                    self.sync_ids == other.sync_ids
                }
            }
            impl ::prost::Message for SyncIds {
                #[allow(unused_variables)]
                fn encode_raw<B>(&self, buf: &mut B)
                where
                    B: ::prost::bytes::BufMut,
                {
                    ::prost::encoding::bytes::encode_repeated(1u32, &self.sync_ids, buf);
                }
                #[allow(unused_variables)]
                fn merge_field<B>(
                    &mut self,
                    tag: u32,
                    wire_type: ::prost::encoding::WireType,
                    buf: &mut B,
                    ctx: ::prost::encoding::DecodeContext,
                ) -> ::core::result::Result<(), ::prost::DecodeError>
                where
                    B: ::prost::bytes::Buf,
                {
                    const STRUCT_NAME: &'static str = "SyncIds";
                    match tag {
                        1u32 => {
                            let mut value = &mut self.sync_ids;
                            ::prost::encoding::bytes::merge_repeated(
                                    wire_type,
                                    value,
                                    buf,
                                    ctx,
                                )
                                .map_err(|mut error| {
                                    error.push(STRUCT_NAME, "sync_ids");
                                    error
                                })
                        }
                        _ => ::prost::encoding::skip_field(wire_type, tag, buf, ctx),
                    }
                }
                #[inline]
                fn encoded_len(&self) -> usize {
                    0
                        + ::prost::encoding::bytes::encoded_len_repeated(
                            1u32,
                            &self.sync_ids,
                        )
                }
                fn clear(&mut self) {
                    self.sync_ids.clear();
                }
            }
            impl ::core::default::Default for SyncIds {
                fn default() -> Self {
                    SyncIds {
                        sync_ids: ::prost::alloc::vec::Vec::new(),
                    }
                }
            }
            impl ::core::fmt::Debug for SyncIds {
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    let mut builder = f.debug_struct("SyncIds");
                    let builder = {
                        let wrapper = {
                            struct ScalarWrapper<'a>(
                                &'a ::prost::alloc::vec::Vec<::prost::alloc::vec::Vec<u8>>,
                            );
                            impl<'a> ::core::fmt::Debug for ScalarWrapper<'a> {
                                fn fmt(
                                    &self,
                                    f: &mut ::core::fmt::Formatter,
                                ) -> ::core::fmt::Result {
                                    let mut vec_builder = f.debug_list();
                                    for v in self.0 {
                                        fn Inner<T>(v: T) -> T {
                                            v
                                        }
                                        vec_builder.entry(&Inner(v));
                                    }
                                    vec_builder.finish()
                                }
                            }
                            ScalarWrapper(&self.sync_ids)
                        };
                        builder.field("sync_ids", &wrapper)
                    };
                    builder.finish()
                }
            }
            #[allow(clippy::derive_partial_eq_without_eq)]
            pub struct FidRequest {
                #[prost(uint64, tag = "1")]
                pub fid: u64,
                #[prost(uint32, optional, tag = "2")]
                pub page_size: ::core::option::Option<u32>,
                #[prost(bytes = "vec", optional, tag = "3")]
                pub page_token: ::core::option::Option<::prost::alloc::vec::Vec<u8>>,
                #[prost(bool, optional, tag = "4")]
                pub reverse: ::core::option::Option<bool>,
            }
            #[automatically_derived]
            #[allow(clippy::derive_partial_eq_without_eq)]
            impl ::core::clone::Clone for FidRequest {
                #[inline]
                fn clone(&self) -> FidRequest {
                    FidRequest {
                        fid: ::core::clone::Clone::clone(&self.fid),
                        page_size: ::core::clone::Clone::clone(&self.page_size),
                        page_token: ::core::clone::Clone::clone(&self.page_token),
                        reverse: ::core::clone::Clone::clone(&self.reverse),
                    }
                }
            }
            #[allow(clippy::derive_partial_eq_without_eq)]
            #[automatically_derived]
            impl ::core::marker::StructuralPartialEq for FidRequest {}
            #[automatically_derived]
            #[allow(clippy::derive_partial_eq_without_eq)]
            impl ::core::cmp::PartialEq for FidRequest {
                #[inline]
                fn eq(&self, other: &FidRequest) -> bool {
                    self.fid == other.fid && self.page_size == other.page_size
                        && self.page_token == other.page_token
                        && self.reverse == other.reverse
                }
            }
            impl ::prost::Message for FidRequest {
                #[allow(unused_variables)]
                fn encode_raw<B>(&self, buf: &mut B)
                where
                    B: ::prost::bytes::BufMut,
                {
                    if self.fid != 0u64 {
                        ::prost::encoding::uint64::encode(1u32, &self.fid, buf);
                    }
                    if let ::core::option::Option::Some(ref value) = self.page_size {
                        ::prost::encoding::uint32::encode(2u32, value, buf);
                    }
                    if let ::core::option::Option::Some(ref value) = self.page_token {
                        ::prost::encoding::bytes::encode(3u32, value, buf);
                    }
                    if let ::core::option::Option::Some(ref value) = self.reverse {
                        ::prost::encoding::bool::encode(4u32, value, buf);
                    }
                }
                #[allow(unused_variables)]
                fn merge_field<B>(
                    &mut self,
                    tag: u32,
                    wire_type: ::prost::encoding::WireType,
                    buf: &mut B,
                    ctx: ::prost::encoding::DecodeContext,
                ) -> ::core::result::Result<(), ::prost::DecodeError>
                where
                    B: ::prost::bytes::Buf,
                {
                    const STRUCT_NAME: &'static str = "FidRequest";
                    match tag {
                        1u32 => {
                            let mut value = &mut self.fid;
                            ::prost::encoding::uint64::merge(wire_type, value, buf, ctx)
                                .map_err(|mut error| {
                                    error.push(STRUCT_NAME, "fid");
                                    error
                                })
                        }
                        2u32 => {
                            let mut value = &mut self.page_size;
                            ::prost::encoding::uint32::merge(
                                    wire_type,
                                    value.get_or_insert_with(::core::default::Default::default),
                                    buf,
                                    ctx,
                                )
                                .map_err(|mut error| {
                                    error.push(STRUCT_NAME, "page_size");
                                    error
                                })
                        }
                        3u32 => {
                            let mut value = &mut self.page_token;
                            ::prost::encoding::bytes::merge(
                                    wire_type,
                                    value.get_or_insert_with(::core::default::Default::default),
                                    buf,
                                    ctx,
                                )
                                .map_err(|mut error| {
                                    error.push(STRUCT_NAME, "page_token");
                                    error
                                })
                        }
                        4u32 => {
                            let mut value = &mut self.reverse;
                            ::prost::encoding::bool::merge(
                                    wire_type,
                                    value.get_or_insert_with(::core::default::Default::default),
                                    buf,
                                    ctx,
                                )
                                .map_err(|mut error| {
                                    error.push(STRUCT_NAME, "reverse");
                                    error
                                })
                        }
                        _ => ::prost::encoding::skip_field(wire_type, tag, buf, ctx),
                    }
                }
                #[inline]
                fn encoded_len(&self) -> usize {
                    0
                        + if self.fid != 0u64 {
                            ::prost::encoding::uint64::encoded_len(1u32, &self.fid)
                        } else {
                            0
                        }
                        + self
                            .page_size
                            .as_ref()
                            .map_or(
                                0,
                                |value| ::prost::encoding::uint32::encoded_len(2u32, value),
                            )
                        + self
                            .page_token
                            .as_ref()
                            .map_or(
                                0,
                                |value| ::prost::encoding::bytes::encoded_len(3u32, value),
                            )
                        + self
                            .reverse
                            .as_ref()
                            .map_or(
                                0,
                                |value| ::prost::encoding::bool::encoded_len(4u32, value),
                            )
                }
                fn clear(&mut self) {
                    self.fid = 0u64;
                    self.page_size = ::core::option::Option::None;
                    self.page_token = ::core::option::Option::None;
                    self.reverse = ::core::option::Option::None;
                }
            }
            impl ::core::default::Default for FidRequest {
                fn default() -> Self {
                    FidRequest {
                        fid: 0u64,
                        page_size: ::core::option::Option::None,
                        page_token: ::core::option::Option::None,
                        reverse: ::core::option::Option::None,
                    }
                }
            }
            impl ::core::fmt::Debug for FidRequest {
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    let mut builder = f.debug_struct("FidRequest");
                    let builder = {
                        let wrapper = {
                            fn ScalarWrapper<T>(v: T) -> T {
                                v
                            }
                            ScalarWrapper(&self.fid)
                        };
                        builder.field("fid", &wrapper)
                    };
                    let builder = {
                        let wrapper = {
                            struct ScalarWrapper<'a>(&'a ::core::option::Option<u32>);
                            impl<'a> ::core::fmt::Debug for ScalarWrapper<'a> {
                                fn fmt(
                                    &self,
                                    f: &mut ::core::fmt::Formatter,
                                ) -> ::core::fmt::Result {
                                    fn Inner<T>(v: T) -> T {
                                        v
                                    }
                                    ::core::fmt::Debug::fmt(&self.0.as_ref().map(Inner), f)
                                }
                            }
                            ScalarWrapper(&self.page_size)
                        };
                        builder.field("page_size", &wrapper)
                    };
                    let builder = {
                        let wrapper = {
                            struct ScalarWrapper<'a>(
                                &'a ::core::option::Option<::prost::alloc::vec::Vec<u8>>,
                            );
                            impl<'a> ::core::fmt::Debug for ScalarWrapper<'a> {
                                fn fmt(
                                    &self,
                                    f: &mut ::core::fmt::Formatter,
                                ) -> ::core::fmt::Result {
                                    fn Inner<T>(v: T) -> T {
                                        v
                                    }
                                    ::core::fmt::Debug::fmt(&self.0.as_ref().map(Inner), f)
                                }
                            }
                            ScalarWrapper(&self.page_token)
                        };
                        builder.field("page_token", &wrapper)
                    };
                    let builder = {
                        let wrapper = {
                            struct ScalarWrapper<'a>(&'a ::core::option::Option<bool>);
                            impl<'a> ::core::fmt::Debug for ScalarWrapper<'a> {
                                fn fmt(
                                    &self,
                                    f: &mut ::core::fmt::Formatter,
                                ) -> ::core::fmt::Result {
                                    fn Inner<T>(v: T) -> T {
                                        v
                                    }
                                    ::core::fmt::Debug::fmt(&self.0.as_ref().map(Inner), f)
                                }
                            }
                            ScalarWrapper(&self.reverse)
                        };
                        builder.field("reverse", &wrapper)
                    };
                    builder.finish()
                }
            }
            #[allow(dead_code)]
            impl FidRequest {
                ///Returns the value of `page_size`, or the default value if `page_size` is unset.
                pub fn page_size(&self) -> u32 {
                    match self.page_size {
                        ::core::option::Option::Some(val) => val,
                        ::core::option::Option::None => 0u32,
                    }
                }
                ///Returns the value of `page_token`, or the default value if `page_token` is unset.
                pub fn page_token(&self) -> &[u8] {
                    match self.page_token {
                        ::core::option::Option::Some(ref val) => &val[..],
                        ::core::option::Option::None => b"" as &[u8],
                    }
                }
                ///Returns the value of `reverse`, or the default value if `reverse` is unset.
                pub fn reverse(&self) -> bool {
                    match self.reverse {
                        ::core::option::Option::Some(val) => val,
                        ::core::option::Option::None => false,
                    }
                }
            }
            #[allow(clippy::derive_partial_eq_without_eq)]
            pub struct FidsRequest {
                #[prost(uint32, optional, tag = "1")]
                pub page_size: ::core::option::Option<u32>,
                #[prost(bytes = "vec", optional, tag = "2")]
                pub page_token: ::core::option::Option<::prost::alloc::vec::Vec<u8>>,
                #[prost(bool, optional, tag = "3")]
                pub reverse: ::core::option::Option<bool>,
            }
            #[automatically_derived]
            #[allow(clippy::derive_partial_eq_without_eq)]
            impl ::core::clone::Clone for FidsRequest {
                #[inline]
                fn clone(&self) -> FidsRequest {
                    FidsRequest {
                        page_size: ::core::clone::Clone::clone(&self.page_size),
                        page_token: ::core::clone::Clone::clone(&self.page_token),
                        reverse: ::core::clone::Clone::clone(&self.reverse),
                    }
                }
            }
            #[allow(clippy::derive_partial_eq_without_eq)]
            #[automatically_derived]
            impl ::core::marker::StructuralPartialEq for FidsRequest {}
            #[automatically_derived]
            #[allow(clippy::derive_partial_eq_without_eq)]
            impl ::core::cmp::PartialEq for FidsRequest {
                #[inline]
                fn eq(&self, other: &FidsRequest) -> bool {
                    self.page_size == other.page_size
                        && self.page_token == other.page_token
                        && self.reverse == other.reverse
                }
            }
            impl ::prost::Message for FidsRequest {
                #[allow(unused_variables)]
                fn encode_raw<B>(&self, buf: &mut B)
                where
                    B: ::prost::bytes::BufMut,
                {
                    if let ::core::option::Option::Some(ref value) = self.page_size {
                        ::prost::encoding::uint32::encode(1u32, value, buf);
                    }
                    if let ::core::option::Option::Some(ref value) = self.page_token {
                        ::prost::encoding::bytes::encode(2u32, value, buf);
                    }
                    if let ::core::option::Option::Some(ref value) = self.reverse {
                        ::prost::encoding::bool::encode(3u32, value, buf);
                    }
                }
                #[allow(unused_variables)]
                fn merge_field<B>(
                    &mut self,
                    tag: u32,
                    wire_type: ::prost::encoding::WireType,
                    buf: &mut B,
                    ctx: ::prost::encoding::DecodeContext,
                ) -> ::core::result::Result<(), ::prost::DecodeError>
                where
                    B: ::prost::bytes::Buf,
                {
                    const STRUCT_NAME: &'static str = "FidsRequest";
                    match tag {
                        1u32 => {
                            let mut value = &mut self.page_size;
                            ::prost::encoding::uint32::merge(
                                    wire_type,
                                    value.get_or_insert_with(::core::default::Default::default),
                                    buf,
                                    ctx,
                                )
                                .map_err(|mut error| {
                                    error.push(STRUCT_NAME, "page_size");
                                    error
                                })
                        }
                        2u32 => {
                            let mut value = &mut self.page_token;
                            ::prost::encoding::bytes::merge(
                                    wire_type,
                                    value.get_or_insert_with(::core::default::Default::default),
                                    buf,
                                    ctx,
                                )
                                .map_err(|mut error| {
                                    error.push(STRUCT_NAME, "page_token");
                                    error
                                })
                        }
                        3u32 => {
                            let mut value = &mut self.reverse;
                            ::prost::encoding::bool::merge(
                                    wire_type,
                                    value.get_or_insert_with(::core::default::Default::default),
                                    buf,
                                    ctx,
                                )
                                .map_err(|mut error| {
                                    error.push(STRUCT_NAME, "reverse");
                                    error
                                })
                        }
                        _ => ::prost::encoding::skip_field(wire_type, tag, buf, ctx),
                    }
                }
                #[inline]
                fn encoded_len(&self) -> usize {
                    0
                        + self
                            .page_size
                            .as_ref()
                            .map_or(
                                0,
                                |value| ::prost::encoding::uint32::encoded_len(1u32, value),
                            )
                        + self
                            .page_token
                            .as_ref()
                            .map_or(
                                0,
                                |value| ::prost::encoding::bytes::encoded_len(2u32, value),
                            )
                        + self
                            .reverse
                            .as_ref()
                            .map_or(
                                0,
                                |value| ::prost::encoding::bool::encoded_len(3u32, value),
                            )
                }
                fn clear(&mut self) {
                    self.page_size = ::core::option::Option::None;
                    self.page_token = ::core::option::Option::None;
                    self.reverse = ::core::option::Option::None;
                }
            }
            impl ::core::default::Default for FidsRequest {
                fn default() -> Self {
                    FidsRequest {
                        page_size: ::core::option::Option::None,
                        page_token: ::core::option::Option::None,
                        reverse: ::core::option::Option::None,
                    }
                }
            }
            impl ::core::fmt::Debug for FidsRequest {
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    let mut builder = f.debug_struct("FidsRequest");
                    let builder = {
                        let wrapper = {
                            struct ScalarWrapper<'a>(&'a ::core::option::Option<u32>);
                            impl<'a> ::core::fmt::Debug for ScalarWrapper<'a> {
                                fn fmt(
                                    &self,
                                    f: &mut ::core::fmt::Formatter,
                                ) -> ::core::fmt::Result {
                                    fn Inner<T>(v: T) -> T {
                                        v
                                    }
                                    ::core::fmt::Debug::fmt(&self.0.as_ref().map(Inner), f)
                                }
                            }
                            ScalarWrapper(&self.page_size)
                        };
                        builder.field("page_size", &wrapper)
                    };
                    let builder = {
                        let wrapper = {
                            struct ScalarWrapper<'a>(
                                &'a ::core::option::Option<::prost::alloc::vec::Vec<u8>>,
                            );
                            impl<'a> ::core::fmt::Debug for ScalarWrapper<'a> {
                                fn fmt(
                                    &self,
                                    f: &mut ::core::fmt::Formatter,
                                ) -> ::core::fmt::Result {
                                    fn Inner<T>(v: T) -> T {
                                        v
                                    }
                                    ::core::fmt::Debug::fmt(&self.0.as_ref().map(Inner), f)
                                }
                            }
                            ScalarWrapper(&self.page_token)
                        };
                        builder.field("page_token", &wrapper)
                    };
                    let builder = {
                        let wrapper = {
                            struct ScalarWrapper<'a>(&'a ::core::option::Option<bool>);
                            impl<'a> ::core::fmt::Debug for ScalarWrapper<'a> {
                                fn fmt(
                                    &self,
                                    f: &mut ::core::fmt::Formatter,
                                ) -> ::core::fmt::Result {
                                    fn Inner<T>(v: T) -> T {
                                        v
                                    }
                                    ::core::fmt::Debug::fmt(&self.0.as_ref().map(Inner), f)
                                }
                            }
                            ScalarWrapper(&self.reverse)
                        };
                        builder.field("reverse", &wrapper)
                    };
                    builder.finish()
                }
            }
            #[allow(dead_code)]
            impl FidsRequest {
                ///Returns the value of `page_size`, or the default value if `page_size` is unset.
                pub fn page_size(&self) -> u32 {
                    match self.page_size {
                        ::core::option::Option::Some(val) => val,
                        ::core::option::Option::None => 0u32,
                    }
                }
                ///Returns the value of `page_token`, or the default value if `page_token` is unset.
                pub fn page_token(&self) -> &[u8] {
                    match self.page_token {
                        ::core::option::Option::Some(ref val) => &val[..],
                        ::core::option::Option::None => b"" as &[u8],
                    }
                }
                ///Returns the value of `reverse`, or the default value if `reverse` is unset.
                pub fn reverse(&self) -> bool {
                    match self.reverse {
                        ::core::option::Option::Some(val) => val,
                        ::core::option::Option::None => false,
                    }
                }
            }
            #[allow(clippy::derive_partial_eq_without_eq)]
            pub struct FidsResponse {
                #[prost(uint64, repeated, tag = "1")]
                pub fids: ::prost::alloc::vec::Vec<u64>,
                #[prost(bytes = "vec", optional, tag = "2")]
                pub next_page_token: ::core::option::Option<
                    ::prost::alloc::vec::Vec<u8>,
                >,
            }
            #[automatically_derived]
            #[allow(clippy::derive_partial_eq_without_eq)]
            impl ::core::clone::Clone for FidsResponse {
                #[inline]
                fn clone(&self) -> FidsResponse {
                    FidsResponse {
                        fids: ::core::clone::Clone::clone(&self.fids),
                        next_page_token: ::core::clone::Clone::clone(
                            &self.next_page_token,
                        ),
                    }
                }
            }
            #[allow(clippy::derive_partial_eq_without_eq)]
            #[automatically_derived]
            impl ::core::marker::StructuralPartialEq for FidsResponse {}
            #[automatically_derived]
            #[allow(clippy::derive_partial_eq_without_eq)]
            impl ::core::cmp::PartialEq for FidsResponse {
                #[inline]
                fn eq(&self, other: &FidsResponse) -> bool {
                    self.fids == other.fids
                        && self.next_page_token == other.next_page_token
                }
            }
            impl ::prost::Message for FidsResponse {
                #[allow(unused_variables)]
                fn encode_raw<B>(&self, buf: &mut B)
                where
                    B: ::prost::bytes::BufMut,
                {
                    ::prost::encoding::uint64::encode_packed(1u32, &self.fids, buf);
                    if let ::core::option::Option::Some(ref value) = self.next_page_token
                    {
                        ::prost::encoding::bytes::encode(2u32, value, buf);
                    }
                }
                #[allow(unused_variables)]
                fn merge_field<B>(
                    &mut self,
                    tag: u32,
                    wire_type: ::prost::encoding::WireType,
                    buf: &mut B,
                    ctx: ::prost::encoding::DecodeContext,
                ) -> ::core::result::Result<(), ::prost::DecodeError>
                where
                    B: ::prost::bytes::Buf,
                {
                    const STRUCT_NAME: &'static str = "FidsResponse";
                    match tag {
                        1u32 => {
                            let mut value = &mut self.fids;
                            ::prost::encoding::uint64::merge_repeated(
                                    wire_type,
                                    value,
                                    buf,
                                    ctx,
                                )
                                .map_err(|mut error| {
                                    error.push(STRUCT_NAME, "fids");
                                    error
                                })
                        }
                        2u32 => {
                            let mut value = &mut self.next_page_token;
                            ::prost::encoding::bytes::merge(
                                    wire_type,
                                    value.get_or_insert_with(::core::default::Default::default),
                                    buf,
                                    ctx,
                                )
                                .map_err(|mut error| {
                                    error.push(STRUCT_NAME, "next_page_token");
                                    error
                                })
                        }
                        _ => ::prost::encoding::skip_field(wire_type, tag, buf, ctx),
                    }
                }
                #[inline]
                fn encoded_len(&self) -> usize {
                    0 + ::prost::encoding::uint64::encoded_len_packed(1u32, &self.fids)
                        + self
                            .next_page_token
                            .as_ref()
                            .map_or(
                                0,
                                |value| ::prost::encoding::bytes::encoded_len(2u32, value),
                            )
                }
                fn clear(&mut self) {
                    self.fids.clear();
                    self.next_page_token = ::core::option::Option::None;
                }
            }
            impl ::core::default::Default for FidsResponse {
                fn default() -> Self {
                    FidsResponse {
                        fids: ::prost::alloc::vec::Vec::new(),
                        next_page_token: ::core::option::Option::None,
                    }
                }
            }
            impl ::core::fmt::Debug for FidsResponse {
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    let mut builder = f.debug_struct("FidsResponse");
                    let builder = {
                        let wrapper = {
                            struct ScalarWrapper<'a>(&'a ::prost::alloc::vec::Vec<u64>);
                            impl<'a> ::core::fmt::Debug for ScalarWrapper<'a> {
                                fn fmt(
                                    &self,
                                    f: &mut ::core::fmt::Formatter,
                                ) -> ::core::fmt::Result {
                                    let mut vec_builder = f.debug_list();
                                    for v in self.0 {
                                        fn Inner<T>(v: T) -> T {
                                            v
                                        }
                                        vec_builder.entry(&Inner(v));
                                    }
                                    vec_builder.finish()
                                }
                            }
                            ScalarWrapper(&self.fids)
                        };
                        builder.field("fids", &wrapper)
                    };
                    let builder = {
                        let wrapper = {
                            struct ScalarWrapper<'a>(
                                &'a ::core::option::Option<::prost::alloc::vec::Vec<u8>>,
                            );
                            impl<'a> ::core::fmt::Debug for ScalarWrapper<'a> {
                                fn fmt(
                                    &self,
                                    f: &mut ::core::fmt::Formatter,
                                ) -> ::core::fmt::Result {
                                    fn Inner<T>(v: T) -> T {
                                        v
                                    }
                                    ::core::fmt::Debug::fmt(&self.0.as_ref().map(Inner), f)
                                }
                            }
                            ScalarWrapper(&self.next_page_token)
                        };
                        builder.field("next_page_token", &wrapper)
                    };
                    builder.finish()
                }
            }
            #[allow(dead_code)]
            impl FidsResponse {
                ///Returns the value of `next_page_token`, or the default value if `next_page_token` is unset.
                pub fn next_page_token(&self) -> &[u8] {
                    match self.next_page_token {
                        ::core::option::Option::Some(ref val) => &val[..],
                        ::core::option::Option::None => b"" as &[u8],
                    }
                }
            }
            #[allow(clippy::derive_partial_eq_without_eq)]
            pub struct MessagesResponse {
                #[prost(message, repeated, tag = "1")]
                pub messages: ::prost::alloc::vec::Vec<Message>,
                #[prost(bytes = "vec", optional, tag = "2")]
                pub next_page_token: ::core::option::Option<
                    ::prost::alloc::vec::Vec<u8>,
                >,
            }
            #[automatically_derived]
            #[allow(clippy::derive_partial_eq_without_eq)]
            impl ::core::clone::Clone for MessagesResponse {
                #[inline]
                fn clone(&self) -> MessagesResponse {
                    MessagesResponse {
                        messages: ::core::clone::Clone::clone(&self.messages),
                        next_page_token: ::core::clone::Clone::clone(
                            &self.next_page_token,
                        ),
                    }
                }
            }
            #[allow(clippy::derive_partial_eq_without_eq)]
            #[automatically_derived]
            impl ::core::marker::StructuralPartialEq for MessagesResponse {}
            #[automatically_derived]
            #[allow(clippy::derive_partial_eq_without_eq)]
            impl ::core::cmp::PartialEq for MessagesResponse {
                #[inline]
                fn eq(&self, other: &MessagesResponse) -> bool {
                    self.messages == other.messages
                        && self.next_page_token == other.next_page_token
                }
            }
            impl ::prost::Message for MessagesResponse {
                #[allow(unused_variables)]
                fn encode_raw<B>(&self, buf: &mut B)
                where
                    B: ::prost::bytes::BufMut,
                {
                    for msg in &self.messages {
                        ::prost::encoding::message::encode(1u32, msg, buf);
                    }
                    if let ::core::option::Option::Some(ref value) = self.next_page_token
                    {
                        ::prost::encoding::bytes::encode(2u32, value, buf);
                    }
                }
                #[allow(unused_variables)]
                fn merge_field<B>(
                    &mut self,
                    tag: u32,
                    wire_type: ::prost::encoding::WireType,
                    buf: &mut B,
                    ctx: ::prost::encoding::DecodeContext,
                ) -> ::core::result::Result<(), ::prost::DecodeError>
                where
                    B: ::prost::bytes::Buf,
                {
                    const STRUCT_NAME: &'static str = "MessagesResponse";
                    match tag {
                        1u32 => {
                            let mut value = &mut self.messages;
                            ::prost::encoding::message::merge_repeated(
                                    wire_type,
                                    value,
                                    buf,
                                    ctx,
                                )
                                .map_err(|mut error| {
                                    error.push(STRUCT_NAME, "messages");
                                    error
                                })
                        }
                        2u32 => {
                            let mut value = &mut self.next_page_token;
                            ::prost::encoding::bytes::merge(
                                    wire_type,
                                    value.get_or_insert_with(::core::default::Default::default),
                                    buf,
                                    ctx,
                                )
                                .map_err(|mut error| {
                                    error.push(STRUCT_NAME, "next_page_token");
                                    error
                                })
                        }
                        _ => ::prost::encoding::skip_field(wire_type, tag, buf, ctx),
                    }
                }
                #[inline]
                fn encoded_len(&self) -> usize {
                    0
                        + ::prost::encoding::message::encoded_len_repeated(
                            1u32,
                            &self.messages,
                        )
                        + self
                            .next_page_token
                            .as_ref()
                            .map_or(
                                0,
                                |value| ::prost::encoding::bytes::encoded_len(2u32, value),
                            )
                }
                fn clear(&mut self) {
                    self.messages.clear();
                    self.next_page_token = ::core::option::Option::None;
                }
            }
            impl ::core::default::Default for MessagesResponse {
                fn default() -> Self {
                    MessagesResponse {
                        messages: ::core::default::Default::default(),
                        next_page_token: ::core::option::Option::None,
                    }
                }
            }
            impl ::core::fmt::Debug for MessagesResponse {
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    let mut builder = f.debug_struct("MessagesResponse");
                    let builder = {
                        let wrapper = &self.messages;
                        builder.field("messages", &wrapper)
                    };
                    let builder = {
                        let wrapper = {
                            struct ScalarWrapper<'a>(
                                &'a ::core::option::Option<::prost::alloc::vec::Vec<u8>>,
                            );
                            impl<'a> ::core::fmt::Debug for ScalarWrapper<'a> {
                                fn fmt(
                                    &self,
                                    f: &mut ::core::fmt::Formatter,
                                ) -> ::core::fmt::Result {
                                    fn Inner<T>(v: T) -> T {
                                        v
                                    }
                                    ::core::fmt::Debug::fmt(&self.0.as_ref().map(Inner), f)
                                }
                            }
                            ScalarWrapper(&self.next_page_token)
                        };
                        builder.field("next_page_token", &wrapper)
                    };
                    builder.finish()
                }
            }
            #[allow(dead_code)]
            impl MessagesResponse {
                ///Returns the value of `next_page_token`, or the default value if `next_page_token` is unset.
                pub fn next_page_token(&self) -> &[u8] {
                    match self.next_page_token {
                        ::core::option::Option::Some(ref val) => &val[..],
                        ::core::option::Option::None => b"" as &[u8],
                    }
                }
            }
            #[allow(clippy::derive_partial_eq_without_eq)]
            pub struct CastsByParentRequest {
                #[prost(uint32, optional, tag = "2")]
                pub page_size: ::core::option::Option<u32>,
                #[prost(bytes = "vec", optional, tag = "3")]
                pub page_token: ::core::option::Option<::prost::alloc::vec::Vec<u8>>,
                #[prost(bool, optional, tag = "4")]
                pub reverse: ::core::option::Option<bool>,
                #[prost(oneof = "casts_by_parent_request::Parent", tags = "1, 5")]
                pub parent: ::core::option::Option<casts_by_parent_request::Parent>,
            }
            #[automatically_derived]
            #[allow(clippy::derive_partial_eq_without_eq)]
            impl ::core::clone::Clone for CastsByParentRequest {
                #[inline]
                fn clone(&self) -> CastsByParentRequest {
                    CastsByParentRequest {
                        page_size: ::core::clone::Clone::clone(&self.page_size),
                        page_token: ::core::clone::Clone::clone(&self.page_token),
                        reverse: ::core::clone::Clone::clone(&self.reverse),
                        parent: ::core::clone::Clone::clone(&self.parent),
                    }
                }
            }
            #[allow(clippy::derive_partial_eq_without_eq)]
            #[automatically_derived]
            impl ::core::marker::StructuralPartialEq for CastsByParentRequest {}
            #[automatically_derived]
            #[allow(clippy::derive_partial_eq_without_eq)]
            impl ::core::cmp::PartialEq for CastsByParentRequest {
                #[inline]
                fn eq(&self, other: &CastsByParentRequest) -> bool {
                    self.page_size == other.page_size
                        && self.page_token == other.page_token
                        && self.reverse == other.reverse && self.parent == other.parent
                }
            }
            impl ::prost::Message for CastsByParentRequest {
                #[allow(unused_variables)]
                fn encode_raw<B>(&self, buf: &mut B)
                where
                    B: ::prost::bytes::BufMut,
                {
                    if let Some(ref oneof) = self.parent {
                        oneof.encode(buf)
                    }
                    if let ::core::option::Option::Some(ref value) = self.page_size {
                        ::prost::encoding::uint32::encode(2u32, value, buf);
                    }
                    if let ::core::option::Option::Some(ref value) = self.page_token {
                        ::prost::encoding::bytes::encode(3u32, value, buf);
                    }
                    if let ::core::option::Option::Some(ref value) = self.reverse {
                        ::prost::encoding::bool::encode(4u32, value, buf);
                    }
                }
                #[allow(unused_variables)]
                fn merge_field<B>(
                    &mut self,
                    tag: u32,
                    wire_type: ::prost::encoding::WireType,
                    buf: &mut B,
                    ctx: ::prost::encoding::DecodeContext,
                ) -> ::core::result::Result<(), ::prost::DecodeError>
                where
                    B: ::prost::bytes::Buf,
                {
                    const STRUCT_NAME: &'static str = "CastsByParentRequest";
                    match tag {
                        1u32 | 5u32 => {
                            let mut value = &mut self.parent;
                            casts_by_parent_request::Parent::merge(
                                    value,
                                    tag,
                                    wire_type,
                                    buf,
                                    ctx,
                                )
                                .map_err(|mut error| {
                                    error.push(STRUCT_NAME, "parent");
                                    error
                                })
                        }
                        2u32 => {
                            let mut value = &mut self.page_size;
                            ::prost::encoding::uint32::merge(
                                    wire_type,
                                    value.get_or_insert_with(::core::default::Default::default),
                                    buf,
                                    ctx,
                                )
                                .map_err(|mut error| {
                                    error.push(STRUCT_NAME, "page_size");
                                    error
                                })
                        }
                        3u32 => {
                            let mut value = &mut self.page_token;
                            ::prost::encoding::bytes::merge(
                                    wire_type,
                                    value.get_or_insert_with(::core::default::Default::default),
                                    buf,
                                    ctx,
                                )
                                .map_err(|mut error| {
                                    error.push(STRUCT_NAME, "page_token");
                                    error
                                })
                        }
                        4u32 => {
                            let mut value = &mut self.reverse;
                            ::prost::encoding::bool::merge(
                                    wire_type,
                                    value.get_or_insert_with(::core::default::Default::default),
                                    buf,
                                    ctx,
                                )
                                .map_err(|mut error| {
                                    error.push(STRUCT_NAME, "reverse");
                                    error
                                })
                        }
                        _ => ::prost::encoding::skip_field(wire_type, tag, buf, ctx),
                    }
                }
                #[inline]
                fn encoded_len(&self) -> usize {
                    0
                        + self
                            .parent
                            .as_ref()
                            .map_or(0, casts_by_parent_request::Parent::encoded_len)
                        + self
                            .page_size
                            .as_ref()
                            .map_or(
                                0,
                                |value| ::prost::encoding::uint32::encoded_len(2u32, value),
                            )
                        + self
                            .page_token
                            .as_ref()
                            .map_or(
                                0,
                                |value| ::prost::encoding::bytes::encoded_len(3u32, value),
                            )
                        + self
                            .reverse
                            .as_ref()
                            .map_or(
                                0,
                                |value| ::prost::encoding::bool::encoded_len(4u32, value),
                            )
                }
                fn clear(&mut self) {
                    self.parent = ::core::option::Option::None;
                    self.page_size = ::core::option::Option::None;
                    self.page_token = ::core::option::Option::None;
                    self.reverse = ::core::option::Option::None;
                }
            }
            impl ::core::default::Default for CastsByParentRequest {
                fn default() -> Self {
                    CastsByParentRequest {
                        parent: ::core::default::Default::default(),
                        page_size: ::core::option::Option::None,
                        page_token: ::core::option::Option::None,
                        reverse: ::core::option::Option::None,
                    }
                }
            }
            impl ::core::fmt::Debug for CastsByParentRequest {
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    let mut builder = f.debug_struct("CastsByParentRequest");
                    let builder = {
                        let wrapper = {
                            struct ScalarWrapper<'a>(&'a ::core::option::Option<u32>);
                            impl<'a> ::core::fmt::Debug for ScalarWrapper<'a> {
                                fn fmt(
                                    &self,
                                    f: &mut ::core::fmt::Formatter,
                                ) -> ::core::fmt::Result {
                                    fn Inner<T>(v: T) -> T {
                                        v
                                    }
                                    ::core::fmt::Debug::fmt(&self.0.as_ref().map(Inner), f)
                                }
                            }
                            ScalarWrapper(&self.page_size)
                        };
                        builder.field("page_size", &wrapper)
                    };
                    let builder = {
                        let wrapper = {
                            struct ScalarWrapper<'a>(
                                &'a ::core::option::Option<::prost::alloc::vec::Vec<u8>>,
                            );
                            impl<'a> ::core::fmt::Debug for ScalarWrapper<'a> {
                                fn fmt(
                                    &self,
                                    f: &mut ::core::fmt::Formatter,
                                ) -> ::core::fmt::Result {
                                    fn Inner<T>(v: T) -> T {
                                        v
                                    }
                                    ::core::fmt::Debug::fmt(&self.0.as_ref().map(Inner), f)
                                }
                            }
                            ScalarWrapper(&self.page_token)
                        };
                        builder.field("page_token", &wrapper)
                    };
                    let builder = {
                        let wrapper = {
                            struct ScalarWrapper<'a>(&'a ::core::option::Option<bool>);
                            impl<'a> ::core::fmt::Debug for ScalarWrapper<'a> {
                                fn fmt(
                                    &self,
                                    f: &mut ::core::fmt::Formatter,
                                ) -> ::core::fmt::Result {
                                    fn Inner<T>(v: T) -> T {
                                        v
                                    }
                                    ::core::fmt::Debug::fmt(&self.0.as_ref().map(Inner), f)
                                }
                            }
                            ScalarWrapper(&self.reverse)
                        };
                        builder.field("reverse", &wrapper)
                    };
                    let builder = {
                        let wrapper = &self.parent;
                        builder.field("parent", &wrapper)
                    };
                    builder.finish()
                }
            }
            #[allow(dead_code)]
            impl CastsByParentRequest {
                ///Returns the value of `page_size`, or the default value if `page_size` is unset.
                pub fn page_size(&self) -> u32 {
                    match self.page_size {
                        ::core::option::Option::Some(val) => val,
                        ::core::option::Option::None => 0u32,
                    }
                }
                ///Returns the value of `page_token`, or the default value if `page_token` is unset.
                pub fn page_token(&self) -> &[u8] {
                    match self.page_token {
                        ::core::option::Option::Some(ref val) => &val[..],
                        ::core::option::Option::None => b"" as &[u8],
                    }
                }
                ///Returns the value of `reverse`, or the default value if `reverse` is unset.
                pub fn reverse(&self) -> bool {
                    match self.reverse {
                        ::core::option::Option::Some(val) => val,
                        ::core::option::Option::None => false,
                    }
                }
            }
            /// Nested message and enum types in `CastsByParentRequest`.
            pub mod casts_by_parent_request {
                #[allow(clippy::derive_partial_eq_without_eq)]
                pub enum Parent {
                    #[prost(message, tag = "1")]
                    ParentCastId(super::CastId),
                    #[prost(string, tag = "5")]
                    ParentUrl(::prost::alloc::string::String),
                }
                #[automatically_derived]
                #[allow(clippy::derive_partial_eq_without_eq)]
                impl ::core::clone::Clone for Parent {
                    #[inline]
                    fn clone(&self) -> Parent {
                        match self {
                            Parent::ParentCastId(__self_0) => {
                                Parent::ParentCastId(::core::clone::Clone::clone(__self_0))
                            }
                            Parent::ParentUrl(__self_0) => {
                                Parent::ParentUrl(::core::clone::Clone::clone(__self_0))
                            }
                        }
                    }
                }
                #[allow(clippy::derive_partial_eq_without_eq)]
                #[automatically_derived]
                impl ::core::marker::StructuralPartialEq for Parent {}
                #[automatically_derived]
                #[allow(clippy::derive_partial_eq_without_eq)]
                impl ::core::cmp::PartialEq for Parent {
                    #[inline]
                    fn eq(&self, other: &Parent) -> bool {
                        let __self_tag = ::core::intrinsics::discriminant_value(self);
                        let __arg1_tag = ::core::intrinsics::discriminant_value(other);
                        __self_tag == __arg1_tag
                            && match (self, other) {
                                (
                                    Parent::ParentCastId(__self_0),
                                    Parent::ParentCastId(__arg1_0),
                                ) => *__self_0 == *__arg1_0,
                                (
                                    Parent::ParentUrl(__self_0),
                                    Parent::ParentUrl(__arg1_0),
                                ) => *__self_0 == *__arg1_0,
                                _ => unsafe { ::core::intrinsics::unreachable() }
                            }
                    }
                }
                impl Parent {
                    /// Encodes the message to a buffer.
                    pub fn encode<B>(&self, buf: &mut B)
                    where
                        B: ::prost::bytes::BufMut,
                    {
                        match *self {
                            Parent::ParentCastId(ref value) => {
                                ::prost::encoding::message::encode(1u32, &*value, buf);
                            }
                            Parent::ParentUrl(ref value) => {
                                ::prost::encoding::string::encode(5u32, &*value, buf);
                            }
                        }
                    }
                    /// Decodes an instance of the message from a buffer, and merges it into self.
                    pub fn merge<B>(
                        field: &mut ::core::option::Option<Parent>,
                        tag: u32,
                        wire_type: ::prost::encoding::WireType,
                        buf: &mut B,
                        ctx: ::prost::encoding::DecodeContext,
                    ) -> ::core::result::Result<(), ::prost::DecodeError>
                    where
                        B: ::prost::bytes::Buf,
                    {
                        match tag {
                            1u32 => {
                                match field {
                                    ::core::option::Option::Some(
                                        Parent::ParentCastId(ref mut value),
                                    ) => {
                                        ::prost::encoding::message::merge(
                                            wire_type,
                                            value,
                                            buf,
                                            ctx,
                                        )
                                    }
                                    _ => {
                                        let mut owned_value = ::core::default::Default::default();
                                        let value = &mut owned_value;
                                        ::prost::encoding::message::merge(
                                                wire_type,
                                                value,
                                                buf,
                                                ctx,
                                            )
                                            .map(|_| {
                                                *field = ::core::option::Option::Some(
                                                    Parent::ParentCastId(owned_value),
                                                );
                                            })
                                    }
                                }
                            }
                            5u32 => {
                                match field {
                                    ::core::option::Option::Some(
                                        Parent::ParentUrl(ref mut value),
                                    ) => {
                                        ::prost::encoding::string::merge(wire_type, value, buf, ctx)
                                    }
                                    _ => {
                                        let mut owned_value = ::core::default::Default::default();
                                        let value = &mut owned_value;
                                        ::prost::encoding::string::merge(wire_type, value, buf, ctx)
                                            .map(|_| {
                                                *field = ::core::option::Option::Some(
                                                    Parent::ParentUrl(owned_value),
                                                );
                                            })
                                    }
                                }
                            }
                            _ => {
                                ::core::panicking::panic_fmt(
                                    format_args!(
                                        "internal error: entered unreachable code: {0}",
                                        format_args!("invalid Parent tag: {0}", tag),
                                    ),
                                );
                            }
                        }
                    }
                    /// Returns the encoded length of the message without a length delimiter.
                    #[inline]
                    pub fn encoded_len(&self) -> usize {
                        match *self {
                            Parent::ParentCastId(ref value) => {
                                ::prost::encoding::message::encoded_len(1u32, &*value)
                            }
                            Parent::ParentUrl(ref value) => {
                                ::prost::encoding::string::encoded_len(5u32, &*value)
                            }
                        }
                    }
                }
                impl ::core::fmt::Debug for Parent {
                    fn fmt(
                        &self,
                        f: &mut ::core::fmt::Formatter,
                    ) -> ::core::fmt::Result {
                        match *self {
                            Parent::ParentCastId(ref value) => {
                                let wrapper = &*value;
                                f.debug_tuple("ParentCastId").field(&wrapper).finish()
                            }
                            Parent::ParentUrl(ref value) => {
                                let wrapper = {
                                    fn ScalarWrapper<T>(v: T) -> T {
                                        v
                                    }
                                    ScalarWrapper(&*value)
                                };
                                f.debug_tuple("ParentUrl").field(&wrapper).finish()
                            }
                        }
                    }
                }
            }
            #[allow(clippy::derive_partial_eq_without_eq)]
            pub struct ReactionRequest {
                #[prost(uint64, tag = "1")]
                pub fid: u64,
                #[prost(enumeration = "ReactionType", tag = "2")]
                pub reaction_type: i32,
                #[prost(oneof = "reaction_request::Target", tags = "3, 4")]
                pub target: ::core::option::Option<reaction_request::Target>,
            }
            #[automatically_derived]
            #[allow(clippy::derive_partial_eq_without_eq)]
            impl ::core::clone::Clone for ReactionRequest {
                #[inline]
                fn clone(&self) -> ReactionRequest {
                    ReactionRequest {
                        fid: ::core::clone::Clone::clone(&self.fid),
                        reaction_type: ::core::clone::Clone::clone(&self.reaction_type),
                        target: ::core::clone::Clone::clone(&self.target),
                    }
                }
            }
            #[allow(clippy::derive_partial_eq_without_eq)]
            #[automatically_derived]
            impl ::core::marker::StructuralPartialEq for ReactionRequest {}
            #[automatically_derived]
            #[allow(clippy::derive_partial_eq_without_eq)]
            impl ::core::cmp::PartialEq for ReactionRequest {
                #[inline]
                fn eq(&self, other: &ReactionRequest) -> bool {
                    self.fid == other.fid && self.reaction_type == other.reaction_type
                        && self.target == other.target
                }
            }
            impl ::prost::Message for ReactionRequest {
                #[allow(unused_variables)]
                fn encode_raw<B>(&self, buf: &mut B)
                where
                    B: ::prost::bytes::BufMut,
                {
                    if self.fid != 0u64 {
                        ::prost::encoding::uint64::encode(1u32, &self.fid, buf);
                    }
                    if self.reaction_type != ReactionType::default() as i32 {
                        ::prost::encoding::int32::encode(2u32, &self.reaction_type, buf);
                    }
                    if let Some(ref oneof) = self.target {
                        oneof.encode(buf)
                    }
                }
                #[allow(unused_variables)]
                fn merge_field<B>(
                    &mut self,
                    tag: u32,
                    wire_type: ::prost::encoding::WireType,
                    buf: &mut B,
                    ctx: ::prost::encoding::DecodeContext,
                ) -> ::core::result::Result<(), ::prost::DecodeError>
                where
                    B: ::prost::bytes::Buf,
                {
                    const STRUCT_NAME: &'static str = "ReactionRequest";
                    match tag {
                        1u32 => {
                            let mut value = &mut self.fid;
                            ::prost::encoding::uint64::merge(wire_type, value, buf, ctx)
                                .map_err(|mut error| {
                                    error.push(STRUCT_NAME, "fid");
                                    error
                                })
                        }
                        2u32 => {
                            let mut value = &mut self.reaction_type;
                            ::prost::encoding::int32::merge(wire_type, value, buf, ctx)
                                .map_err(|mut error| {
                                    error.push(STRUCT_NAME, "reaction_type");
                                    error
                                })
                        }
                        3u32 | 4u32 => {
                            let mut value = &mut self.target;
                            reaction_request::Target::merge(
                                    value,
                                    tag,
                                    wire_type,
                                    buf,
                                    ctx,
                                )
                                .map_err(|mut error| {
                                    error.push(STRUCT_NAME, "target");
                                    error
                                })
                        }
                        _ => ::prost::encoding::skip_field(wire_type, tag, buf, ctx),
                    }
                }
                #[inline]
                fn encoded_len(&self) -> usize {
                    0
                        + if self.fid != 0u64 {
                            ::prost::encoding::uint64::encoded_len(1u32, &self.fid)
                        } else {
                            0
                        }
                        + if self.reaction_type != ReactionType::default() as i32 {
                            ::prost::encoding::int32::encoded_len(
                                2u32,
                                &self.reaction_type,
                            )
                        } else {
                            0
                        }
                        + self
                            .target
                            .as_ref()
                            .map_or(0, reaction_request::Target::encoded_len)
                }
                fn clear(&mut self) {
                    self.fid = 0u64;
                    self.reaction_type = ReactionType::default() as i32;
                    self.target = ::core::option::Option::None;
                }
            }
            impl ::core::default::Default for ReactionRequest {
                fn default() -> Self {
                    ReactionRequest {
                        fid: 0u64,
                        reaction_type: ReactionType::default() as i32,
                        target: ::core::default::Default::default(),
                    }
                }
            }
            impl ::core::fmt::Debug for ReactionRequest {
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    let mut builder = f.debug_struct("ReactionRequest");
                    let builder = {
                        let wrapper = {
                            fn ScalarWrapper<T>(v: T) -> T {
                                v
                            }
                            ScalarWrapper(&self.fid)
                        };
                        builder.field("fid", &wrapper)
                    };
                    let builder = {
                        let wrapper = {
                            struct ScalarWrapper<'a>(&'a i32);
                            impl<'a> ::core::fmt::Debug for ScalarWrapper<'a> {
                                fn fmt(
                                    &self,
                                    f: &mut ::core::fmt::Formatter,
                                ) -> ::core::fmt::Result {
                                    match ReactionType::from_i32(*self.0) {
                                        None => ::core::fmt::Debug::fmt(&self.0, f),
                                        Some(en) => ::core::fmt::Debug::fmt(&en, f),
                                    }
                                }
                            }
                            ScalarWrapper(&self.reaction_type)
                        };
                        builder.field("reaction_type", &wrapper)
                    };
                    let builder = {
                        let wrapper = &self.target;
                        builder.field("target", &wrapper)
                    };
                    builder.finish()
                }
            }
            #[allow(dead_code)]
            impl ReactionRequest {
                ///Returns the enum value of `reaction_type`, or the default if the field is set to an invalid enum value.
                pub fn reaction_type(&self) -> ReactionType {
                    ReactionType::from_i32(self.reaction_type)
                        .unwrap_or(ReactionType::default())
                }
                ///Sets `reaction_type` to the provided enum value.
                pub fn set_reaction_type(&mut self, value: ReactionType) {
                    self.reaction_type = value as i32;
                }
            }
            /// Nested message and enum types in `ReactionRequest`.
            pub mod reaction_request {
                #[allow(clippy::derive_partial_eq_without_eq)]
                pub enum Target {
                    #[prost(message, tag = "3")]
                    TargetCastId(super::CastId),
                    #[prost(string, tag = "4")]
                    TargetUrl(::prost::alloc::string::String),
                }
                #[automatically_derived]
                #[allow(clippy::derive_partial_eq_without_eq)]
                impl ::core::clone::Clone for Target {
                    #[inline]
                    fn clone(&self) -> Target {
                        match self {
                            Target::TargetCastId(__self_0) => {
                                Target::TargetCastId(::core::clone::Clone::clone(__self_0))
                            }
                            Target::TargetUrl(__self_0) => {
                                Target::TargetUrl(::core::clone::Clone::clone(__self_0))
                            }
                        }
                    }
                }
                #[allow(clippy::derive_partial_eq_without_eq)]
                #[automatically_derived]
                impl ::core::marker::StructuralPartialEq for Target {}
                #[automatically_derived]
                #[allow(clippy::derive_partial_eq_without_eq)]
                impl ::core::cmp::PartialEq for Target {
                    #[inline]
                    fn eq(&self, other: &Target) -> bool {
                        let __self_tag = ::core::intrinsics::discriminant_value(self);
                        let __arg1_tag = ::core::intrinsics::discriminant_value(other);
                        __self_tag == __arg1_tag
                            && match (self, other) {
                                (
                                    Target::TargetCastId(__self_0),
                                    Target::TargetCastId(__arg1_0),
                                ) => *__self_0 == *__arg1_0,
                                (
                                    Target::TargetUrl(__self_0),
                                    Target::TargetUrl(__arg1_0),
                                ) => *__self_0 == *__arg1_0,
                                _ => unsafe { ::core::intrinsics::unreachable() }
                            }
                    }
                }
                impl Target {
                    /// Encodes the message to a buffer.
                    pub fn encode<B>(&self, buf: &mut B)
                    where
                        B: ::prost::bytes::BufMut,
                    {
                        match *self {
                            Target::TargetCastId(ref value) => {
                                ::prost::encoding::message::encode(3u32, &*value, buf);
                            }
                            Target::TargetUrl(ref value) => {
                                ::prost::encoding::string::encode(4u32, &*value, buf);
                            }
                        }
                    }
                    /// Decodes an instance of the message from a buffer, and merges it into self.
                    pub fn merge<B>(
                        field: &mut ::core::option::Option<Target>,
                        tag: u32,
                        wire_type: ::prost::encoding::WireType,
                        buf: &mut B,
                        ctx: ::prost::encoding::DecodeContext,
                    ) -> ::core::result::Result<(), ::prost::DecodeError>
                    where
                        B: ::prost::bytes::Buf,
                    {
                        match tag {
                            3u32 => {
                                match field {
                                    ::core::option::Option::Some(
                                        Target::TargetCastId(ref mut value),
                                    ) => {
                                        ::prost::encoding::message::merge(
                                            wire_type,
                                            value,
                                            buf,
                                            ctx,
                                        )
                                    }
                                    _ => {
                                        let mut owned_value = ::core::default::Default::default();
                                        let value = &mut owned_value;
                                        ::prost::encoding::message::merge(
                                                wire_type,
                                                value,
                                                buf,
                                                ctx,
                                            )
                                            .map(|_| {
                                                *field = ::core::option::Option::Some(
                                                    Target::TargetCastId(owned_value),
                                                );
                                            })
                                    }
                                }
                            }
                            4u32 => {
                                match field {
                                    ::core::option::Option::Some(
                                        Target::TargetUrl(ref mut value),
                                    ) => {
                                        ::prost::encoding::string::merge(wire_type, value, buf, ctx)
                                    }
                                    _ => {
                                        let mut owned_value = ::core::default::Default::default();
                                        let value = &mut owned_value;
                                        ::prost::encoding::string::merge(wire_type, value, buf, ctx)
                                            .map(|_| {
                                                *field = ::core::option::Option::Some(
                                                    Target::TargetUrl(owned_value),
                                                );
                                            })
                                    }
                                }
                            }
                            _ => {
                                ::core::panicking::panic_fmt(
                                    format_args!(
                                        "internal error: entered unreachable code: {0}",
                                        format_args!("invalid Target tag: {0}", tag),
                                    ),
                                );
                            }
                        }
                    }
                    /// Returns the encoded length of the message without a length delimiter.
                    #[inline]
                    pub fn encoded_len(&self) -> usize {
                        match *self {
                            Target::TargetCastId(ref value) => {
                                ::prost::encoding::message::encoded_len(3u32, &*value)
                            }
                            Target::TargetUrl(ref value) => {
                                ::prost::encoding::string::encoded_len(4u32, &*value)
                            }
                        }
                    }
                }
                impl ::core::fmt::Debug for Target {
                    fn fmt(
                        &self,
                        f: &mut ::core::fmt::Formatter,
                    ) -> ::core::fmt::Result {
                        match *self {
                            Target::TargetCastId(ref value) => {
                                let wrapper = &*value;
                                f.debug_tuple("TargetCastId").field(&wrapper).finish()
                            }
                            Target::TargetUrl(ref value) => {
                                let wrapper = {
                                    fn ScalarWrapper<T>(v: T) -> T {
                                        v
                                    }
                                    ScalarWrapper(&*value)
                                };
                                f.debug_tuple("TargetUrl").field(&wrapper).finish()
                            }
                        }
                    }
                }
            }
            #[allow(clippy::derive_partial_eq_without_eq)]
            pub struct ReactionsByFidRequest {
                #[prost(uint64, tag = "1")]
                pub fid: u64,
                #[prost(enumeration = "ReactionType", optional, tag = "2")]
                pub reaction_type: ::core::option::Option<i32>,
                #[prost(uint32, optional, tag = "3")]
                pub page_size: ::core::option::Option<u32>,
                #[prost(bytes = "vec", optional, tag = "4")]
                pub page_token: ::core::option::Option<::prost::alloc::vec::Vec<u8>>,
                #[prost(bool, optional, tag = "5")]
                pub reverse: ::core::option::Option<bool>,
            }
            #[automatically_derived]
            #[allow(clippy::derive_partial_eq_without_eq)]
            impl ::core::clone::Clone for ReactionsByFidRequest {
                #[inline]
                fn clone(&self) -> ReactionsByFidRequest {
                    ReactionsByFidRequest {
                        fid: ::core::clone::Clone::clone(&self.fid),
                        reaction_type: ::core::clone::Clone::clone(&self.reaction_type),
                        page_size: ::core::clone::Clone::clone(&self.page_size),
                        page_token: ::core::clone::Clone::clone(&self.page_token),
                        reverse: ::core::clone::Clone::clone(&self.reverse),
                    }
                }
            }
            #[allow(clippy::derive_partial_eq_without_eq)]
            #[automatically_derived]
            impl ::core::marker::StructuralPartialEq for ReactionsByFidRequest {}
            #[automatically_derived]
            #[allow(clippy::derive_partial_eq_without_eq)]
            impl ::core::cmp::PartialEq for ReactionsByFidRequest {
                #[inline]
                fn eq(&self, other: &ReactionsByFidRequest) -> bool {
                    self.fid == other.fid && self.reaction_type == other.reaction_type
                        && self.page_size == other.page_size
                        && self.page_token == other.page_token
                        && self.reverse == other.reverse
                }
            }
            impl ::prost::Message for ReactionsByFidRequest {
                #[allow(unused_variables)]
                fn encode_raw<B>(&self, buf: &mut B)
                where
                    B: ::prost::bytes::BufMut,
                {
                    if self.fid != 0u64 {
                        ::prost::encoding::uint64::encode(1u32, &self.fid, buf);
                    }
                    if let ::core::option::Option::Some(ref value) = self.reaction_type {
                        ::prost::encoding::int32::encode(2u32, value, buf);
                    }
                    if let ::core::option::Option::Some(ref value) = self.page_size {
                        ::prost::encoding::uint32::encode(3u32, value, buf);
                    }
                    if let ::core::option::Option::Some(ref value) = self.page_token {
                        ::prost::encoding::bytes::encode(4u32, value, buf);
                    }
                    if let ::core::option::Option::Some(ref value) = self.reverse {
                        ::prost::encoding::bool::encode(5u32, value, buf);
                    }
                }
                #[allow(unused_variables)]
                fn merge_field<B>(
                    &mut self,
                    tag: u32,
                    wire_type: ::prost::encoding::WireType,
                    buf: &mut B,
                    ctx: ::prost::encoding::DecodeContext,
                ) -> ::core::result::Result<(), ::prost::DecodeError>
                where
                    B: ::prost::bytes::Buf,
                {
                    const STRUCT_NAME: &'static str = "ReactionsByFidRequest";
                    match tag {
                        1u32 => {
                            let mut value = &mut self.fid;
                            ::prost::encoding::uint64::merge(wire_type, value, buf, ctx)
                                .map_err(|mut error| {
                                    error.push(STRUCT_NAME, "fid");
                                    error
                                })
                        }
                        2u32 => {
                            let mut value = &mut self.reaction_type;
                            ::prost::encoding::int32::merge(
                                    wire_type,
                                    value.get_or_insert_with(::core::default::Default::default),
                                    buf,
                                    ctx,
                                )
                                .map_err(|mut error| {
                                    error.push(STRUCT_NAME, "reaction_type");
                                    error
                                })
                        }
                        3u32 => {
                            let mut value = &mut self.page_size;
                            ::prost::encoding::uint32::merge(
                                    wire_type,
                                    value.get_or_insert_with(::core::default::Default::default),
                                    buf,
                                    ctx,
                                )
                                .map_err(|mut error| {
                                    error.push(STRUCT_NAME, "page_size");
                                    error
                                })
                        }
                        4u32 => {
                            let mut value = &mut self.page_token;
                            ::prost::encoding::bytes::merge(
                                    wire_type,
                                    value.get_or_insert_with(::core::default::Default::default),
                                    buf,
                                    ctx,
                                )
                                .map_err(|mut error| {
                                    error.push(STRUCT_NAME, "page_token");
                                    error
                                })
                        }
                        5u32 => {
                            let mut value = &mut self.reverse;
                            ::prost::encoding::bool::merge(
                                    wire_type,
                                    value.get_or_insert_with(::core::default::Default::default),
                                    buf,
                                    ctx,
                                )
                                .map_err(|mut error| {
                                    error.push(STRUCT_NAME, "reverse");
                                    error
                                })
                        }
                        _ => ::prost::encoding::skip_field(wire_type, tag, buf, ctx),
                    }
                }
                #[inline]
                fn encoded_len(&self) -> usize {
                    0
                        + if self.fid != 0u64 {
                            ::prost::encoding::uint64::encoded_len(1u32, &self.fid)
                        } else {
                            0
                        }
                        + self
                            .reaction_type
                            .as_ref()
                            .map_or(
                                0,
                                |value| ::prost::encoding::int32::encoded_len(2u32, value),
                            )
                        + self
                            .page_size
                            .as_ref()
                            .map_or(
                                0,
                                |value| ::prost::encoding::uint32::encoded_len(3u32, value),
                            )
                        + self
                            .page_token
                            .as_ref()
                            .map_or(
                                0,
                                |value| ::prost::encoding::bytes::encoded_len(4u32, value),
                            )
                        + self
                            .reverse
                            .as_ref()
                            .map_or(
                                0,
                                |value| ::prost::encoding::bool::encoded_len(5u32, value),
                            )
                }
                fn clear(&mut self) {
                    self.fid = 0u64;
                    self.reaction_type = ::core::option::Option::None;
                    self.page_size = ::core::option::Option::None;
                    self.page_token = ::core::option::Option::None;
                    self.reverse = ::core::option::Option::None;
                }
            }
            impl ::core::default::Default for ReactionsByFidRequest {
                fn default() -> Self {
                    ReactionsByFidRequest {
                        fid: 0u64,
                        reaction_type: ::core::option::Option::None,
                        page_size: ::core::option::Option::None,
                        page_token: ::core::option::Option::None,
                        reverse: ::core::option::Option::None,
                    }
                }
            }
            impl ::core::fmt::Debug for ReactionsByFidRequest {
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    let mut builder = f.debug_struct("ReactionsByFidRequest");
                    let builder = {
                        let wrapper = {
                            fn ScalarWrapper<T>(v: T) -> T {
                                v
                            }
                            ScalarWrapper(&self.fid)
                        };
                        builder.field("fid", &wrapper)
                    };
                    let builder = {
                        let wrapper = {
                            struct ScalarWrapper<'a>(&'a ::core::option::Option<i32>);
                            impl<'a> ::core::fmt::Debug for ScalarWrapper<'a> {
                                fn fmt(
                                    &self,
                                    f: &mut ::core::fmt::Formatter,
                                ) -> ::core::fmt::Result {
                                    struct Inner<'a>(&'a i32);
                                    impl<'a> ::core::fmt::Debug for Inner<'a> {
                                        fn fmt(
                                            &self,
                                            f: &mut ::core::fmt::Formatter,
                                        ) -> ::core::fmt::Result {
                                            match ReactionType::from_i32(*self.0) {
                                                None => ::core::fmt::Debug::fmt(&self.0, f),
                                                Some(en) => ::core::fmt::Debug::fmt(&en, f),
                                            }
                                        }
                                    }
                                    ::core::fmt::Debug::fmt(&self.0.as_ref().map(Inner), f)
                                }
                            }
                            ScalarWrapper(&self.reaction_type)
                        };
                        builder.field("reaction_type", &wrapper)
                    };
                    let builder = {
                        let wrapper = {
                            struct ScalarWrapper<'a>(&'a ::core::option::Option<u32>);
                            impl<'a> ::core::fmt::Debug for ScalarWrapper<'a> {
                                fn fmt(
                                    &self,
                                    f: &mut ::core::fmt::Formatter,
                                ) -> ::core::fmt::Result {
                                    fn Inner<T>(v: T) -> T {
                                        v
                                    }
                                    ::core::fmt::Debug::fmt(&self.0.as_ref().map(Inner), f)
                                }
                            }
                            ScalarWrapper(&self.page_size)
                        };
                        builder.field("page_size", &wrapper)
                    };
                    let builder = {
                        let wrapper = {
                            struct ScalarWrapper<'a>(
                                &'a ::core::option::Option<::prost::alloc::vec::Vec<u8>>,
                            );
                            impl<'a> ::core::fmt::Debug for ScalarWrapper<'a> {
                                fn fmt(
                                    &self,
                                    f: &mut ::core::fmt::Formatter,
                                ) -> ::core::fmt::Result {
                                    fn Inner<T>(v: T) -> T {
                                        v
                                    }
                                    ::core::fmt::Debug::fmt(&self.0.as_ref().map(Inner), f)
                                }
                            }
                            ScalarWrapper(&self.page_token)
                        };
                        builder.field("page_token", &wrapper)
                    };
                    let builder = {
                        let wrapper = {
                            struct ScalarWrapper<'a>(&'a ::core::option::Option<bool>);
                            impl<'a> ::core::fmt::Debug for ScalarWrapper<'a> {
                                fn fmt(
                                    &self,
                                    f: &mut ::core::fmt::Formatter,
                                ) -> ::core::fmt::Result {
                                    fn Inner<T>(v: T) -> T {
                                        v
                                    }
                                    ::core::fmt::Debug::fmt(&self.0.as_ref().map(Inner), f)
                                }
                            }
                            ScalarWrapper(&self.reverse)
                        };
                        builder.field("reverse", &wrapper)
                    };
                    builder.finish()
                }
            }
            #[allow(dead_code)]
            impl ReactionsByFidRequest {
                ///Returns the enum value of `reaction_type`, or the default if the field is unset or set to an invalid enum value.
                pub fn reaction_type(&self) -> ReactionType {
                    self.reaction_type
                        .and_then(ReactionType::from_i32)
                        .unwrap_or(ReactionType::default())
                }
                ///Sets `reaction_type` to the provided enum value.
                pub fn set_reaction_type(&mut self, value: ReactionType) {
                    self.reaction_type = ::core::option::Option::Some(value as i32);
                }
                ///Returns the value of `page_size`, or the default value if `page_size` is unset.
                pub fn page_size(&self) -> u32 {
                    match self.page_size {
                        ::core::option::Option::Some(val) => val,
                        ::core::option::Option::None => 0u32,
                    }
                }
                ///Returns the value of `page_token`, or the default value if `page_token` is unset.
                pub fn page_token(&self) -> &[u8] {
                    match self.page_token {
                        ::core::option::Option::Some(ref val) => &val[..],
                        ::core::option::Option::None => b"" as &[u8],
                    }
                }
                ///Returns the value of `reverse`, or the default value if `reverse` is unset.
                pub fn reverse(&self) -> bool {
                    match self.reverse {
                        ::core::option::Option::Some(val) => val,
                        ::core::option::Option::None => false,
                    }
                }
            }
            #[allow(clippy::derive_partial_eq_without_eq)]
            pub struct ReactionsByTargetRequest {
                #[prost(enumeration = "ReactionType", optional, tag = "2")]
                pub reaction_type: ::core::option::Option<i32>,
                #[prost(uint32, optional, tag = "3")]
                pub page_size: ::core::option::Option<u32>,
                #[prost(bytes = "vec", optional, tag = "4")]
                pub page_token: ::core::option::Option<::prost::alloc::vec::Vec<u8>>,
                #[prost(bool, optional, tag = "5")]
                pub reverse: ::core::option::Option<bool>,
                #[prost(oneof = "reactions_by_target_request::Target", tags = "1, 6")]
                pub target: ::core::option::Option<reactions_by_target_request::Target>,
            }
            #[automatically_derived]
            #[allow(clippy::derive_partial_eq_without_eq)]
            impl ::core::clone::Clone for ReactionsByTargetRequest {
                #[inline]
                fn clone(&self) -> ReactionsByTargetRequest {
                    ReactionsByTargetRequest {
                        reaction_type: ::core::clone::Clone::clone(&self.reaction_type),
                        page_size: ::core::clone::Clone::clone(&self.page_size),
                        page_token: ::core::clone::Clone::clone(&self.page_token),
                        reverse: ::core::clone::Clone::clone(&self.reverse),
                        target: ::core::clone::Clone::clone(&self.target),
                    }
                }
            }
            #[allow(clippy::derive_partial_eq_without_eq)]
            #[automatically_derived]
            impl ::core::marker::StructuralPartialEq for ReactionsByTargetRequest {}
            #[automatically_derived]
            #[allow(clippy::derive_partial_eq_without_eq)]
            impl ::core::cmp::PartialEq for ReactionsByTargetRequest {
                #[inline]
                fn eq(&self, other: &ReactionsByTargetRequest) -> bool {
                    self.reaction_type == other.reaction_type
                        && self.page_size == other.page_size
                        && self.page_token == other.page_token
                        && self.reverse == other.reverse && self.target == other.target
                }
            }
            impl ::prost::Message for ReactionsByTargetRequest {
                #[allow(unused_variables)]
                fn encode_raw<B>(&self, buf: &mut B)
                where
                    B: ::prost::bytes::BufMut,
                {
                    if let Some(ref oneof) = self.target {
                        oneof.encode(buf)
                    }
                    if let ::core::option::Option::Some(ref value) = self.reaction_type {
                        ::prost::encoding::int32::encode(2u32, value, buf);
                    }
                    if let ::core::option::Option::Some(ref value) = self.page_size {
                        ::prost::encoding::uint32::encode(3u32, value, buf);
                    }
                    if let ::core::option::Option::Some(ref value) = self.page_token {
                        ::prost::encoding::bytes::encode(4u32, value, buf);
                    }
                    if let ::core::option::Option::Some(ref value) = self.reverse {
                        ::prost::encoding::bool::encode(5u32, value, buf);
                    }
                }
                #[allow(unused_variables)]
                fn merge_field<B>(
                    &mut self,
                    tag: u32,
                    wire_type: ::prost::encoding::WireType,
                    buf: &mut B,
                    ctx: ::prost::encoding::DecodeContext,
                ) -> ::core::result::Result<(), ::prost::DecodeError>
                where
                    B: ::prost::bytes::Buf,
                {
                    const STRUCT_NAME: &'static str = "ReactionsByTargetRequest";
                    match tag {
                        1u32 | 6u32 => {
                            let mut value = &mut self.target;
                            reactions_by_target_request::Target::merge(
                                    value,
                                    tag,
                                    wire_type,
                                    buf,
                                    ctx,
                                )
                                .map_err(|mut error| {
                                    error.push(STRUCT_NAME, "target");
                                    error
                                })
                        }
                        2u32 => {
                            let mut value = &mut self.reaction_type;
                            ::prost::encoding::int32::merge(
                                    wire_type,
                                    value.get_or_insert_with(::core::default::Default::default),
                                    buf,
                                    ctx,
                                )
                                .map_err(|mut error| {
                                    error.push(STRUCT_NAME, "reaction_type");
                                    error
                                })
                        }
                        3u32 => {
                            let mut value = &mut self.page_size;
                            ::prost::encoding::uint32::merge(
                                    wire_type,
                                    value.get_or_insert_with(::core::default::Default::default),
                                    buf,
                                    ctx,
                                )
                                .map_err(|mut error| {
                                    error.push(STRUCT_NAME, "page_size");
                                    error
                                })
                        }
                        4u32 => {
                            let mut value = &mut self.page_token;
                            ::prost::encoding::bytes::merge(
                                    wire_type,
                                    value.get_or_insert_with(::core::default::Default::default),
                                    buf,
                                    ctx,
                                )
                                .map_err(|mut error| {
                                    error.push(STRUCT_NAME, "page_token");
                                    error
                                })
                        }
                        5u32 => {
                            let mut value = &mut self.reverse;
                            ::prost::encoding::bool::merge(
                                    wire_type,
                                    value.get_or_insert_with(::core::default::Default::default),
                                    buf,
                                    ctx,
                                )
                                .map_err(|mut error| {
                                    error.push(STRUCT_NAME, "reverse");
                                    error
                                })
                        }
                        _ => ::prost::encoding::skip_field(wire_type, tag, buf, ctx),
                    }
                }
                #[inline]
                fn encoded_len(&self) -> usize {
                    0
                        + self
                            .target
                            .as_ref()
                            .map_or(0, reactions_by_target_request::Target::encoded_len)
                        + self
                            .reaction_type
                            .as_ref()
                            .map_or(
                                0,
                                |value| ::prost::encoding::int32::encoded_len(2u32, value),
                            )
                        + self
                            .page_size
                            .as_ref()
                            .map_or(
                                0,
                                |value| ::prost::encoding::uint32::encoded_len(3u32, value),
                            )
                        + self
                            .page_token
                            .as_ref()
                            .map_or(
                                0,
                                |value| ::prost::encoding::bytes::encoded_len(4u32, value),
                            )
                        + self
                            .reverse
                            .as_ref()
                            .map_or(
                                0,
                                |value| ::prost::encoding::bool::encoded_len(5u32, value),
                            )
                }
                fn clear(&mut self) {
                    self.target = ::core::option::Option::None;
                    self.reaction_type = ::core::option::Option::None;
                    self.page_size = ::core::option::Option::None;
                    self.page_token = ::core::option::Option::None;
                    self.reverse = ::core::option::Option::None;
                }
            }
            impl ::core::default::Default for ReactionsByTargetRequest {
                fn default() -> Self {
                    ReactionsByTargetRequest {
                        target: ::core::default::Default::default(),
                        reaction_type: ::core::option::Option::None,
                        page_size: ::core::option::Option::None,
                        page_token: ::core::option::Option::None,
                        reverse: ::core::option::Option::None,
                    }
                }
            }
            impl ::core::fmt::Debug for ReactionsByTargetRequest {
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    let mut builder = f.debug_struct("ReactionsByTargetRequest");
                    let builder = {
                        let wrapper = {
                            struct ScalarWrapper<'a>(&'a ::core::option::Option<i32>);
                            impl<'a> ::core::fmt::Debug for ScalarWrapper<'a> {
                                fn fmt(
                                    &self,
                                    f: &mut ::core::fmt::Formatter,
                                ) -> ::core::fmt::Result {
                                    struct Inner<'a>(&'a i32);
                                    impl<'a> ::core::fmt::Debug for Inner<'a> {
                                        fn fmt(
                                            &self,
                                            f: &mut ::core::fmt::Formatter,
                                        ) -> ::core::fmt::Result {
                                            match ReactionType::from_i32(*self.0) {
                                                None => ::core::fmt::Debug::fmt(&self.0, f),
                                                Some(en) => ::core::fmt::Debug::fmt(&en, f),
                                            }
                                        }
                                    }
                                    ::core::fmt::Debug::fmt(&self.0.as_ref().map(Inner), f)
                                }
                            }
                            ScalarWrapper(&self.reaction_type)
                        };
                        builder.field("reaction_type", &wrapper)
                    };
                    let builder = {
                        let wrapper = {
                            struct ScalarWrapper<'a>(&'a ::core::option::Option<u32>);
                            impl<'a> ::core::fmt::Debug for ScalarWrapper<'a> {
                                fn fmt(
                                    &self,
                                    f: &mut ::core::fmt::Formatter,
                                ) -> ::core::fmt::Result {
                                    fn Inner<T>(v: T) -> T {
                                        v
                                    }
                                    ::core::fmt::Debug::fmt(&self.0.as_ref().map(Inner), f)
                                }
                            }
                            ScalarWrapper(&self.page_size)
                        };
                        builder.field("page_size", &wrapper)
                    };
                    let builder = {
                        let wrapper = {
                            struct ScalarWrapper<'a>(
                                &'a ::core::option::Option<::prost::alloc::vec::Vec<u8>>,
                            );
                            impl<'a> ::core::fmt::Debug for ScalarWrapper<'a> {
                                fn fmt(
                                    &self,
                                    f: &mut ::core::fmt::Formatter,
                                ) -> ::core::fmt::Result {
                                    fn Inner<T>(v: T) -> T {
                                        v
                                    }
                                    ::core::fmt::Debug::fmt(&self.0.as_ref().map(Inner), f)
                                }
                            }
                            ScalarWrapper(&self.page_token)
                        };
                        builder.field("page_token", &wrapper)
                    };
                    let builder = {
                        let wrapper = {
                            struct ScalarWrapper<'a>(&'a ::core::option::Option<bool>);
                            impl<'a> ::core::fmt::Debug for ScalarWrapper<'a> {
                                fn fmt(
                                    &self,
                                    f: &mut ::core::fmt::Formatter,
                                ) -> ::core::fmt::Result {
                                    fn Inner<T>(v: T) -> T {
                                        v
                                    }
                                    ::core::fmt::Debug::fmt(&self.0.as_ref().map(Inner), f)
                                }
                            }
                            ScalarWrapper(&self.reverse)
                        };
                        builder.field("reverse", &wrapper)
                    };
                    let builder = {
                        let wrapper = &self.target;
                        builder.field("target", &wrapper)
                    };
                    builder.finish()
                }
            }
            #[allow(dead_code)]
            impl ReactionsByTargetRequest {
                ///Returns the enum value of `reaction_type`, or the default if the field is unset or set to an invalid enum value.
                pub fn reaction_type(&self) -> ReactionType {
                    self.reaction_type
                        .and_then(ReactionType::from_i32)
                        .unwrap_or(ReactionType::default())
                }
                ///Sets `reaction_type` to the provided enum value.
                pub fn set_reaction_type(&mut self, value: ReactionType) {
                    self.reaction_type = ::core::option::Option::Some(value as i32);
                }
                ///Returns the value of `page_size`, or the default value if `page_size` is unset.
                pub fn page_size(&self) -> u32 {
                    match self.page_size {
                        ::core::option::Option::Some(val) => val,
                        ::core::option::Option::None => 0u32,
                    }
                }
                ///Returns the value of `page_token`, or the default value if `page_token` is unset.
                pub fn page_token(&self) -> &[u8] {
                    match self.page_token {
                        ::core::option::Option::Some(ref val) => &val[..],
                        ::core::option::Option::None => b"" as &[u8],
                    }
                }
                ///Returns the value of `reverse`, or the default value if `reverse` is unset.
                pub fn reverse(&self) -> bool {
                    match self.reverse {
                        ::core::option::Option::Some(val) => val,
                        ::core::option::Option::None => false,
                    }
                }
            }
            /// Nested message and enum types in `ReactionsByTargetRequest`.
            pub mod reactions_by_target_request {
                #[allow(clippy::derive_partial_eq_without_eq)]
                pub enum Target {
                    #[prost(message, tag = "1")]
                    TargetCastId(super::CastId),
                    #[prost(string, tag = "6")]
                    TargetUrl(::prost::alloc::string::String),
                }
                #[automatically_derived]
                #[allow(clippy::derive_partial_eq_without_eq)]
                impl ::core::clone::Clone for Target {
                    #[inline]
                    fn clone(&self) -> Target {
                        match self {
                            Target::TargetCastId(__self_0) => {
                                Target::TargetCastId(::core::clone::Clone::clone(__self_0))
                            }
                            Target::TargetUrl(__self_0) => {
                                Target::TargetUrl(::core::clone::Clone::clone(__self_0))
                            }
                        }
                    }
                }
                #[allow(clippy::derive_partial_eq_without_eq)]
                #[automatically_derived]
                impl ::core::marker::StructuralPartialEq for Target {}
                #[automatically_derived]
                #[allow(clippy::derive_partial_eq_without_eq)]
                impl ::core::cmp::PartialEq for Target {
                    #[inline]
                    fn eq(&self, other: &Target) -> bool {
                        let __self_tag = ::core::intrinsics::discriminant_value(self);
                        let __arg1_tag = ::core::intrinsics::discriminant_value(other);
                        __self_tag == __arg1_tag
                            && match (self, other) {
                                (
                                    Target::TargetCastId(__self_0),
                                    Target::TargetCastId(__arg1_0),
                                ) => *__self_0 == *__arg1_0,
                                (
                                    Target::TargetUrl(__self_0),
                                    Target::TargetUrl(__arg1_0),
                                ) => *__self_0 == *__arg1_0,
                                _ => unsafe { ::core::intrinsics::unreachable() }
                            }
                    }
                }
                impl Target {
                    /// Encodes the message to a buffer.
                    pub fn encode<B>(&self, buf: &mut B)
                    where
                        B: ::prost::bytes::BufMut,
                    {
                        match *self {
                            Target::TargetCastId(ref value) => {
                                ::prost::encoding::message::encode(1u32, &*value, buf);
                            }
                            Target::TargetUrl(ref value) => {
                                ::prost::encoding::string::encode(6u32, &*value, buf);
                            }
                        }
                    }
                    /// Decodes an instance of the message from a buffer, and merges it into self.
                    pub fn merge<B>(
                        field: &mut ::core::option::Option<Target>,
                        tag: u32,
                        wire_type: ::prost::encoding::WireType,
                        buf: &mut B,
                        ctx: ::prost::encoding::DecodeContext,
                    ) -> ::core::result::Result<(), ::prost::DecodeError>
                    where
                        B: ::prost::bytes::Buf,
                    {
                        match tag {
                            1u32 => {
                                match field {
                                    ::core::option::Option::Some(
                                        Target::TargetCastId(ref mut value),
                                    ) => {
                                        ::prost::encoding::message::merge(
                                            wire_type,
                                            value,
                                            buf,
                                            ctx,
                                        )
                                    }
                                    _ => {
                                        let mut owned_value = ::core::default::Default::default();
                                        let value = &mut owned_value;
                                        ::prost::encoding::message::merge(
                                                wire_type,
                                                value,
                                                buf,
                                                ctx,
                                            )
                                            .map(|_| {
                                                *field = ::core::option::Option::Some(
                                                    Target::TargetCastId(owned_value),
                                                );
                                            })
                                    }
                                }
                            }
                            6u32 => {
                                match field {
                                    ::core::option::Option::Some(
                                        Target::TargetUrl(ref mut value),
                                    ) => {
                                        ::prost::encoding::string::merge(wire_type, value, buf, ctx)
                                    }
                                    _ => {
                                        let mut owned_value = ::core::default::Default::default();
                                        let value = &mut owned_value;
                                        ::prost::encoding::string::merge(wire_type, value, buf, ctx)
                                            .map(|_| {
                                                *field = ::core::option::Option::Some(
                                                    Target::TargetUrl(owned_value),
                                                );
                                            })
                                    }
                                }
                            }
                            _ => {
                                ::core::panicking::panic_fmt(
                                    format_args!(
                                        "internal error: entered unreachable code: {0}",
                                        format_args!("invalid Target tag: {0}", tag),
                                    ),
                                );
                            }
                        }
                    }
                    /// Returns the encoded length of the message without a length delimiter.
                    #[inline]
                    pub fn encoded_len(&self) -> usize {
                        match *self {
                            Target::TargetCastId(ref value) => {
                                ::prost::encoding::message::encoded_len(1u32, &*value)
                            }
                            Target::TargetUrl(ref value) => {
                                ::prost::encoding::string::encoded_len(6u32, &*value)
                            }
                        }
                    }
                }
                impl ::core::fmt::Debug for Target {
                    fn fmt(
                        &self,
                        f: &mut ::core::fmt::Formatter,
                    ) -> ::core::fmt::Result {
                        match *self {
                            Target::TargetCastId(ref value) => {
                                let wrapper = &*value;
                                f.debug_tuple("TargetCastId").field(&wrapper).finish()
                            }
                            Target::TargetUrl(ref value) => {
                                let wrapper = {
                                    fn ScalarWrapper<T>(v: T) -> T {
                                        v
                                    }
                                    ScalarWrapper(&*value)
                                };
                                f.debug_tuple("TargetUrl").field(&wrapper).finish()
                            }
                        }
                    }
                }
            }
            #[allow(clippy::derive_partial_eq_without_eq)]
            pub struct UserDataRequest {
                #[prost(uint64, tag = "1")]
                pub fid: u64,
                #[prost(enumeration = "UserDataType", tag = "2")]
                pub user_data_type: i32,
            }
            #[automatically_derived]
            #[allow(clippy::derive_partial_eq_without_eq)]
            impl ::core::clone::Clone for UserDataRequest {
                #[inline]
                fn clone(&self) -> UserDataRequest {
                    UserDataRequest {
                        fid: ::core::clone::Clone::clone(&self.fid),
                        user_data_type: ::core::clone::Clone::clone(&self.user_data_type),
                    }
                }
            }
            #[allow(clippy::derive_partial_eq_without_eq)]
            #[automatically_derived]
            impl ::core::marker::StructuralPartialEq for UserDataRequest {}
            #[automatically_derived]
            #[allow(clippy::derive_partial_eq_without_eq)]
            impl ::core::cmp::PartialEq for UserDataRequest {
                #[inline]
                fn eq(&self, other: &UserDataRequest) -> bool {
                    self.fid == other.fid && self.user_data_type == other.user_data_type
                }
            }
            impl ::prost::Message for UserDataRequest {
                #[allow(unused_variables)]
                fn encode_raw<B>(&self, buf: &mut B)
                where
                    B: ::prost::bytes::BufMut,
                {
                    if self.fid != 0u64 {
                        ::prost::encoding::uint64::encode(1u32, &self.fid, buf);
                    }
                    if self.user_data_type != UserDataType::default() as i32 {
                        ::prost::encoding::int32::encode(
                            2u32,
                            &self.user_data_type,
                            buf,
                        );
                    }
                }
                #[allow(unused_variables)]
                fn merge_field<B>(
                    &mut self,
                    tag: u32,
                    wire_type: ::prost::encoding::WireType,
                    buf: &mut B,
                    ctx: ::prost::encoding::DecodeContext,
                ) -> ::core::result::Result<(), ::prost::DecodeError>
                where
                    B: ::prost::bytes::Buf,
                {
                    const STRUCT_NAME: &'static str = "UserDataRequest";
                    match tag {
                        1u32 => {
                            let mut value = &mut self.fid;
                            ::prost::encoding::uint64::merge(wire_type, value, buf, ctx)
                                .map_err(|mut error| {
                                    error.push(STRUCT_NAME, "fid");
                                    error
                                })
                        }
                        2u32 => {
                            let mut value = &mut self.user_data_type;
                            ::prost::encoding::int32::merge(wire_type, value, buf, ctx)
                                .map_err(|mut error| {
                                    error.push(STRUCT_NAME, "user_data_type");
                                    error
                                })
                        }
                        _ => ::prost::encoding::skip_field(wire_type, tag, buf, ctx),
                    }
                }
                #[inline]
                fn encoded_len(&self) -> usize {
                    0
                        + if self.fid != 0u64 {
                            ::prost::encoding::uint64::encoded_len(1u32, &self.fid)
                        } else {
                            0
                        }
                        + if self.user_data_type != UserDataType::default() as i32 {
                            ::prost::encoding::int32::encoded_len(
                                2u32,
                                &self.user_data_type,
                            )
                        } else {
                            0
                        }
                }
                fn clear(&mut self) {
                    self.fid = 0u64;
                    self.user_data_type = UserDataType::default() as i32;
                }
            }
            impl ::core::default::Default for UserDataRequest {
                fn default() -> Self {
                    UserDataRequest {
                        fid: 0u64,
                        user_data_type: UserDataType::default() as i32,
                    }
                }
            }
            impl ::core::fmt::Debug for UserDataRequest {
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    let mut builder = f.debug_struct("UserDataRequest");
                    let builder = {
                        let wrapper = {
                            fn ScalarWrapper<T>(v: T) -> T {
                                v
                            }
                            ScalarWrapper(&self.fid)
                        };
                        builder.field("fid", &wrapper)
                    };
                    let builder = {
                        let wrapper = {
                            struct ScalarWrapper<'a>(&'a i32);
                            impl<'a> ::core::fmt::Debug for ScalarWrapper<'a> {
                                fn fmt(
                                    &self,
                                    f: &mut ::core::fmt::Formatter,
                                ) -> ::core::fmt::Result {
                                    match UserDataType::from_i32(*self.0) {
                                        None => ::core::fmt::Debug::fmt(&self.0, f),
                                        Some(en) => ::core::fmt::Debug::fmt(&en, f),
                                    }
                                }
                            }
                            ScalarWrapper(&self.user_data_type)
                        };
                        builder.field("user_data_type", &wrapper)
                    };
                    builder.finish()
                }
            }
            #[allow(dead_code)]
            impl UserDataRequest {
                ///Returns the enum value of `user_data_type`, or the default if the field is set to an invalid enum value.
                pub fn user_data_type(&self) -> UserDataType {
                    UserDataType::from_i32(self.user_data_type)
                        .unwrap_or(UserDataType::default())
                }
                ///Sets `user_data_type` to the provided enum value.
                pub fn set_user_data_type(&mut self, value: UserDataType) {
                    self.user_data_type = value as i32;
                }
            }
            #[allow(clippy::derive_partial_eq_without_eq)]
            pub struct NameRegistryEventRequest {
                #[prost(bytes = "vec", tag = "1")]
                pub name: ::prost::alloc::vec::Vec<u8>,
            }
            #[automatically_derived]
            #[allow(clippy::derive_partial_eq_without_eq)]
            impl ::core::clone::Clone for NameRegistryEventRequest {
                #[inline]
                fn clone(&self) -> NameRegistryEventRequest {
                    NameRegistryEventRequest {
                        name: ::core::clone::Clone::clone(&self.name),
                    }
                }
            }
            #[allow(clippy::derive_partial_eq_without_eq)]
            #[automatically_derived]
            impl ::core::marker::StructuralPartialEq for NameRegistryEventRequest {}
            #[automatically_derived]
            #[allow(clippy::derive_partial_eq_without_eq)]
            impl ::core::cmp::PartialEq for NameRegistryEventRequest {
                #[inline]
                fn eq(&self, other: &NameRegistryEventRequest) -> bool {
                    self.name == other.name
                }
            }
            impl ::prost::Message for NameRegistryEventRequest {
                #[allow(unused_variables)]
                fn encode_raw<B>(&self, buf: &mut B)
                where
                    B: ::prost::bytes::BufMut,
                {
                    if self.name != b"" as &[u8] {
                        ::prost::encoding::bytes::encode(1u32, &self.name, buf);
                    }
                }
                #[allow(unused_variables)]
                fn merge_field<B>(
                    &mut self,
                    tag: u32,
                    wire_type: ::prost::encoding::WireType,
                    buf: &mut B,
                    ctx: ::prost::encoding::DecodeContext,
                ) -> ::core::result::Result<(), ::prost::DecodeError>
                where
                    B: ::prost::bytes::Buf,
                {
                    const STRUCT_NAME: &'static str = "NameRegistryEventRequest";
                    match tag {
                        1u32 => {
                            let mut value = &mut self.name;
                            ::prost::encoding::bytes::merge(wire_type, value, buf, ctx)
                                .map_err(|mut error| {
                                    error.push(STRUCT_NAME, "name");
                                    error
                                })
                        }
                        _ => ::prost::encoding::skip_field(wire_type, tag, buf, ctx),
                    }
                }
                #[inline]
                fn encoded_len(&self) -> usize {
                    0
                        + if self.name != b"" as &[u8] {
                            ::prost::encoding::bytes::encoded_len(1u32, &self.name)
                        } else {
                            0
                        }
                }
                fn clear(&mut self) {
                    self.name.clear();
                }
            }
            impl ::core::default::Default for NameRegistryEventRequest {
                fn default() -> Self {
                    NameRegistryEventRequest {
                        name: ::core::default::Default::default(),
                    }
                }
            }
            impl ::core::fmt::Debug for NameRegistryEventRequest {
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    let mut builder = f.debug_struct("NameRegistryEventRequest");
                    let builder = {
                        let wrapper = {
                            fn ScalarWrapper<T>(v: T) -> T {
                                v
                            }
                            ScalarWrapper(&self.name)
                        };
                        builder.field("name", &wrapper)
                    };
                    builder.finish()
                }
            }
            #[allow(clippy::derive_partial_eq_without_eq)]
            pub struct RentRegistryEventsRequest {
                #[prost(uint64, tag = "1")]
                pub fid: u64,
            }
            #[automatically_derived]
            #[allow(clippy::derive_partial_eq_without_eq)]
            impl ::core::clone::Clone for RentRegistryEventsRequest {
                #[inline]
                fn clone(&self) -> RentRegistryEventsRequest {
                    RentRegistryEventsRequest {
                        fid: ::core::clone::Clone::clone(&self.fid),
                    }
                }
            }
            #[allow(clippy::derive_partial_eq_without_eq)]
            #[automatically_derived]
            impl ::core::marker::StructuralPartialEq for RentRegistryEventsRequest {}
            #[automatically_derived]
            #[allow(clippy::derive_partial_eq_without_eq)]
            impl ::core::cmp::PartialEq for RentRegistryEventsRequest {
                #[inline]
                fn eq(&self, other: &RentRegistryEventsRequest) -> bool {
                    self.fid == other.fid
                }
            }
            impl ::prost::Message for RentRegistryEventsRequest {
                #[allow(unused_variables)]
                fn encode_raw<B>(&self, buf: &mut B)
                where
                    B: ::prost::bytes::BufMut,
                {
                    if self.fid != 0u64 {
                        ::prost::encoding::uint64::encode(1u32, &self.fid, buf);
                    }
                }
                #[allow(unused_variables)]
                fn merge_field<B>(
                    &mut self,
                    tag: u32,
                    wire_type: ::prost::encoding::WireType,
                    buf: &mut B,
                    ctx: ::prost::encoding::DecodeContext,
                ) -> ::core::result::Result<(), ::prost::DecodeError>
                where
                    B: ::prost::bytes::Buf,
                {
                    const STRUCT_NAME: &'static str = "RentRegistryEventsRequest";
                    match tag {
                        1u32 => {
                            let mut value = &mut self.fid;
                            ::prost::encoding::uint64::merge(wire_type, value, buf, ctx)
                                .map_err(|mut error| {
                                    error.push(STRUCT_NAME, "fid");
                                    error
                                })
                        }
                        _ => ::prost::encoding::skip_field(wire_type, tag, buf, ctx),
                    }
                }
                #[inline]
                fn encoded_len(&self) -> usize {
                    0
                        + if self.fid != 0u64 {
                            ::prost::encoding::uint64::encoded_len(1u32, &self.fid)
                        } else {
                            0
                        }
                }
                fn clear(&mut self) {
                    self.fid = 0u64;
                }
            }
            impl ::core::default::Default for RentRegistryEventsRequest {
                fn default() -> Self {
                    RentRegistryEventsRequest {
                        fid: 0u64,
                    }
                }
            }
            impl ::core::fmt::Debug for RentRegistryEventsRequest {
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    let mut builder = f.debug_struct("RentRegistryEventsRequest");
                    let builder = {
                        let wrapper = {
                            fn ScalarWrapper<T>(v: T) -> T {
                                v
                            }
                            ScalarWrapper(&self.fid)
                        };
                        builder.field("fid", &wrapper)
                    };
                    builder.finish()
                }
            }
            #[allow(clippy::derive_partial_eq_without_eq)]
            pub struct OnChainEventRequest {
                #[prost(uint64, tag = "1")]
                pub fid: u64,
                #[prost(enumeration = "OnChainEventType", tag = "2")]
                pub event_type: i32,
            }
            #[automatically_derived]
            #[allow(clippy::derive_partial_eq_without_eq)]
            impl ::core::clone::Clone for OnChainEventRequest {
                #[inline]
                fn clone(&self) -> OnChainEventRequest {
                    OnChainEventRequest {
                        fid: ::core::clone::Clone::clone(&self.fid),
                        event_type: ::core::clone::Clone::clone(&self.event_type),
                    }
                }
            }
            #[allow(clippy::derive_partial_eq_without_eq)]
            #[automatically_derived]
            impl ::core::marker::StructuralPartialEq for OnChainEventRequest {}
            #[automatically_derived]
            #[allow(clippy::derive_partial_eq_without_eq)]
            impl ::core::cmp::PartialEq for OnChainEventRequest {
                #[inline]
                fn eq(&self, other: &OnChainEventRequest) -> bool {
                    self.fid == other.fid && self.event_type == other.event_type
                }
            }
            impl ::prost::Message for OnChainEventRequest {
                #[allow(unused_variables)]
                fn encode_raw<B>(&self, buf: &mut B)
                where
                    B: ::prost::bytes::BufMut,
                {
                    if self.fid != 0u64 {
                        ::prost::encoding::uint64::encode(1u32, &self.fid, buf);
                    }
                    if self.event_type != OnChainEventType::default() as i32 {
                        ::prost::encoding::int32::encode(2u32, &self.event_type, buf);
                    }
                }
                #[allow(unused_variables)]
                fn merge_field<B>(
                    &mut self,
                    tag: u32,
                    wire_type: ::prost::encoding::WireType,
                    buf: &mut B,
                    ctx: ::prost::encoding::DecodeContext,
                ) -> ::core::result::Result<(), ::prost::DecodeError>
                where
                    B: ::prost::bytes::Buf,
                {
                    const STRUCT_NAME: &'static str = "OnChainEventRequest";
                    match tag {
                        1u32 => {
                            let mut value = &mut self.fid;
                            ::prost::encoding::uint64::merge(wire_type, value, buf, ctx)
                                .map_err(|mut error| {
                                    error.push(STRUCT_NAME, "fid");
                                    error
                                })
                        }
                        2u32 => {
                            let mut value = &mut self.event_type;
                            ::prost::encoding::int32::merge(wire_type, value, buf, ctx)
                                .map_err(|mut error| {
                                    error.push(STRUCT_NAME, "event_type");
                                    error
                                })
                        }
                        _ => ::prost::encoding::skip_field(wire_type, tag, buf, ctx),
                    }
                }
                #[inline]
                fn encoded_len(&self) -> usize {
                    0
                        + if self.fid != 0u64 {
                            ::prost::encoding::uint64::encoded_len(1u32, &self.fid)
                        } else {
                            0
                        }
                        + if self.event_type != OnChainEventType::default() as i32 {
                            ::prost::encoding::int32::encoded_len(2u32, &self.event_type)
                        } else {
                            0
                        }
                }
                fn clear(&mut self) {
                    self.fid = 0u64;
                    self.event_type = OnChainEventType::default() as i32;
                }
            }
            impl ::core::default::Default for OnChainEventRequest {
                fn default() -> Self {
                    OnChainEventRequest {
                        fid: 0u64,
                        event_type: OnChainEventType::default() as i32,
                    }
                }
            }
            impl ::core::fmt::Debug for OnChainEventRequest {
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    let mut builder = f.debug_struct("OnChainEventRequest");
                    let builder = {
                        let wrapper = {
                            fn ScalarWrapper<T>(v: T) -> T {
                                v
                            }
                            ScalarWrapper(&self.fid)
                        };
                        builder.field("fid", &wrapper)
                    };
                    let builder = {
                        let wrapper = {
                            struct ScalarWrapper<'a>(&'a i32);
                            impl<'a> ::core::fmt::Debug for ScalarWrapper<'a> {
                                fn fmt(
                                    &self,
                                    f: &mut ::core::fmt::Formatter,
                                ) -> ::core::fmt::Result {
                                    match OnChainEventType::from_i32(*self.0) {
                                        None => ::core::fmt::Debug::fmt(&self.0, f),
                                        Some(en) => ::core::fmt::Debug::fmt(&en, f),
                                    }
                                }
                            }
                            ScalarWrapper(&self.event_type)
                        };
                        builder.field("event_type", &wrapper)
                    };
                    builder.finish()
                }
            }
            #[allow(dead_code)]
            impl OnChainEventRequest {
                ///Returns the enum value of `event_type`, or the default if the field is set to an invalid enum value.
                pub fn event_type(&self) -> OnChainEventType {
                    OnChainEventType::from_i32(self.event_type)
                        .unwrap_or(OnChainEventType::default())
                }
                ///Sets `event_type` to the provided enum value.
                pub fn set_event_type(&mut self, value: OnChainEventType) {
                    self.event_type = value as i32;
                }
            }
            #[allow(clippy::derive_partial_eq_without_eq)]
            pub struct OnChainEventResponse {
                #[prost(message, repeated, tag = "1")]
                pub events: ::prost::alloc::vec::Vec<OnChainEvent>,
            }
            #[automatically_derived]
            #[allow(clippy::derive_partial_eq_without_eq)]
            impl ::core::clone::Clone for OnChainEventResponse {
                #[inline]
                fn clone(&self) -> OnChainEventResponse {
                    OnChainEventResponse {
                        events: ::core::clone::Clone::clone(&self.events),
                    }
                }
            }
            #[allow(clippy::derive_partial_eq_without_eq)]
            #[automatically_derived]
            impl ::core::marker::StructuralPartialEq for OnChainEventResponse {}
            #[automatically_derived]
            #[allow(clippy::derive_partial_eq_without_eq)]
            impl ::core::cmp::PartialEq for OnChainEventResponse {
                #[inline]
                fn eq(&self, other: &OnChainEventResponse) -> bool {
                    self.events == other.events
                }
            }
            impl ::prost::Message for OnChainEventResponse {
                #[allow(unused_variables)]
                fn encode_raw<B>(&self, buf: &mut B)
                where
                    B: ::prost::bytes::BufMut,
                {
                    for msg in &self.events {
                        ::prost::encoding::message::encode(1u32, msg, buf);
                    }
                }
                #[allow(unused_variables)]
                fn merge_field<B>(
                    &mut self,
                    tag: u32,
                    wire_type: ::prost::encoding::WireType,
                    buf: &mut B,
                    ctx: ::prost::encoding::DecodeContext,
                ) -> ::core::result::Result<(), ::prost::DecodeError>
                where
                    B: ::prost::bytes::Buf,
                {
                    const STRUCT_NAME: &'static str = "OnChainEventResponse";
                    match tag {
                        1u32 => {
                            let mut value = &mut self.events;
                            ::prost::encoding::message::merge_repeated(
                                    wire_type,
                                    value,
                                    buf,
                                    ctx,
                                )
                                .map_err(|mut error| {
                                    error.push(STRUCT_NAME, "events");
                                    error
                                })
                        }
                        _ => ::prost::encoding::skip_field(wire_type, tag, buf, ctx),
                    }
                }
                #[inline]
                fn encoded_len(&self) -> usize {
                    0
                        + ::prost::encoding::message::encoded_len_repeated(
                            1u32,
                            &self.events,
                        )
                }
                fn clear(&mut self) {
                    self.events.clear();
                }
            }
            impl ::core::default::Default for OnChainEventResponse {
                fn default() -> Self {
                    OnChainEventResponse {
                        events: ::core::default::Default::default(),
                    }
                }
            }
            impl ::core::fmt::Debug for OnChainEventResponse {
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    let mut builder = f.debug_struct("OnChainEventResponse");
                    let builder = {
                        let wrapper = &self.events;
                        builder.field("events", &wrapper)
                    };
                    builder.finish()
                }
            }
            #[allow(clippy::derive_partial_eq_without_eq)]
            pub struct StorageLimitsResponse {
                #[prost(message, repeated, tag = "1")]
                pub limits: ::prost::alloc::vec::Vec<StorageLimit>,
            }
            #[automatically_derived]
            #[allow(clippy::derive_partial_eq_without_eq)]
            impl ::core::clone::Clone for StorageLimitsResponse {
                #[inline]
                fn clone(&self) -> StorageLimitsResponse {
                    StorageLimitsResponse {
                        limits: ::core::clone::Clone::clone(&self.limits),
                    }
                }
            }
            #[allow(clippy::derive_partial_eq_without_eq)]
            #[automatically_derived]
            impl ::core::marker::StructuralPartialEq for StorageLimitsResponse {}
            #[automatically_derived]
            #[allow(clippy::derive_partial_eq_without_eq)]
            impl ::core::cmp::PartialEq for StorageLimitsResponse {
                #[inline]
                fn eq(&self, other: &StorageLimitsResponse) -> bool {
                    self.limits == other.limits
                }
            }
            impl ::prost::Message for StorageLimitsResponse {
                #[allow(unused_variables)]
                fn encode_raw<B>(&self, buf: &mut B)
                where
                    B: ::prost::bytes::BufMut,
                {
                    for msg in &self.limits {
                        ::prost::encoding::message::encode(1u32, msg, buf);
                    }
                }
                #[allow(unused_variables)]
                fn merge_field<B>(
                    &mut self,
                    tag: u32,
                    wire_type: ::prost::encoding::WireType,
                    buf: &mut B,
                    ctx: ::prost::encoding::DecodeContext,
                ) -> ::core::result::Result<(), ::prost::DecodeError>
                where
                    B: ::prost::bytes::Buf,
                {
                    const STRUCT_NAME: &'static str = "StorageLimitsResponse";
                    match tag {
                        1u32 => {
                            let mut value = &mut self.limits;
                            ::prost::encoding::message::merge_repeated(
                                    wire_type,
                                    value,
                                    buf,
                                    ctx,
                                )
                                .map_err(|mut error| {
                                    error.push(STRUCT_NAME, "limits");
                                    error
                                })
                        }
                        _ => ::prost::encoding::skip_field(wire_type, tag, buf, ctx),
                    }
                }
                #[inline]
                fn encoded_len(&self) -> usize {
                    0
                        + ::prost::encoding::message::encoded_len_repeated(
                            1u32,
                            &self.limits,
                        )
                }
                fn clear(&mut self) {
                    self.limits.clear();
                }
            }
            impl ::core::default::Default for StorageLimitsResponse {
                fn default() -> Self {
                    StorageLimitsResponse {
                        limits: ::core::default::Default::default(),
                    }
                }
            }
            impl ::core::fmt::Debug for StorageLimitsResponse {
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    let mut builder = f.debug_struct("StorageLimitsResponse");
                    let builder = {
                        let wrapper = &self.limits;
                        builder.field("limits", &wrapper)
                    };
                    builder.finish()
                }
            }
            #[allow(clippy::derive_partial_eq_without_eq)]
            pub struct StorageLimit {
                #[prost(enumeration = "StoreType", tag = "1")]
                pub store_type: i32,
                #[prost(uint64, tag = "2")]
                pub limit: u64,
            }
            #[automatically_derived]
            #[allow(clippy::derive_partial_eq_without_eq)]
            impl ::core::clone::Clone for StorageLimit {
                #[inline]
                fn clone(&self) -> StorageLimit {
                    StorageLimit {
                        store_type: ::core::clone::Clone::clone(&self.store_type),
                        limit: ::core::clone::Clone::clone(&self.limit),
                    }
                }
            }
            #[allow(clippy::derive_partial_eq_without_eq)]
            #[automatically_derived]
            impl ::core::marker::StructuralPartialEq for StorageLimit {}
            #[automatically_derived]
            #[allow(clippy::derive_partial_eq_without_eq)]
            impl ::core::cmp::PartialEq for StorageLimit {
                #[inline]
                fn eq(&self, other: &StorageLimit) -> bool {
                    self.store_type == other.store_type && self.limit == other.limit
                }
            }
            impl ::prost::Message for StorageLimit {
                #[allow(unused_variables)]
                fn encode_raw<B>(&self, buf: &mut B)
                where
                    B: ::prost::bytes::BufMut,
                {
                    if self.store_type != StoreType::default() as i32 {
                        ::prost::encoding::int32::encode(1u32, &self.store_type, buf);
                    }
                    if self.limit != 0u64 {
                        ::prost::encoding::uint64::encode(2u32, &self.limit, buf);
                    }
                }
                #[allow(unused_variables)]
                fn merge_field<B>(
                    &mut self,
                    tag: u32,
                    wire_type: ::prost::encoding::WireType,
                    buf: &mut B,
                    ctx: ::prost::encoding::DecodeContext,
                ) -> ::core::result::Result<(), ::prost::DecodeError>
                where
                    B: ::prost::bytes::Buf,
                {
                    const STRUCT_NAME: &'static str = "StorageLimit";
                    match tag {
                        1u32 => {
                            let mut value = &mut self.store_type;
                            ::prost::encoding::int32::merge(wire_type, value, buf, ctx)
                                .map_err(|mut error| {
                                    error.push(STRUCT_NAME, "store_type");
                                    error
                                })
                        }
                        2u32 => {
                            let mut value = &mut self.limit;
                            ::prost::encoding::uint64::merge(wire_type, value, buf, ctx)
                                .map_err(|mut error| {
                                    error.push(STRUCT_NAME, "limit");
                                    error
                                })
                        }
                        _ => ::prost::encoding::skip_field(wire_type, tag, buf, ctx),
                    }
                }
                #[inline]
                fn encoded_len(&self) -> usize {
                    0
                        + if self.store_type != StoreType::default() as i32 {
                            ::prost::encoding::int32::encoded_len(1u32, &self.store_type)
                        } else {
                            0
                        }
                        + if self.limit != 0u64 {
                            ::prost::encoding::uint64::encoded_len(2u32, &self.limit)
                        } else {
                            0
                        }
                }
                fn clear(&mut self) {
                    self.store_type = StoreType::default() as i32;
                    self.limit = 0u64;
                }
            }
            impl ::core::default::Default for StorageLimit {
                fn default() -> Self {
                    StorageLimit {
                        store_type: StoreType::default() as i32,
                        limit: 0u64,
                    }
                }
            }
            impl ::core::fmt::Debug for StorageLimit {
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    let mut builder = f.debug_struct("StorageLimit");
                    let builder = {
                        let wrapper = {
                            struct ScalarWrapper<'a>(&'a i32);
                            impl<'a> ::core::fmt::Debug for ScalarWrapper<'a> {
                                fn fmt(
                                    &self,
                                    f: &mut ::core::fmt::Formatter,
                                ) -> ::core::fmt::Result {
                                    match StoreType::from_i32(*self.0) {
                                        None => ::core::fmt::Debug::fmt(&self.0, f),
                                        Some(en) => ::core::fmt::Debug::fmt(&en, f),
                                    }
                                }
                            }
                            ScalarWrapper(&self.store_type)
                        };
                        builder.field("store_type", &wrapper)
                    };
                    let builder = {
                        let wrapper = {
                            fn ScalarWrapper<T>(v: T) -> T {
                                v
                            }
                            ScalarWrapper(&self.limit)
                        };
                        builder.field("limit", &wrapper)
                    };
                    builder.finish()
                }
            }
            #[allow(dead_code)]
            impl StorageLimit {
                ///Returns the enum value of `store_type`, or the default if the field is set to an invalid enum value.
                pub fn store_type(&self) -> StoreType {
                    StoreType::from_i32(self.store_type).unwrap_or(StoreType::default())
                }
                ///Sets `store_type` to the provided enum value.
                pub fn set_store_type(&mut self, value: StoreType) {
                    self.store_type = value as i32;
                }
            }
            #[allow(clippy::derive_partial_eq_without_eq)]
            pub struct UsernameProofRequest {
                #[prost(bytes = "vec", tag = "1")]
                pub name: ::prost::alloc::vec::Vec<u8>,
            }
            #[automatically_derived]
            #[allow(clippy::derive_partial_eq_without_eq)]
            impl ::core::clone::Clone for UsernameProofRequest {
                #[inline]
                fn clone(&self) -> UsernameProofRequest {
                    UsernameProofRequest {
                        name: ::core::clone::Clone::clone(&self.name),
                    }
                }
            }
            #[allow(clippy::derive_partial_eq_without_eq)]
            #[automatically_derived]
            impl ::core::marker::StructuralPartialEq for UsernameProofRequest {}
            #[automatically_derived]
            #[allow(clippy::derive_partial_eq_without_eq)]
            impl ::core::cmp::PartialEq for UsernameProofRequest {
                #[inline]
                fn eq(&self, other: &UsernameProofRequest) -> bool {
                    self.name == other.name
                }
            }
            impl ::prost::Message for UsernameProofRequest {
                #[allow(unused_variables)]
                fn encode_raw<B>(&self, buf: &mut B)
                where
                    B: ::prost::bytes::BufMut,
                {
                    if self.name != b"" as &[u8] {
                        ::prost::encoding::bytes::encode(1u32, &self.name, buf);
                    }
                }
                #[allow(unused_variables)]
                fn merge_field<B>(
                    &mut self,
                    tag: u32,
                    wire_type: ::prost::encoding::WireType,
                    buf: &mut B,
                    ctx: ::prost::encoding::DecodeContext,
                ) -> ::core::result::Result<(), ::prost::DecodeError>
                where
                    B: ::prost::bytes::Buf,
                {
                    const STRUCT_NAME: &'static str = "UsernameProofRequest";
                    match tag {
                        1u32 => {
                            let mut value = &mut self.name;
                            ::prost::encoding::bytes::merge(wire_type, value, buf, ctx)
                                .map_err(|mut error| {
                                    error.push(STRUCT_NAME, "name");
                                    error
                                })
                        }
                        _ => ::prost::encoding::skip_field(wire_type, tag, buf, ctx),
                    }
                }
                #[inline]
                fn encoded_len(&self) -> usize {
                    0
                        + if self.name != b"" as &[u8] {
                            ::prost::encoding::bytes::encoded_len(1u32, &self.name)
                        } else {
                            0
                        }
                }
                fn clear(&mut self) {
                    self.name.clear();
                }
            }
            impl ::core::default::Default for UsernameProofRequest {
                fn default() -> Self {
                    UsernameProofRequest {
                        name: ::core::default::Default::default(),
                    }
                }
            }
            impl ::core::fmt::Debug for UsernameProofRequest {
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    let mut builder = f.debug_struct("UsernameProofRequest");
                    let builder = {
                        let wrapper = {
                            fn ScalarWrapper<T>(v: T) -> T {
                                v
                            }
                            ScalarWrapper(&self.name)
                        };
                        builder.field("name", &wrapper)
                    };
                    builder.finish()
                }
            }
            #[allow(clippy::derive_partial_eq_without_eq)]
            pub struct UsernameProofsResponse {
                #[prost(message, repeated, tag = "1")]
                pub proofs: ::prost::alloc::vec::Vec<UserNameProof>,
            }
            #[automatically_derived]
            #[allow(clippy::derive_partial_eq_without_eq)]
            impl ::core::clone::Clone for UsernameProofsResponse {
                #[inline]
                fn clone(&self) -> UsernameProofsResponse {
                    UsernameProofsResponse {
                        proofs: ::core::clone::Clone::clone(&self.proofs),
                    }
                }
            }
            #[allow(clippy::derive_partial_eq_without_eq)]
            #[automatically_derived]
            impl ::core::marker::StructuralPartialEq for UsernameProofsResponse {}
            #[automatically_derived]
            #[allow(clippy::derive_partial_eq_without_eq)]
            impl ::core::cmp::PartialEq for UsernameProofsResponse {
                #[inline]
                fn eq(&self, other: &UsernameProofsResponse) -> bool {
                    self.proofs == other.proofs
                }
            }
            impl ::prost::Message for UsernameProofsResponse {
                #[allow(unused_variables)]
                fn encode_raw<B>(&self, buf: &mut B)
                where
                    B: ::prost::bytes::BufMut,
                {
                    for msg in &self.proofs {
                        ::prost::encoding::message::encode(1u32, msg, buf);
                    }
                }
                #[allow(unused_variables)]
                fn merge_field<B>(
                    &mut self,
                    tag: u32,
                    wire_type: ::prost::encoding::WireType,
                    buf: &mut B,
                    ctx: ::prost::encoding::DecodeContext,
                ) -> ::core::result::Result<(), ::prost::DecodeError>
                where
                    B: ::prost::bytes::Buf,
                {
                    const STRUCT_NAME: &'static str = "UsernameProofsResponse";
                    match tag {
                        1u32 => {
                            let mut value = &mut self.proofs;
                            ::prost::encoding::message::merge_repeated(
                                    wire_type,
                                    value,
                                    buf,
                                    ctx,
                                )
                                .map_err(|mut error| {
                                    error.push(STRUCT_NAME, "proofs");
                                    error
                                })
                        }
                        _ => ::prost::encoding::skip_field(wire_type, tag, buf, ctx),
                    }
                }
                #[inline]
                fn encoded_len(&self) -> usize {
                    0
                        + ::prost::encoding::message::encoded_len_repeated(
                            1u32,
                            &self.proofs,
                        )
                }
                fn clear(&mut self) {
                    self.proofs.clear();
                }
            }
            impl ::core::default::Default for UsernameProofsResponse {
                fn default() -> Self {
                    UsernameProofsResponse {
                        proofs: ::core::default::Default::default(),
                    }
                }
            }
            impl ::core::fmt::Debug for UsernameProofsResponse {
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    let mut builder = f.debug_struct("UsernameProofsResponse");
                    let builder = {
                        let wrapper = &self.proofs;
                        builder.field("proofs", &wrapper)
                    };
                    builder.finish()
                }
            }
            #[allow(clippy::derive_partial_eq_without_eq)]
            pub struct VerificationRequest {
                #[prost(uint64, tag = "1")]
                pub fid: u64,
                #[prost(bytes = "vec", tag = "2")]
                pub address: ::prost::alloc::vec::Vec<u8>,
            }
            #[automatically_derived]
            #[allow(clippy::derive_partial_eq_without_eq)]
            impl ::core::clone::Clone for VerificationRequest {
                #[inline]
                fn clone(&self) -> VerificationRequest {
                    VerificationRequest {
                        fid: ::core::clone::Clone::clone(&self.fid),
                        address: ::core::clone::Clone::clone(&self.address),
                    }
                }
            }
            #[allow(clippy::derive_partial_eq_without_eq)]
            #[automatically_derived]
            impl ::core::marker::StructuralPartialEq for VerificationRequest {}
            #[automatically_derived]
            #[allow(clippy::derive_partial_eq_without_eq)]
            impl ::core::cmp::PartialEq for VerificationRequest {
                #[inline]
                fn eq(&self, other: &VerificationRequest) -> bool {
                    self.fid == other.fid && self.address == other.address
                }
            }
            impl ::prost::Message for VerificationRequest {
                #[allow(unused_variables)]
                fn encode_raw<B>(&self, buf: &mut B)
                where
                    B: ::prost::bytes::BufMut,
                {
                    if self.fid != 0u64 {
                        ::prost::encoding::uint64::encode(1u32, &self.fid, buf);
                    }
                    if self.address != b"" as &[u8] {
                        ::prost::encoding::bytes::encode(2u32, &self.address, buf);
                    }
                }
                #[allow(unused_variables)]
                fn merge_field<B>(
                    &mut self,
                    tag: u32,
                    wire_type: ::prost::encoding::WireType,
                    buf: &mut B,
                    ctx: ::prost::encoding::DecodeContext,
                ) -> ::core::result::Result<(), ::prost::DecodeError>
                where
                    B: ::prost::bytes::Buf,
                {
                    const STRUCT_NAME: &'static str = "VerificationRequest";
                    match tag {
                        1u32 => {
                            let mut value = &mut self.fid;
                            ::prost::encoding::uint64::merge(wire_type, value, buf, ctx)
                                .map_err(|mut error| {
                                    error.push(STRUCT_NAME, "fid");
                                    error
                                })
                        }
                        2u32 => {
                            let mut value = &mut self.address;
                            ::prost::encoding::bytes::merge(wire_type, value, buf, ctx)
                                .map_err(|mut error| {
                                    error.push(STRUCT_NAME, "address");
                                    error
                                })
                        }
                        _ => ::prost::encoding::skip_field(wire_type, tag, buf, ctx),
                    }
                }
                #[inline]
                fn encoded_len(&self) -> usize {
                    0
                        + if self.fid != 0u64 {
                            ::prost::encoding::uint64::encoded_len(1u32, &self.fid)
                        } else {
                            0
                        }
                        + if self.address != b"" as &[u8] {
                            ::prost::encoding::bytes::encoded_len(2u32, &self.address)
                        } else {
                            0
                        }
                }
                fn clear(&mut self) {
                    self.fid = 0u64;
                    self.address.clear();
                }
            }
            impl ::core::default::Default for VerificationRequest {
                fn default() -> Self {
                    VerificationRequest {
                        fid: 0u64,
                        address: ::core::default::Default::default(),
                    }
                }
            }
            impl ::core::fmt::Debug for VerificationRequest {
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    let mut builder = f.debug_struct("VerificationRequest");
                    let builder = {
                        let wrapper = {
                            fn ScalarWrapper<T>(v: T) -> T {
                                v
                            }
                            ScalarWrapper(&self.fid)
                        };
                        builder.field("fid", &wrapper)
                    };
                    let builder = {
                        let wrapper = {
                            fn ScalarWrapper<T>(v: T) -> T {
                                v
                            }
                            ScalarWrapper(&self.address)
                        };
                        builder.field("address", &wrapper)
                    };
                    builder.finish()
                }
            }
            #[allow(clippy::derive_partial_eq_without_eq)]
            pub struct SignerRequest {
                #[prost(uint64, tag = "1")]
                pub fid: u64,
                #[prost(bytes = "vec", tag = "2")]
                pub signer: ::prost::alloc::vec::Vec<u8>,
            }
            #[automatically_derived]
            #[allow(clippy::derive_partial_eq_without_eq)]
            impl ::core::clone::Clone for SignerRequest {
                #[inline]
                fn clone(&self) -> SignerRequest {
                    SignerRequest {
                        fid: ::core::clone::Clone::clone(&self.fid),
                        signer: ::core::clone::Clone::clone(&self.signer),
                    }
                }
            }
            #[allow(clippy::derive_partial_eq_without_eq)]
            #[automatically_derived]
            impl ::core::marker::StructuralPartialEq for SignerRequest {}
            #[automatically_derived]
            #[allow(clippy::derive_partial_eq_without_eq)]
            impl ::core::cmp::PartialEq for SignerRequest {
                #[inline]
                fn eq(&self, other: &SignerRequest) -> bool {
                    self.fid == other.fid && self.signer == other.signer
                }
            }
            impl ::prost::Message for SignerRequest {
                #[allow(unused_variables)]
                fn encode_raw<B>(&self, buf: &mut B)
                where
                    B: ::prost::bytes::BufMut,
                {
                    if self.fid != 0u64 {
                        ::prost::encoding::uint64::encode(1u32, &self.fid, buf);
                    }
                    if self.signer != b"" as &[u8] {
                        ::prost::encoding::bytes::encode(2u32, &self.signer, buf);
                    }
                }
                #[allow(unused_variables)]
                fn merge_field<B>(
                    &mut self,
                    tag: u32,
                    wire_type: ::prost::encoding::WireType,
                    buf: &mut B,
                    ctx: ::prost::encoding::DecodeContext,
                ) -> ::core::result::Result<(), ::prost::DecodeError>
                where
                    B: ::prost::bytes::Buf,
                {
                    const STRUCT_NAME: &'static str = "SignerRequest";
                    match tag {
                        1u32 => {
                            let mut value = &mut self.fid;
                            ::prost::encoding::uint64::merge(wire_type, value, buf, ctx)
                                .map_err(|mut error| {
                                    error.push(STRUCT_NAME, "fid");
                                    error
                                })
                        }
                        2u32 => {
                            let mut value = &mut self.signer;
                            ::prost::encoding::bytes::merge(wire_type, value, buf, ctx)
                                .map_err(|mut error| {
                                    error.push(STRUCT_NAME, "signer");
                                    error
                                })
                        }
                        _ => ::prost::encoding::skip_field(wire_type, tag, buf, ctx),
                    }
                }
                #[inline]
                fn encoded_len(&self) -> usize {
                    0
                        + if self.fid != 0u64 {
                            ::prost::encoding::uint64::encoded_len(1u32, &self.fid)
                        } else {
                            0
                        }
                        + if self.signer != b"" as &[u8] {
                            ::prost::encoding::bytes::encoded_len(2u32, &self.signer)
                        } else {
                            0
                        }
                }
                fn clear(&mut self) {
                    self.fid = 0u64;
                    self.signer.clear();
                }
            }
            impl ::core::default::Default for SignerRequest {
                fn default() -> Self {
                    SignerRequest {
                        fid: 0u64,
                        signer: ::core::default::Default::default(),
                    }
                }
            }
            impl ::core::fmt::Debug for SignerRequest {
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    let mut builder = f.debug_struct("SignerRequest");
                    let builder = {
                        let wrapper = {
                            fn ScalarWrapper<T>(v: T) -> T {
                                v
                            }
                            ScalarWrapper(&self.fid)
                        };
                        builder.field("fid", &wrapper)
                    };
                    let builder = {
                        let wrapper = {
                            fn ScalarWrapper<T>(v: T) -> T {
                                v
                            }
                            ScalarWrapper(&self.signer)
                        };
                        builder.field("signer", &wrapper)
                    };
                    builder.finish()
                }
            }
            #[allow(clippy::derive_partial_eq_without_eq)]
            pub struct LinkRequest {
                #[prost(uint64, tag = "1")]
                pub fid: u64,
                #[prost(string, tag = "2")]
                pub link_type: ::prost::alloc::string::String,
                #[prost(oneof = "link_request::Target", tags = "3")]
                pub target: ::core::option::Option<link_request::Target>,
            }
            #[automatically_derived]
            #[allow(clippy::derive_partial_eq_without_eq)]
            impl ::core::clone::Clone for LinkRequest {
                #[inline]
                fn clone(&self) -> LinkRequest {
                    LinkRequest {
                        fid: ::core::clone::Clone::clone(&self.fid),
                        link_type: ::core::clone::Clone::clone(&self.link_type),
                        target: ::core::clone::Clone::clone(&self.target),
                    }
                }
            }
            #[allow(clippy::derive_partial_eq_without_eq)]
            #[automatically_derived]
            impl ::core::marker::StructuralPartialEq for LinkRequest {}
            #[automatically_derived]
            #[allow(clippy::derive_partial_eq_without_eq)]
            impl ::core::cmp::PartialEq for LinkRequest {
                #[inline]
                fn eq(&self, other: &LinkRequest) -> bool {
                    self.fid == other.fid && self.link_type == other.link_type
                        && self.target == other.target
                }
            }
            impl ::prost::Message for LinkRequest {
                #[allow(unused_variables)]
                fn encode_raw<B>(&self, buf: &mut B)
                where
                    B: ::prost::bytes::BufMut,
                {
                    if self.fid != 0u64 {
                        ::prost::encoding::uint64::encode(1u32, &self.fid, buf);
                    }
                    if self.link_type != "" {
                        ::prost::encoding::string::encode(2u32, &self.link_type, buf);
                    }
                    if let Some(ref oneof) = self.target {
                        oneof.encode(buf)
                    }
                }
                #[allow(unused_variables)]
                fn merge_field<B>(
                    &mut self,
                    tag: u32,
                    wire_type: ::prost::encoding::WireType,
                    buf: &mut B,
                    ctx: ::prost::encoding::DecodeContext,
                ) -> ::core::result::Result<(), ::prost::DecodeError>
                where
                    B: ::prost::bytes::Buf,
                {
                    const STRUCT_NAME: &'static str = "LinkRequest";
                    match tag {
                        1u32 => {
                            let mut value = &mut self.fid;
                            ::prost::encoding::uint64::merge(wire_type, value, buf, ctx)
                                .map_err(|mut error| {
                                    error.push(STRUCT_NAME, "fid");
                                    error
                                })
                        }
                        2u32 => {
                            let mut value = &mut self.link_type;
                            ::prost::encoding::string::merge(wire_type, value, buf, ctx)
                                .map_err(|mut error| {
                                    error.push(STRUCT_NAME, "link_type");
                                    error
                                })
                        }
                        3u32 => {
                            let mut value = &mut self.target;
                            link_request::Target::merge(value, tag, wire_type, buf, ctx)
                                .map_err(|mut error| {
                                    error.push(STRUCT_NAME, "target");
                                    error
                                })
                        }
                        _ => ::prost::encoding::skip_field(wire_type, tag, buf, ctx),
                    }
                }
                #[inline]
                fn encoded_len(&self) -> usize {
                    0
                        + if self.fid != 0u64 {
                            ::prost::encoding::uint64::encoded_len(1u32, &self.fid)
                        } else {
                            0
                        }
                        + if self.link_type != "" {
                            ::prost::encoding::string::encoded_len(2u32, &self.link_type)
                        } else {
                            0
                        }
                        + self
                            .target
                            .as_ref()
                            .map_or(0, link_request::Target::encoded_len)
                }
                fn clear(&mut self) {
                    self.fid = 0u64;
                    self.link_type.clear();
                    self.target = ::core::option::Option::None;
                }
            }
            impl ::core::default::Default for LinkRequest {
                fn default() -> Self {
                    LinkRequest {
                        fid: 0u64,
                        link_type: ::prost::alloc::string::String::new(),
                        target: ::core::default::Default::default(),
                    }
                }
            }
            impl ::core::fmt::Debug for LinkRequest {
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    let mut builder = f.debug_struct("LinkRequest");
                    let builder = {
                        let wrapper = {
                            fn ScalarWrapper<T>(v: T) -> T {
                                v
                            }
                            ScalarWrapper(&self.fid)
                        };
                        builder.field("fid", &wrapper)
                    };
                    let builder = {
                        let wrapper = {
                            fn ScalarWrapper<T>(v: T) -> T {
                                v
                            }
                            ScalarWrapper(&self.link_type)
                        };
                        builder.field("link_type", &wrapper)
                    };
                    let builder = {
                        let wrapper = &self.target;
                        builder.field("target", &wrapper)
                    };
                    builder.finish()
                }
            }
            /// Nested message and enum types in `LinkRequest`.
            pub mod link_request {
                #[allow(clippy::derive_partial_eq_without_eq)]
                pub enum Target {
                    #[prost(uint64, tag = "3")]
                    TargetFid(u64),
                }
                #[automatically_derived]
                #[allow(clippy::derive_partial_eq_without_eq)]
                impl ::core::clone::Clone for Target {
                    #[inline]
                    fn clone(&self) -> Target {
                        match self {
                            Target::TargetFid(__self_0) => {
                                Target::TargetFid(::core::clone::Clone::clone(__self_0))
                            }
                        }
                    }
                }
                #[allow(clippy::derive_partial_eq_without_eq)]
                #[automatically_derived]
                impl ::core::marker::StructuralPartialEq for Target {}
                #[automatically_derived]
                #[allow(clippy::derive_partial_eq_without_eq)]
                impl ::core::cmp::PartialEq for Target {
                    #[inline]
                    fn eq(&self, other: &Target) -> bool {
                        match (self, other) {
                            (
                                Target::TargetFid(__self_0),
                                Target::TargetFid(__arg1_0),
                            ) => *__self_0 == *__arg1_0,
                        }
                    }
                }
                impl Target {
                    /// Encodes the message to a buffer.
                    pub fn encode<B>(&self, buf: &mut B)
                    where
                        B: ::prost::bytes::BufMut,
                    {
                        match *self {
                            Target::TargetFid(ref value) => {
                                ::prost::encoding::uint64::encode(3u32, &*value, buf);
                            }
                        }
                    }
                    /// Decodes an instance of the message from a buffer, and merges it into self.
                    pub fn merge<B>(
                        field: &mut ::core::option::Option<Target>,
                        tag: u32,
                        wire_type: ::prost::encoding::WireType,
                        buf: &mut B,
                        ctx: ::prost::encoding::DecodeContext,
                    ) -> ::core::result::Result<(), ::prost::DecodeError>
                    where
                        B: ::prost::bytes::Buf,
                    {
                        match tag {
                            3u32 => {
                                match field {
                                    ::core::option::Option::Some(
                                        Target::TargetFid(ref mut value),
                                    ) => {
                                        ::prost::encoding::uint64::merge(wire_type, value, buf, ctx)
                                    }
                                    _ => {
                                        let mut owned_value = ::core::default::Default::default();
                                        let value = &mut owned_value;
                                        ::prost::encoding::uint64::merge(wire_type, value, buf, ctx)
                                            .map(|_| {
                                                *field = ::core::option::Option::Some(
                                                    Target::TargetFid(owned_value),
                                                );
                                            })
                                    }
                                }
                            }
                            _ => {
                                ::core::panicking::panic_fmt(
                                    format_args!(
                                        "internal error: entered unreachable code: {0}",
                                        format_args!("invalid Target tag: {0}", tag),
                                    ),
                                );
                            }
                        }
                    }
                    /// Returns the encoded length of the message without a length delimiter.
                    #[inline]
                    pub fn encoded_len(&self) -> usize {
                        match *self {
                            Target::TargetFid(ref value) => {
                                ::prost::encoding::uint64::encoded_len(3u32, &*value)
                            }
                        }
                    }
                }
                impl ::core::fmt::Debug for Target {
                    fn fmt(
                        &self,
                        f: &mut ::core::fmt::Formatter,
                    ) -> ::core::fmt::Result {
                        match *self {
                            Target::TargetFid(ref value) => {
                                let wrapper = {
                                    fn ScalarWrapper<T>(v: T) -> T {
                                        v
                                    }
                                    ScalarWrapper(&*value)
                                };
                                f.debug_tuple("TargetFid").field(&wrapper).finish()
                            }
                        }
                    }
                }
            }
            #[allow(clippy::derive_partial_eq_without_eq)]
            pub struct LinksByFidRequest {
                #[prost(uint64, tag = "1")]
                pub fid: u64,
                #[prost(string, optional, tag = "2")]
                pub link_type: ::core::option::Option<::prost::alloc::string::String>,
                #[prost(uint32, optional, tag = "3")]
                pub page_size: ::core::option::Option<u32>,
                #[prost(bytes = "vec", optional, tag = "4")]
                pub page_token: ::core::option::Option<::prost::alloc::vec::Vec<u8>>,
                #[prost(bool, optional, tag = "5")]
                pub reverse: ::core::option::Option<bool>,
            }
            #[automatically_derived]
            #[allow(clippy::derive_partial_eq_without_eq)]
            impl ::core::clone::Clone for LinksByFidRequest {
                #[inline]
                fn clone(&self) -> LinksByFidRequest {
                    LinksByFidRequest {
                        fid: ::core::clone::Clone::clone(&self.fid),
                        link_type: ::core::clone::Clone::clone(&self.link_type),
                        page_size: ::core::clone::Clone::clone(&self.page_size),
                        page_token: ::core::clone::Clone::clone(&self.page_token),
                        reverse: ::core::clone::Clone::clone(&self.reverse),
                    }
                }
            }
            #[allow(clippy::derive_partial_eq_without_eq)]
            #[automatically_derived]
            impl ::core::marker::StructuralPartialEq for LinksByFidRequest {}
            #[automatically_derived]
            #[allow(clippy::derive_partial_eq_without_eq)]
            impl ::core::cmp::PartialEq for LinksByFidRequest {
                #[inline]
                fn eq(&self, other: &LinksByFidRequest) -> bool {
                    self.fid == other.fid && self.link_type == other.link_type
                        && self.page_size == other.page_size
                        && self.page_token == other.page_token
                        && self.reverse == other.reverse
                }
            }
            impl ::prost::Message for LinksByFidRequest {
                #[allow(unused_variables)]
                fn encode_raw<B>(&self, buf: &mut B)
                where
                    B: ::prost::bytes::BufMut,
                {
                    if self.fid != 0u64 {
                        ::prost::encoding::uint64::encode(1u32, &self.fid, buf);
                    }
                    if let ::core::option::Option::Some(ref value) = self.link_type {
                        ::prost::encoding::string::encode(2u32, value, buf);
                    }
                    if let ::core::option::Option::Some(ref value) = self.page_size {
                        ::prost::encoding::uint32::encode(3u32, value, buf);
                    }
                    if let ::core::option::Option::Some(ref value) = self.page_token {
                        ::prost::encoding::bytes::encode(4u32, value, buf);
                    }
                    if let ::core::option::Option::Some(ref value) = self.reverse {
                        ::prost::encoding::bool::encode(5u32, value, buf);
                    }
                }
                #[allow(unused_variables)]
                fn merge_field<B>(
                    &mut self,
                    tag: u32,
                    wire_type: ::prost::encoding::WireType,
                    buf: &mut B,
                    ctx: ::prost::encoding::DecodeContext,
                ) -> ::core::result::Result<(), ::prost::DecodeError>
                where
                    B: ::prost::bytes::Buf,
                {
                    const STRUCT_NAME: &'static str = "LinksByFidRequest";
                    match tag {
                        1u32 => {
                            let mut value = &mut self.fid;
                            ::prost::encoding::uint64::merge(wire_type, value, buf, ctx)
                                .map_err(|mut error| {
                                    error.push(STRUCT_NAME, "fid");
                                    error
                                })
                        }
                        2u32 => {
                            let mut value = &mut self.link_type;
                            ::prost::encoding::string::merge(
                                    wire_type,
                                    value.get_or_insert_with(::core::default::Default::default),
                                    buf,
                                    ctx,
                                )
                                .map_err(|mut error| {
                                    error.push(STRUCT_NAME, "link_type");
                                    error
                                })
                        }
                        3u32 => {
                            let mut value = &mut self.page_size;
                            ::prost::encoding::uint32::merge(
                                    wire_type,
                                    value.get_or_insert_with(::core::default::Default::default),
                                    buf,
                                    ctx,
                                )
                                .map_err(|mut error| {
                                    error.push(STRUCT_NAME, "page_size");
                                    error
                                })
                        }
                        4u32 => {
                            let mut value = &mut self.page_token;
                            ::prost::encoding::bytes::merge(
                                    wire_type,
                                    value.get_or_insert_with(::core::default::Default::default),
                                    buf,
                                    ctx,
                                )
                                .map_err(|mut error| {
                                    error.push(STRUCT_NAME, "page_token");
                                    error
                                })
                        }
                        5u32 => {
                            let mut value = &mut self.reverse;
                            ::prost::encoding::bool::merge(
                                    wire_type,
                                    value.get_or_insert_with(::core::default::Default::default),
                                    buf,
                                    ctx,
                                )
                                .map_err(|mut error| {
                                    error.push(STRUCT_NAME, "reverse");
                                    error
                                })
                        }
                        _ => ::prost::encoding::skip_field(wire_type, tag, buf, ctx),
                    }
                }
                #[inline]
                fn encoded_len(&self) -> usize {
                    0
                        + if self.fid != 0u64 {
                            ::prost::encoding::uint64::encoded_len(1u32, &self.fid)
                        } else {
                            0
                        }
                        + self
                            .link_type
                            .as_ref()
                            .map_or(
                                0,
                                |value| ::prost::encoding::string::encoded_len(2u32, value),
                            )
                        + self
                            .page_size
                            .as_ref()
                            .map_or(
                                0,
                                |value| ::prost::encoding::uint32::encoded_len(3u32, value),
                            )
                        + self
                            .page_token
                            .as_ref()
                            .map_or(
                                0,
                                |value| ::prost::encoding::bytes::encoded_len(4u32, value),
                            )
                        + self
                            .reverse
                            .as_ref()
                            .map_or(
                                0,
                                |value| ::prost::encoding::bool::encoded_len(5u32, value),
                            )
                }
                fn clear(&mut self) {
                    self.fid = 0u64;
                    self.link_type = ::core::option::Option::None;
                    self.page_size = ::core::option::Option::None;
                    self.page_token = ::core::option::Option::None;
                    self.reverse = ::core::option::Option::None;
                }
            }
            impl ::core::default::Default for LinksByFidRequest {
                fn default() -> Self {
                    LinksByFidRequest {
                        fid: 0u64,
                        link_type: ::core::option::Option::None,
                        page_size: ::core::option::Option::None,
                        page_token: ::core::option::Option::None,
                        reverse: ::core::option::Option::None,
                    }
                }
            }
            impl ::core::fmt::Debug for LinksByFidRequest {
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    let mut builder = f.debug_struct("LinksByFidRequest");
                    let builder = {
                        let wrapper = {
                            fn ScalarWrapper<T>(v: T) -> T {
                                v
                            }
                            ScalarWrapper(&self.fid)
                        };
                        builder.field("fid", &wrapper)
                    };
                    let builder = {
                        let wrapper = {
                            struct ScalarWrapper<'a>(
                                &'a ::core::option::Option<::prost::alloc::string::String>,
                            );
                            impl<'a> ::core::fmt::Debug for ScalarWrapper<'a> {
                                fn fmt(
                                    &self,
                                    f: &mut ::core::fmt::Formatter,
                                ) -> ::core::fmt::Result {
                                    fn Inner<T>(v: T) -> T {
                                        v
                                    }
                                    ::core::fmt::Debug::fmt(&self.0.as_ref().map(Inner), f)
                                }
                            }
                            ScalarWrapper(&self.link_type)
                        };
                        builder.field("link_type", &wrapper)
                    };
                    let builder = {
                        let wrapper = {
                            struct ScalarWrapper<'a>(&'a ::core::option::Option<u32>);
                            impl<'a> ::core::fmt::Debug for ScalarWrapper<'a> {
                                fn fmt(
                                    &self,
                                    f: &mut ::core::fmt::Formatter,
                                ) -> ::core::fmt::Result {
                                    fn Inner<T>(v: T) -> T {
                                        v
                                    }
                                    ::core::fmt::Debug::fmt(&self.0.as_ref().map(Inner), f)
                                }
                            }
                            ScalarWrapper(&self.page_size)
                        };
                        builder.field("page_size", &wrapper)
                    };
                    let builder = {
                        let wrapper = {
                            struct ScalarWrapper<'a>(
                                &'a ::core::option::Option<::prost::alloc::vec::Vec<u8>>,
                            );
                            impl<'a> ::core::fmt::Debug for ScalarWrapper<'a> {
                                fn fmt(
                                    &self,
                                    f: &mut ::core::fmt::Formatter,
                                ) -> ::core::fmt::Result {
                                    fn Inner<T>(v: T) -> T {
                                        v
                                    }
                                    ::core::fmt::Debug::fmt(&self.0.as_ref().map(Inner), f)
                                }
                            }
                            ScalarWrapper(&self.page_token)
                        };
                        builder.field("page_token", &wrapper)
                    };
                    let builder = {
                        let wrapper = {
                            struct ScalarWrapper<'a>(&'a ::core::option::Option<bool>);
                            impl<'a> ::core::fmt::Debug for ScalarWrapper<'a> {
                                fn fmt(
                                    &self,
                                    f: &mut ::core::fmt::Formatter,
                                ) -> ::core::fmt::Result {
                                    fn Inner<T>(v: T) -> T {
                                        v
                                    }
                                    ::core::fmt::Debug::fmt(&self.0.as_ref().map(Inner), f)
                                }
                            }
                            ScalarWrapper(&self.reverse)
                        };
                        builder.field("reverse", &wrapper)
                    };
                    builder.finish()
                }
            }
            #[allow(dead_code)]
            impl LinksByFidRequest {
                ///Returns the value of `link_type`, or the default value if `link_type` is unset.
                pub fn link_type(&self) -> &str {
                    match self.link_type {
                        ::core::option::Option::Some(ref val) => &val[..],
                        ::core::option::Option::None => "",
                    }
                }
                ///Returns the value of `page_size`, or the default value if `page_size` is unset.
                pub fn page_size(&self) -> u32 {
                    match self.page_size {
                        ::core::option::Option::Some(val) => val,
                        ::core::option::Option::None => 0u32,
                    }
                }
                ///Returns the value of `page_token`, or the default value if `page_token` is unset.
                pub fn page_token(&self) -> &[u8] {
                    match self.page_token {
                        ::core::option::Option::Some(ref val) => &val[..],
                        ::core::option::Option::None => b"" as &[u8],
                    }
                }
                ///Returns the value of `reverse`, or the default value if `reverse` is unset.
                pub fn reverse(&self) -> bool {
                    match self.reverse {
                        ::core::option::Option::Some(val) => val,
                        ::core::option::Option::None => false,
                    }
                }
            }
            #[allow(clippy::derive_partial_eq_without_eq)]
            pub struct LinksByTargetRequest {
                #[prost(string, optional, tag = "2")]
                pub link_type: ::core::option::Option<::prost::alloc::string::String>,
                #[prost(uint32, optional, tag = "3")]
                pub page_size: ::core::option::Option<u32>,
                #[prost(bytes = "vec", optional, tag = "4")]
                pub page_token: ::core::option::Option<::prost::alloc::vec::Vec<u8>>,
                #[prost(bool, optional, tag = "5")]
                pub reverse: ::core::option::Option<bool>,
                #[prost(oneof = "links_by_target_request::Target", tags = "1")]
                pub target: ::core::option::Option<links_by_target_request::Target>,
            }
            #[automatically_derived]
            #[allow(clippy::derive_partial_eq_without_eq)]
            impl ::core::clone::Clone for LinksByTargetRequest {
                #[inline]
                fn clone(&self) -> LinksByTargetRequest {
                    LinksByTargetRequest {
                        link_type: ::core::clone::Clone::clone(&self.link_type),
                        page_size: ::core::clone::Clone::clone(&self.page_size),
                        page_token: ::core::clone::Clone::clone(&self.page_token),
                        reverse: ::core::clone::Clone::clone(&self.reverse),
                        target: ::core::clone::Clone::clone(&self.target),
                    }
                }
            }
            #[allow(clippy::derive_partial_eq_without_eq)]
            #[automatically_derived]
            impl ::core::marker::StructuralPartialEq for LinksByTargetRequest {}
            #[automatically_derived]
            #[allow(clippy::derive_partial_eq_without_eq)]
            impl ::core::cmp::PartialEq for LinksByTargetRequest {
                #[inline]
                fn eq(&self, other: &LinksByTargetRequest) -> bool {
                    self.link_type == other.link_type
                        && self.page_size == other.page_size
                        && self.page_token == other.page_token
                        && self.reverse == other.reverse && self.target == other.target
                }
            }
            impl ::prost::Message for LinksByTargetRequest {
                #[allow(unused_variables)]
                fn encode_raw<B>(&self, buf: &mut B)
                where
                    B: ::prost::bytes::BufMut,
                {
                    if let Some(ref oneof) = self.target {
                        oneof.encode(buf)
                    }
                    if let ::core::option::Option::Some(ref value) = self.link_type {
                        ::prost::encoding::string::encode(2u32, value, buf);
                    }
                    if let ::core::option::Option::Some(ref value) = self.page_size {
                        ::prost::encoding::uint32::encode(3u32, value, buf);
                    }
                    if let ::core::option::Option::Some(ref value) = self.page_token {
                        ::prost::encoding::bytes::encode(4u32, value, buf);
                    }
                    if let ::core::option::Option::Some(ref value) = self.reverse {
                        ::prost::encoding::bool::encode(5u32, value, buf);
                    }
                }
                #[allow(unused_variables)]
                fn merge_field<B>(
                    &mut self,
                    tag: u32,
                    wire_type: ::prost::encoding::WireType,
                    buf: &mut B,
                    ctx: ::prost::encoding::DecodeContext,
                ) -> ::core::result::Result<(), ::prost::DecodeError>
                where
                    B: ::prost::bytes::Buf,
                {
                    const STRUCT_NAME: &'static str = "LinksByTargetRequest";
                    match tag {
                        1u32 => {
                            let mut value = &mut self.target;
                            links_by_target_request::Target::merge(
                                    value,
                                    tag,
                                    wire_type,
                                    buf,
                                    ctx,
                                )
                                .map_err(|mut error| {
                                    error.push(STRUCT_NAME, "target");
                                    error
                                })
                        }
                        2u32 => {
                            let mut value = &mut self.link_type;
                            ::prost::encoding::string::merge(
                                    wire_type,
                                    value.get_or_insert_with(::core::default::Default::default),
                                    buf,
                                    ctx,
                                )
                                .map_err(|mut error| {
                                    error.push(STRUCT_NAME, "link_type");
                                    error
                                })
                        }
                        3u32 => {
                            let mut value = &mut self.page_size;
                            ::prost::encoding::uint32::merge(
                                    wire_type,
                                    value.get_or_insert_with(::core::default::Default::default),
                                    buf,
                                    ctx,
                                )
                                .map_err(|mut error| {
                                    error.push(STRUCT_NAME, "page_size");
                                    error
                                })
                        }
                        4u32 => {
                            let mut value = &mut self.page_token;
                            ::prost::encoding::bytes::merge(
                                    wire_type,
                                    value.get_or_insert_with(::core::default::Default::default),
                                    buf,
                                    ctx,
                                )
                                .map_err(|mut error| {
                                    error.push(STRUCT_NAME, "page_token");
                                    error
                                })
                        }
                        5u32 => {
                            let mut value = &mut self.reverse;
                            ::prost::encoding::bool::merge(
                                    wire_type,
                                    value.get_or_insert_with(::core::default::Default::default),
                                    buf,
                                    ctx,
                                )
                                .map_err(|mut error| {
                                    error.push(STRUCT_NAME, "reverse");
                                    error
                                })
                        }
                        _ => ::prost::encoding::skip_field(wire_type, tag, buf, ctx),
                    }
                }
                #[inline]
                fn encoded_len(&self) -> usize {
                    0
                        + self
                            .target
                            .as_ref()
                            .map_or(0, links_by_target_request::Target::encoded_len)
                        + self
                            .link_type
                            .as_ref()
                            .map_or(
                                0,
                                |value| ::prost::encoding::string::encoded_len(2u32, value),
                            )
                        + self
                            .page_size
                            .as_ref()
                            .map_or(
                                0,
                                |value| ::prost::encoding::uint32::encoded_len(3u32, value),
                            )
                        + self
                            .page_token
                            .as_ref()
                            .map_or(
                                0,
                                |value| ::prost::encoding::bytes::encoded_len(4u32, value),
                            )
                        + self
                            .reverse
                            .as_ref()
                            .map_or(
                                0,
                                |value| ::prost::encoding::bool::encoded_len(5u32, value),
                            )
                }
                fn clear(&mut self) {
                    self.target = ::core::option::Option::None;
                    self.link_type = ::core::option::Option::None;
                    self.page_size = ::core::option::Option::None;
                    self.page_token = ::core::option::Option::None;
                    self.reverse = ::core::option::Option::None;
                }
            }
            impl ::core::default::Default for LinksByTargetRequest {
                fn default() -> Self {
                    LinksByTargetRequest {
                        target: ::core::default::Default::default(),
                        link_type: ::core::option::Option::None,
                        page_size: ::core::option::Option::None,
                        page_token: ::core::option::Option::None,
                        reverse: ::core::option::Option::None,
                    }
                }
            }
            impl ::core::fmt::Debug for LinksByTargetRequest {
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    let mut builder = f.debug_struct("LinksByTargetRequest");
                    let builder = {
                        let wrapper = {
                            struct ScalarWrapper<'a>(
                                &'a ::core::option::Option<::prost::alloc::string::String>,
                            );
                            impl<'a> ::core::fmt::Debug for ScalarWrapper<'a> {
                                fn fmt(
                                    &self,
                                    f: &mut ::core::fmt::Formatter,
                                ) -> ::core::fmt::Result {
                                    fn Inner<T>(v: T) -> T {
                                        v
                                    }
                                    ::core::fmt::Debug::fmt(&self.0.as_ref().map(Inner), f)
                                }
                            }
                            ScalarWrapper(&self.link_type)
                        };
                        builder.field("link_type", &wrapper)
                    };
                    let builder = {
                        let wrapper = {
                            struct ScalarWrapper<'a>(&'a ::core::option::Option<u32>);
                            impl<'a> ::core::fmt::Debug for ScalarWrapper<'a> {
                                fn fmt(
                                    &self,
                                    f: &mut ::core::fmt::Formatter,
                                ) -> ::core::fmt::Result {
                                    fn Inner<T>(v: T) -> T {
                                        v
                                    }
                                    ::core::fmt::Debug::fmt(&self.0.as_ref().map(Inner), f)
                                }
                            }
                            ScalarWrapper(&self.page_size)
                        };
                        builder.field("page_size", &wrapper)
                    };
                    let builder = {
                        let wrapper = {
                            struct ScalarWrapper<'a>(
                                &'a ::core::option::Option<::prost::alloc::vec::Vec<u8>>,
                            );
                            impl<'a> ::core::fmt::Debug for ScalarWrapper<'a> {
                                fn fmt(
                                    &self,
                                    f: &mut ::core::fmt::Formatter,
                                ) -> ::core::fmt::Result {
                                    fn Inner<T>(v: T) -> T {
                                        v
                                    }
                                    ::core::fmt::Debug::fmt(&self.0.as_ref().map(Inner), f)
                                }
                            }
                            ScalarWrapper(&self.page_token)
                        };
                        builder.field("page_token", &wrapper)
                    };
                    let builder = {
                        let wrapper = {
                            struct ScalarWrapper<'a>(&'a ::core::option::Option<bool>);
                            impl<'a> ::core::fmt::Debug for ScalarWrapper<'a> {
                                fn fmt(
                                    &self,
                                    f: &mut ::core::fmt::Formatter,
                                ) -> ::core::fmt::Result {
                                    fn Inner<T>(v: T) -> T {
                                        v
                                    }
                                    ::core::fmt::Debug::fmt(&self.0.as_ref().map(Inner), f)
                                }
                            }
                            ScalarWrapper(&self.reverse)
                        };
                        builder.field("reverse", &wrapper)
                    };
                    let builder = {
                        let wrapper = &self.target;
                        builder.field("target", &wrapper)
                    };
                    builder.finish()
                }
            }
            #[allow(dead_code)]
            impl LinksByTargetRequest {
                ///Returns the value of `link_type`, or the default value if `link_type` is unset.
                pub fn link_type(&self) -> &str {
                    match self.link_type {
                        ::core::option::Option::Some(ref val) => &val[..],
                        ::core::option::Option::None => "",
                    }
                }
                ///Returns the value of `page_size`, or the default value if `page_size` is unset.
                pub fn page_size(&self) -> u32 {
                    match self.page_size {
                        ::core::option::Option::Some(val) => val,
                        ::core::option::Option::None => 0u32,
                    }
                }
                ///Returns the value of `page_token`, or the default value if `page_token` is unset.
                pub fn page_token(&self) -> &[u8] {
                    match self.page_token {
                        ::core::option::Option::Some(ref val) => &val[..],
                        ::core::option::Option::None => b"" as &[u8],
                    }
                }
                ///Returns the value of `reverse`, or the default value if `reverse` is unset.
                pub fn reverse(&self) -> bool {
                    match self.reverse {
                        ::core::option::Option::Some(val) => val,
                        ::core::option::Option::None => false,
                    }
                }
            }
            /// Nested message and enum types in `LinksByTargetRequest`.
            pub mod links_by_target_request {
                #[allow(clippy::derive_partial_eq_without_eq)]
                pub enum Target {
                    #[prost(uint64, tag = "1")]
                    TargetFid(u64),
                }
                #[automatically_derived]
                #[allow(clippy::derive_partial_eq_without_eq)]
                impl ::core::clone::Clone for Target {
                    #[inline]
                    fn clone(&self) -> Target {
                        match self {
                            Target::TargetFid(__self_0) => {
                                Target::TargetFid(::core::clone::Clone::clone(__self_0))
                            }
                        }
                    }
                }
                #[allow(clippy::derive_partial_eq_without_eq)]
                #[automatically_derived]
                impl ::core::marker::StructuralPartialEq for Target {}
                #[automatically_derived]
                #[allow(clippy::derive_partial_eq_without_eq)]
                impl ::core::cmp::PartialEq for Target {
                    #[inline]
                    fn eq(&self, other: &Target) -> bool {
                        match (self, other) {
                            (
                                Target::TargetFid(__self_0),
                                Target::TargetFid(__arg1_0),
                            ) => *__self_0 == *__arg1_0,
                        }
                    }
                }
                impl Target {
                    /// Encodes the message to a buffer.
                    pub fn encode<B>(&self, buf: &mut B)
                    where
                        B: ::prost::bytes::BufMut,
                    {
                        match *self {
                            Target::TargetFid(ref value) => {
                                ::prost::encoding::uint64::encode(1u32, &*value, buf);
                            }
                        }
                    }
                    /// Decodes an instance of the message from a buffer, and merges it into self.
                    pub fn merge<B>(
                        field: &mut ::core::option::Option<Target>,
                        tag: u32,
                        wire_type: ::prost::encoding::WireType,
                        buf: &mut B,
                        ctx: ::prost::encoding::DecodeContext,
                    ) -> ::core::result::Result<(), ::prost::DecodeError>
                    where
                        B: ::prost::bytes::Buf,
                    {
                        match tag {
                            1u32 => {
                                match field {
                                    ::core::option::Option::Some(
                                        Target::TargetFid(ref mut value),
                                    ) => {
                                        ::prost::encoding::uint64::merge(wire_type, value, buf, ctx)
                                    }
                                    _ => {
                                        let mut owned_value = ::core::default::Default::default();
                                        let value = &mut owned_value;
                                        ::prost::encoding::uint64::merge(wire_type, value, buf, ctx)
                                            .map(|_| {
                                                *field = ::core::option::Option::Some(
                                                    Target::TargetFid(owned_value),
                                                );
                                            })
                                    }
                                }
                            }
                            _ => {
                                ::core::panicking::panic_fmt(
                                    format_args!(
                                        "internal error: entered unreachable code: {0}",
                                        format_args!("invalid Target tag: {0}", tag),
                                    ),
                                );
                            }
                        }
                    }
                    /// Returns the encoded length of the message without a length delimiter.
                    #[inline]
                    pub fn encoded_len(&self) -> usize {
                        match *self {
                            Target::TargetFid(ref value) => {
                                ::prost::encoding::uint64::encoded_len(1u32, &*value)
                            }
                        }
                    }
                }
                impl ::core::fmt::Debug for Target {
                    fn fmt(
                        &self,
                        f: &mut ::core::fmt::Formatter,
                    ) -> ::core::fmt::Result {
                        match *self {
                            Target::TargetFid(ref value) => {
                                let wrapper = {
                                    fn ScalarWrapper<T>(v: T) -> T {
                                        v
                                    }
                                    ScalarWrapper(&*value)
                                };
                                f.debug_tuple("TargetFid").field(&wrapper).finish()
                            }
                        }
                    }
                }
            }
            #[allow(clippy::derive_partial_eq_without_eq)]
            pub struct IdRegistryEventRequest {
                #[prost(uint64, tag = "1")]
                pub fid: u64,
            }
            #[automatically_derived]
            #[allow(clippy::derive_partial_eq_without_eq)]
            impl ::core::clone::Clone for IdRegistryEventRequest {
                #[inline]
                fn clone(&self) -> IdRegistryEventRequest {
                    IdRegistryEventRequest {
                        fid: ::core::clone::Clone::clone(&self.fid),
                    }
                }
            }
            #[allow(clippy::derive_partial_eq_without_eq)]
            #[automatically_derived]
            impl ::core::marker::StructuralPartialEq for IdRegistryEventRequest {}
            #[automatically_derived]
            #[allow(clippy::derive_partial_eq_without_eq)]
            impl ::core::cmp::PartialEq for IdRegistryEventRequest {
                #[inline]
                fn eq(&self, other: &IdRegistryEventRequest) -> bool {
                    self.fid == other.fid
                }
            }
            impl ::prost::Message for IdRegistryEventRequest {
                #[allow(unused_variables)]
                fn encode_raw<B>(&self, buf: &mut B)
                where
                    B: ::prost::bytes::BufMut,
                {
                    if self.fid != 0u64 {
                        ::prost::encoding::uint64::encode(1u32, &self.fid, buf);
                    }
                }
                #[allow(unused_variables)]
                fn merge_field<B>(
                    &mut self,
                    tag: u32,
                    wire_type: ::prost::encoding::WireType,
                    buf: &mut B,
                    ctx: ::prost::encoding::DecodeContext,
                ) -> ::core::result::Result<(), ::prost::DecodeError>
                where
                    B: ::prost::bytes::Buf,
                {
                    const STRUCT_NAME: &'static str = "IdRegistryEventRequest";
                    match tag {
                        1u32 => {
                            let mut value = &mut self.fid;
                            ::prost::encoding::uint64::merge(wire_type, value, buf, ctx)
                                .map_err(|mut error| {
                                    error.push(STRUCT_NAME, "fid");
                                    error
                                })
                        }
                        _ => ::prost::encoding::skip_field(wire_type, tag, buf, ctx),
                    }
                }
                #[inline]
                fn encoded_len(&self) -> usize {
                    0
                        + if self.fid != 0u64 {
                            ::prost::encoding::uint64::encoded_len(1u32, &self.fid)
                        } else {
                            0
                        }
                }
                fn clear(&mut self) {
                    self.fid = 0u64;
                }
            }
            impl ::core::default::Default for IdRegistryEventRequest {
                fn default() -> Self {
                    IdRegistryEventRequest {
                        fid: 0u64,
                    }
                }
            }
            impl ::core::fmt::Debug for IdRegistryEventRequest {
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    let mut builder = f.debug_struct("IdRegistryEventRequest");
                    let builder = {
                        let wrapper = {
                            fn ScalarWrapper<T>(v: T) -> T {
                                v
                            }
                            ScalarWrapper(&self.fid)
                        };
                        builder.field("fid", &wrapper)
                    };
                    builder.finish()
                }
            }
            #[allow(clippy::derive_partial_eq_without_eq)]
            pub struct IdRegistryEventByAddressRequest {
                #[prost(bytes = "vec", tag = "1")]
                pub address: ::prost::alloc::vec::Vec<u8>,
            }
            #[automatically_derived]
            #[allow(clippy::derive_partial_eq_without_eq)]
            impl ::core::clone::Clone for IdRegistryEventByAddressRequest {
                #[inline]
                fn clone(&self) -> IdRegistryEventByAddressRequest {
                    IdRegistryEventByAddressRequest {
                        address: ::core::clone::Clone::clone(&self.address),
                    }
                }
            }
            #[allow(clippy::derive_partial_eq_without_eq)]
            #[automatically_derived]
            impl ::core::marker::StructuralPartialEq
            for IdRegistryEventByAddressRequest {}
            #[automatically_derived]
            #[allow(clippy::derive_partial_eq_without_eq)]
            impl ::core::cmp::PartialEq for IdRegistryEventByAddressRequest {
                #[inline]
                fn eq(&self, other: &IdRegistryEventByAddressRequest) -> bool {
                    self.address == other.address
                }
            }
            impl ::prost::Message for IdRegistryEventByAddressRequest {
                #[allow(unused_variables)]
                fn encode_raw<B>(&self, buf: &mut B)
                where
                    B: ::prost::bytes::BufMut,
                {
                    if self.address != b"" as &[u8] {
                        ::prost::encoding::bytes::encode(1u32, &self.address, buf);
                    }
                }
                #[allow(unused_variables)]
                fn merge_field<B>(
                    &mut self,
                    tag: u32,
                    wire_type: ::prost::encoding::WireType,
                    buf: &mut B,
                    ctx: ::prost::encoding::DecodeContext,
                ) -> ::core::result::Result<(), ::prost::DecodeError>
                where
                    B: ::prost::bytes::Buf,
                {
                    const STRUCT_NAME: &'static str = "IdRegistryEventByAddressRequest";
                    match tag {
                        1u32 => {
                            let mut value = &mut self.address;
                            ::prost::encoding::bytes::merge(wire_type, value, buf, ctx)
                                .map_err(|mut error| {
                                    error.push(STRUCT_NAME, "address");
                                    error
                                })
                        }
                        _ => ::prost::encoding::skip_field(wire_type, tag, buf, ctx),
                    }
                }
                #[inline]
                fn encoded_len(&self) -> usize {
                    0
                        + if self.address != b"" as &[u8] {
                            ::prost::encoding::bytes::encoded_len(1u32, &self.address)
                        } else {
                            0
                        }
                }
                fn clear(&mut self) {
                    self.address.clear();
                }
            }
            impl ::core::default::Default for IdRegistryEventByAddressRequest {
                fn default() -> Self {
                    IdRegistryEventByAddressRequest {
                        address: ::core::default::Default::default(),
                    }
                }
            }
            impl ::core::fmt::Debug for IdRegistryEventByAddressRequest {
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    let mut builder = f.debug_struct("IdRegistryEventByAddressRequest");
                    let builder = {
                        let wrapper = {
                            fn ScalarWrapper<T>(v: T) -> T {
                                v
                            }
                            ScalarWrapper(&self.address)
                        };
                        builder.field("address", &wrapper)
                    };
                    builder.finish()
                }
            }
            #[repr(i32)]
            pub enum StoreType {
                None = 0,
                Casts = 1,
                Links = 2,
                Reactions = 3,
                UserData = 4,
                Verifications = 5,
            }
            #[automatically_derived]
            impl ::core::clone::Clone for StoreType {
                #[inline]
                fn clone(&self) -> StoreType {
                    *self
                }
            }
            #[automatically_derived]
            impl ::core::marker::Copy for StoreType {}
            #[automatically_derived]
            impl ::core::fmt::Debug for StoreType {
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    ::core::fmt::Formatter::write_str(
                        f,
                        match self {
                            StoreType::None => "None",
                            StoreType::Casts => "Casts",
                            StoreType::Links => "Links",
                            StoreType::Reactions => "Reactions",
                            StoreType::UserData => "UserData",
                            StoreType::Verifications => "Verifications",
                        },
                    )
                }
            }
            #[automatically_derived]
            impl ::core::marker::StructuralPartialEq for StoreType {}
            #[automatically_derived]
            impl ::core::cmp::PartialEq for StoreType {
                #[inline]
                fn eq(&self, other: &StoreType) -> bool {
                    let __self_tag = ::core::intrinsics::discriminant_value(self);
                    let __arg1_tag = ::core::intrinsics::discriminant_value(other);
                    __self_tag == __arg1_tag
                }
            }
            #[automatically_derived]
            impl ::core::marker::StructuralEq for StoreType {}
            #[automatically_derived]
            impl ::core::cmp::Eq for StoreType {
                #[inline]
                #[doc(hidden)]
                #[no_coverage]
                fn assert_receiver_is_total_eq(&self) -> () {}
            }
            #[automatically_derived]
            impl ::core::hash::Hash for StoreType {
                fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {
                    let __self_tag = ::core::intrinsics::discriminant_value(self);
                    ::core::hash::Hash::hash(&__self_tag, state)
                }
            }
            #[automatically_derived]
            impl ::core::cmp::PartialOrd for StoreType {
                #[inline]
                fn partial_cmp(
                    &self,
                    other: &StoreType,
                ) -> ::core::option::Option<::core::cmp::Ordering> {
                    let __self_tag = ::core::intrinsics::discriminant_value(self);
                    let __arg1_tag = ::core::intrinsics::discriminant_value(other);
                    ::core::cmp::PartialOrd::partial_cmp(&__self_tag, &__arg1_tag)
                }
            }
            #[automatically_derived]
            impl ::core::cmp::Ord for StoreType {
                #[inline]
                fn cmp(&self, other: &StoreType) -> ::core::cmp::Ordering {
                    let __self_tag = ::core::intrinsics::discriminant_value(self);
                    let __arg1_tag = ::core::intrinsics::discriminant_value(other);
                    ::core::cmp::Ord::cmp(&__self_tag, &__arg1_tag)
                }
            }
            impl StoreType {
                ///Returns `true` if `value` is a variant of `StoreType`.
                pub fn is_valid(value: i32) -> bool {
                    match value {
                        0 => true,
                        1 => true,
                        2 => true,
                        3 => true,
                        4 => true,
                        5 => true,
                        _ => false,
                    }
                }
                ///Converts an `i32` to a `StoreType`, or `None` if `value` is not a valid variant.
                pub fn from_i32(value: i32) -> ::core::option::Option<StoreType> {
                    match value {
                        0 => ::core::option::Option::Some(StoreType::None),
                        1 => ::core::option::Option::Some(StoreType::Casts),
                        2 => ::core::option::Option::Some(StoreType::Links),
                        3 => ::core::option::Option::Some(StoreType::Reactions),
                        4 => ::core::option::Option::Some(StoreType::UserData),
                        5 => ::core::option::Option::Some(StoreType::Verifications),
                        _ => ::core::option::Option::None,
                    }
                }
            }
            impl ::core::default::Default for StoreType {
                fn default() -> StoreType {
                    StoreType::None
                }
            }
            impl ::core::convert::From<StoreType> for i32 {
                fn from(value: StoreType) -> i32 {
                    value as i32
                }
            }
            impl StoreType {
                /// String value of the enum field names used in the ProtoBuf definition.
                ///
                /// The values are not transformed in any way and thus are considered stable
                /// (if the ProtoBuf definition does not change) and safe for programmatic use.
                pub fn as_str_name(&self) -> &'static str {
                    match self {
                        StoreType::None => "STORE_TYPE_NONE",
                        StoreType::Casts => "STORE_TYPE_CASTS",
                        StoreType::Links => "STORE_TYPE_LINKS",
                        StoreType::Reactions => "STORE_TYPE_REACTIONS",
                        StoreType::UserData => "STORE_TYPE_USER_DATA",
                        StoreType::Verifications => "STORE_TYPE_VERIFICATIONS",
                    }
                }
                /// Creates an enum from field names used in the ProtoBuf definition.
                pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
                    match value {
                        "STORE_TYPE_NONE" => Some(Self::None),
                        "STORE_TYPE_CASTS" => Some(Self::Casts),
                        "STORE_TYPE_LINKS" => Some(Self::Links),
                        "STORE_TYPE_REACTIONS" => Some(Self::Reactions),
                        "STORE_TYPE_USER_DATA" => Some(Self::UserData),
                        "STORE_TYPE_VERIFICATIONS" => Some(Self::Verifications),
                        _ => None,
                    }
                }
            }
            /// Generated client implementations.
            pub mod hub_service_client {
                #![allow(
                    unused_variables,
                    dead_code,
                    missing_docs,
                    clippy::let_unit_value
                )]
                use tonic::codegen::*;
                use tonic::codegen::http::Uri;
                pub struct HubServiceClient<T> {
                    inner: tonic::client::Grpc<T>,
                }
                #[automatically_derived]
                impl<T: ::core::fmt::Debug> ::core::fmt::Debug for HubServiceClient<T> {
                    fn fmt(
                        &self,
                        f: &mut ::core::fmt::Formatter,
                    ) -> ::core::fmt::Result {
                        ::core::fmt::Formatter::debug_struct_field1_finish(
                            f,
                            "HubServiceClient",
                            "inner",
                            &&self.inner,
                        )
                    }
                }
                #[automatically_derived]
                impl<T: ::core::clone::Clone> ::core::clone::Clone
                for HubServiceClient<T> {
                    #[inline]
                    fn clone(&self) -> HubServiceClient<T> {
                        HubServiceClient {
                            inner: ::core::clone::Clone::clone(&self.inner),
                        }
                    }
                }
                impl HubServiceClient<tonic::transport::Channel> {
                    /// Attempt to create a new client by connecting to a given endpoint.
                    pub async fn connect<D>(
                        dst: D,
                    ) -> Result<Self, tonic::transport::Error>
                    where
                        D: TryInto<tonic::transport::Endpoint>,
                        D::Error: Into<StdError>,
                    {
                        let conn = tonic::transport::Endpoint::new(dst)?
                            .connect()
                            .await?;
                        Ok(Self::new(conn))
                    }
                }
                impl<T> HubServiceClient<T>
                where
                    T: tonic::client::GrpcService<tonic::body::BoxBody>,
                    T::Error: Into<StdError>,
                    T::ResponseBody: Body<Data = Bytes> + Send + 'static,
                    <T::ResponseBody as Body>::Error: Into<StdError> + Send,
                {
                    pub fn new(inner: T) -> Self {
                        let inner = tonic::client::Grpc::new(inner);
                        Self { inner }
                    }
                    pub fn with_origin(inner: T, origin: Uri) -> Self {
                        let inner = tonic::client::Grpc::with_origin(inner, origin);
                        Self { inner }
                    }
                    pub fn with_interceptor<F>(
                        inner: T,
                        interceptor: F,
                    ) -> HubServiceClient<InterceptedService<T, F>>
                    where
                        F: tonic::service::Interceptor,
                        T::ResponseBody: Default,
                        T: tonic::codegen::Service<
                            http::Request<tonic::body::BoxBody>,
                            Response = http::Response<
                                <T as tonic::client::GrpcService<
                                    tonic::body::BoxBody,
                                >>::ResponseBody,
                            >,
                        >,
                        <T as tonic::codegen::Service<
                            http::Request<tonic::body::BoxBody>,
                        >>::Error: Into<StdError> + Send + Sync,
                    {
                        HubServiceClient::new(
                            InterceptedService::new(inner, interceptor),
                        )
                    }
                    /// Compress requests with the given encoding.
                    ///
                    /// This requires the server to support it otherwise it might respond with an
                    /// error.
                    #[must_use]
                    pub fn send_compressed(
                        mut self,
                        encoding: CompressionEncoding,
                    ) -> Self {
                        self.inner = self.inner.send_compressed(encoding);
                        self
                    }
                    /// Enable decompressing responses.
                    #[must_use]
                    pub fn accept_compressed(
                        mut self,
                        encoding: CompressionEncoding,
                    ) -> Self {
                        self.inner = self.inner.accept_compressed(encoding);
                        self
                    }
                    /// Limits the maximum size of a decoded message.
                    ///
                    /// Default: `4MB`
                    #[must_use]
                    pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
                        self.inner = self.inner.max_decoding_message_size(limit);
                        self
                    }
                    /// Limits the maximum size of an encoded message.
                    ///
                    /// Default: `usize::MAX`
                    #[must_use]
                    pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
                        self.inner = self.inner.max_encoding_message_size(limit);
                        self
                    }
                    /// Submit Methods
                    pub async fn submit_message(
                        &mut self,
                        request: impl tonic::IntoRequest<super::Message>,
                    ) -> std::result::Result<
                        tonic::Response<super::Message>,
                        tonic::Status,
                    > {
                        self.inner
                            .ready()
                            .await
                            .map_err(|e| {
                                tonic::Status::new(
                                    tonic::Code::Unknown,
                                    {
                                        let res = ::alloc::fmt::format(
                                            format_args!("Service was not ready: {0}", e.into()),
                                        );
                                        res
                                    },
                                )
                            })?;
                        let codec = tonic::codec::ProstCodec::default();
                        let path = http::uri::PathAndQuery::from_static(
                            "/HubService/SubmitMessage",
                        );
                        let mut req = request.into_request();
                        req.extensions_mut()
                            .insert(GrpcMethod::new("HubService", "SubmitMessage"));
                        self.inner.unary(req, path, codec).await
                    }
                    /// Event Methods
                    pub async fn subscribe(
                        &mut self,
                        request: impl tonic::IntoRequest<super::SubscribeRequest>,
                    ) -> std::result::Result<
                        tonic::Response<tonic::codec::Streaming<super::HubEvent>>,
                        tonic::Status,
                    > {
                        self.inner
                            .ready()
                            .await
                            .map_err(|e| {
                                tonic::Status::new(
                                    tonic::Code::Unknown,
                                    {
                                        let res = ::alloc::fmt::format(
                                            format_args!("Service was not ready: {0}", e.into()),
                                        );
                                        res
                                    },
                                )
                            })?;
                        let codec = tonic::codec::ProstCodec::default();
                        let path = http::uri::PathAndQuery::from_static(
                            "/HubService/Subscribe",
                        );
                        let mut req = request.into_request();
                        req.extensions_mut()
                            .insert(GrpcMethod::new("HubService", "Subscribe"));
                        self.inner.server_streaming(req, path, codec).await
                    }
                    pub async fn get_event(
                        &mut self,
                        request: impl tonic::IntoRequest<super::EventRequest>,
                    ) -> std::result::Result<
                        tonic::Response<super::HubEvent>,
                        tonic::Status,
                    > {
                        self.inner
                            .ready()
                            .await
                            .map_err(|e| {
                                tonic::Status::new(
                                    tonic::Code::Unknown,
                                    {
                                        let res = ::alloc::fmt::format(
                                            format_args!("Service was not ready: {0}", e.into()),
                                        );
                                        res
                                    },
                                )
                            })?;
                        let codec = tonic::codec::ProstCodec::default();
                        let path = http::uri::PathAndQuery::from_static(
                            "/HubService/GetEvent",
                        );
                        let mut req = request.into_request();
                        req.extensions_mut()
                            .insert(GrpcMethod::new("HubService", "GetEvent"));
                        self.inner.unary(req, path, codec).await
                    }
                    /// Casts
                    pub async fn get_cast(
                        &mut self,
                        request: impl tonic::IntoRequest<super::CastId>,
                    ) -> std::result::Result<
                        tonic::Response<super::Message>,
                        tonic::Status,
                    > {
                        self.inner
                            .ready()
                            .await
                            .map_err(|e| {
                                tonic::Status::new(
                                    tonic::Code::Unknown,
                                    {
                                        let res = ::alloc::fmt::format(
                                            format_args!("Service was not ready: {0}", e.into()),
                                        );
                                        res
                                    },
                                )
                            })?;
                        let codec = tonic::codec::ProstCodec::default();
                        let path = http::uri::PathAndQuery::from_static(
                            "/HubService/GetCast",
                        );
                        let mut req = request.into_request();
                        req.extensions_mut()
                            .insert(GrpcMethod::new("HubService", "GetCast"));
                        self.inner.unary(req, path, codec).await
                    }
                    pub async fn get_casts_by_fid(
                        &mut self,
                        request: impl tonic::IntoRequest<super::FidRequest>,
                    ) -> std::result::Result<
                        tonic::Response<super::MessagesResponse>,
                        tonic::Status,
                    > {
                        self.inner
                            .ready()
                            .await
                            .map_err(|e| {
                                tonic::Status::new(
                                    tonic::Code::Unknown,
                                    {
                                        let res = ::alloc::fmt::format(
                                            format_args!("Service was not ready: {0}", e.into()),
                                        );
                                        res
                                    },
                                )
                            })?;
                        let codec = tonic::codec::ProstCodec::default();
                        let path = http::uri::PathAndQuery::from_static(
                            "/HubService/GetCastsByFid",
                        );
                        let mut req = request.into_request();
                        req.extensions_mut()
                            .insert(GrpcMethod::new("HubService", "GetCastsByFid"));
                        self.inner.unary(req, path, codec).await
                    }
                    pub async fn get_casts_by_parent(
                        &mut self,
                        request: impl tonic::IntoRequest<super::CastsByParentRequest>,
                    ) -> std::result::Result<
                        tonic::Response<super::MessagesResponse>,
                        tonic::Status,
                    > {
                        self.inner
                            .ready()
                            .await
                            .map_err(|e| {
                                tonic::Status::new(
                                    tonic::Code::Unknown,
                                    {
                                        let res = ::alloc::fmt::format(
                                            format_args!("Service was not ready: {0}", e.into()),
                                        );
                                        res
                                    },
                                )
                            })?;
                        let codec = tonic::codec::ProstCodec::default();
                        let path = http::uri::PathAndQuery::from_static(
                            "/HubService/GetCastsByParent",
                        );
                        let mut req = request.into_request();
                        req.extensions_mut()
                            .insert(GrpcMethod::new("HubService", "GetCastsByParent"));
                        self.inner.unary(req, path, codec).await
                    }
                    pub async fn get_casts_by_mention(
                        &mut self,
                        request: impl tonic::IntoRequest<super::FidRequest>,
                    ) -> std::result::Result<
                        tonic::Response<super::MessagesResponse>,
                        tonic::Status,
                    > {
                        self.inner
                            .ready()
                            .await
                            .map_err(|e| {
                                tonic::Status::new(
                                    tonic::Code::Unknown,
                                    {
                                        let res = ::alloc::fmt::format(
                                            format_args!("Service was not ready: {0}", e.into()),
                                        );
                                        res
                                    },
                                )
                            })?;
                        let codec = tonic::codec::ProstCodec::default();
                        let path = http::uri::PathAndQuery::from_static(
                            "/HubService/GetCastsByMention",
                        );
                        let mut req = request.into_request();
                        req.extensions_mut()
                            .insert(GrpcMethod::new("HubService", "GetCastsByMention"));
                        self.inner.unary(req, path, codec).await
                    }
                    /// Reactions
                    pub async fn get_reaction(
                        &mut self,
                        request: impl tonic::IntoRequest<super::ReactionRequest>,
                    ) -> std::result::Result<
                        tonic::Response<super::Message>,
                        tonic::Status,
                    > {
                        self.inner
                            .ready()
                            .await
                            .map_err(|e| {
                                tonic::Status::new(
                                    tonic::Code::Unknown,
                                    {
                                        let res = ::alloc::fmt::format(
                                            format_args!("Service was not ready: {0}", e.into()),
                                        );
                                        res
                                    },
                                )
                            })?;
                        let codec = tonic::codec::ProstCodec::default();
                        let path = http::uri::PathAndQuery::from_static(
                            "/HubService/GetReaction",
                        );
                        let mut req = request.into_request();
                        req.extensions_mut()
                            .insert(GrpcMethod::new("HubService", "GetReaction"));
                        self.inner.unary(req, path, codec).await
                    }
                    pub async fn get_reactions_by_fid(
                        &mut self,
                        request: impl tonic::IntoRequest<super::ReactionsByFidRequest>,
                    ) -> std::result::Result<
                        tonic::Response<super::MessagesResponse>,
                        tonic::Status,
                    > {
                        self.inner
                            .ready()
                            .await
                            .map_err(|e| {
                                tonic::Status::new(
                                    tonic::Code::Unknown,
                                    {
                                        let res = ::alloc::fmt::format(
                                            format_args!("Service was not ready: {0}", e.into()),
                                        );
                                        res
                                    },
                                )
                            })?;
                        let codec = tonic::codec::ProstCodec::default();
                        let path = http::uri::PathAndQuery::from_static(
                            "/HubService/GetReactionsByFid",
                        );
                        let mut req = request.into_request();
                        req.extensions_mut()
                            .insert(GrpcMethod::new("HubService", "GetReactionsByFid"));
                        self.inner.unary(req, path, codec).await
                    }
                    pub async fn get_reactions_by_cast(
                        &mut self,
                        request: impl tonic::IntoRequest<super::ReactionsByTargetRequest>,
                    ) -> std::result::Result<
                        tonic::Response<super::MessagesResponse>,
                        tonic::Status,
                    > {
                        self.inner
                            .ready()
                            .await
                            .map_err(|e| {
                                tonic::Status::new(
                                    tonic::Code::Unknown,
                                    {
                                        let res = ::alloc::fmt::format(
                                            format_args!("Service was not ready: {0}", e.into()),
                                        );
                                        res
                                    },
                                )
                            })?;
                        let codec = tonic::codec::ProstCodec::default();
                        let path = http::uri::PathAndQuery::from_static(
                            "/HubService/GetReactionsByCast",
                        );
                        let mut req = request.into_request();
                        req.extensions_mut()
                            .insert(GrpcMethod::new("HubService", "GetReactionsByCast"));
                        self.inner.unary(req, path, codec).await
                    }
                    pub async fn get_reactions_by_target(
                        &mut self,
                        request: impl tonic::IntoRequest<super::ReactionsByTargetRequest>,
                    ) -> std::result::Result<
                        tonic::Response<super::MessagesResponse>,
                        tonic::Status,
                    > {
                        self.inner
                            .ready()
                            .await
                            .map_err(|e| {
                                tonic::Status::new(
                                    tonic::Code::Unknown,
                                    {
                                        let res = ::alloc::fmt::format(
                                            format_args!("Service was not ready: {0}", e.into()),
                                        );
                                        res
                                    },
                                )
                            })?;
                        let codec = tonic::codec::ProstCodec::default();
                        let path = http::uri::PathAndQuery::from_static(
                            "/HubService/GetReactionsByTarget",
                        );
                        let mut req = request.into_request();
                        req.extensions_mut()
                            .insert(
                                GrpcMethod::new("HubService", "GetReactionsByTarget"),
                            );
                        self.inner.unary(req, path, codec).await
                    }
                    /// User Data
                    pub async fn get_user_data(
                        &mut self,
                        request: impl tonic::IntoRequest<super::UserDataRequest>,
                    ) -> std::result::Result<
                        tonic::Response<super::Message>,
                        tonic::Status,
                    > {
                        self.inner
                            .ready()
                            .await
                            .map_err(|e| {
                                tonic::Status::new(
                                    tonic::Code::Unknown,
                                    {
                                        let res = ::alloc::fmt::format(
                                            format_args!("Service was not ready: {0}", e.into()),
                                        );
                                        res
                                    },
                                )
                            })?;
                        let codec = tonic::codec::ProstCodec::default();
                        let path = http::uri::PathAndQuery::from_static(
                            "/HubService/GetUserData",
                        );
                        let mut req = request.into_request();
                        req.extensions_mut()
                            .insert(GrpcMethod::new("HubService", "GetUserData"));
                        self.inner.unary(req, path, codec).await
                    }
                    pub async fn get_user_data_by_fid(
                        &mut self,
                        request: impl tonic::IntoRequest<super::FidRequest>,
                    ) -> std::result::Result<
                        tonic::Response<super::MessagesResponse>,
                        tonic::Status,
                    > {
                        self.inner
                            .ready()
                            .await
                            .map_err(|e| {
                                tonic::Status::new(
                                    tonic::Code::Unknown,
                                    {
                                        let res = ::alloc::fmt::format(
                                            format_args!("Service was not ready: {0}", e.into()),
                                        );
                                        res
                                    },
                                )
                            })?;
                        let codec = tonic::codec::ProstCodec::default();
                        let path = http::uri::PathAndQuery::from_static(
                            "/HubService/GetUserDataByFid",
                        );
                        let mut req = request.into_request();
                        req.extensions_mut()
                            .insert(GrpcMethod::new("HubService", "GetUserDataByFid"));
                        self.inner.unary(req, path, codec).await
                    }
                    pub async fn get_name_registry_event(
                        &mut self,
                        request: impl tonic::IntoRequest<super::NameRegistryEventRequest>,
                    ) -> std::result::Result<
                        tonic::Response<super::NameRegistryEvent>,
                        tonic::Status,
                    > {
                        self.inner
                            .ready()
                            .await
                            .map_err(|e| {
                                tonic::Status::new(
                                    tonic::Code::Unknown,
                                    {
                                        let res = ::alloc::fmt::format(
                                            format_args!("Service was not ready: {0}", e.into()),
                                        );
                                        res
                                    },
                                )
                            })?;
                        let codec = tonic::codec::ProstCodec::default();
                        let path = http::uri::PathAndQuery::from_static(
                            "/HubService/GetNameRegistryEvent",
                        );
                        let mut req = request.into_request();
                        req.extensions_mut()
                            .insert(
                                GrpcMethod::new("HubService", "GetNameRegistryEvent"),
                            );
                        self.inner.unary(req, path, codec).await
                    }
                    pub async fn get_on_chain_events(
                        &mut self,
                        request: impl tonic::IntoRequest<super::OnChainEventRequest>,
                    ) -> std::result::Result<
                        tonic::Response<super::OnChainEventResponse>,
                        tonic::Status,
                    > {
                        self.inner
                            .ready()
                            .await
                            .map_err(|e| {
                                tonic::Status::new(
                                    tonic::Code::Unknown,
                                    {
                                        let res = ::alloc::fmt::format(
                                            format_args!("Service was not ready: {0}", e.into()),
                                        );
                                        res
                                    },
                                )
                            })?;
                        let codec = tonic::codec::ProstCodec::default();
                        let path = http::uri::PathAndQuery::from_static(
                            "/HubService/GetOnChainEvents",
                        );
                        let mut req = request.into_request();
                        req.extensions_mut()
                            .insert(GrpcMethod::new("HubService", "GetOnChainEvents"));
                        self.inner.unary(req, path, codec).await
                    }
                    pub async fn get_current_storage_limits_by_fid(
                        &mut self,
                        request: impl tonic::IntoRequest<super::FidRequest>,
                    ) -> std::result::Result<
                        tonic::Response<super::StorageLimitsResponse>,
                        tonic::Status,
                    > {
                        self.inner
                            .ready()
                            .await
                            .map_err(|e| {
                                tonic::Status::new(
                                    tonic::Code::Unknown,
                                    {
                                        let res = ::alloc::fmt::format(
                                            format_args!("Service was not ready: {0}", e.into()),
                                        );
                                        res
                                    },
                                )
                            })?;
                        let codec = tonic::codec::ProstCodec::default();
                        let path = http::uri::PathAndQuery::from_static(
                            "/HubService/GetCurrentStorageLimitsByFid",
                        );
                        let mut req = request.into_request();
                        req.extensions_mut()
                            .insert(
                                GrpcMethod::new(
                                    "HubService",
                                    "GetCurrentStorageLimitsByFid",
                                ),
                            );
                        self.inner.unary(req, path, codec).await
                    }
                    /// Username Proof
                    pub async fn get_username_proof(
                        &mut self,
                        request: impl tonic::IntoRequest<super::UsernameProofRequest>,
                    ) -> std::result::Result<
                        tonic::Response<super::UserNameProof>,
                        tonic::Status,
                    > {
                        self.inner
                            .ready()
                            .await
                            .map_err(|e| {
                                tonic::Status::new(
                                    tonic::Code::Unknown,
                                    {
                                        let res = ::alloc::fmt::format(
                                            format_args!("Service was not ready: {0}", e.into()),
                                        );
                                        res
                                    },
                                )
                            })?;
                        let codec = tonic::codec::ProstCodec::default();
                        let path = http::uri::PathAndQuery::from_static(
                            "/HubService/GetUsernameProof",
                        );
                        let mut req = request.into_request();
                        req.extensions_mut()
                            .insert(GrpcMethod::new("HubService", "GetUsernameProof"));
                        self.inner.unary(req, path, codec).await
                    }
                    pub async fn get_user_name_proofs_by_fid(
                        &mut self,
                        request: impl tonic::IntoRequest<super::FidRequest>,
                    ) -> std::result::Result<
                        tonic::Response<super::UsernameProofsResponse>,
                        tonic::Status,
                    > {
                        self.inner
                            .ready()
                            .await
                            .map_err(|e| {
                                tonic::Status::new(
                                    tonic::Code::Unknown,
                                    {
                                        let res = ::alloc::fmt::format(
                                            format_args!("Service was not ready: {0}", e.into()),
                                        );
                                        res
                                    },
                                )
                            })?;
                        let codec = tonic::codec::ProstCodec::default();
                        let path = http::uri::PathAndQuery::from_static(
                            "/HubService/GetUserNameProofsByFid",
                        );
                        let mut req = request.into_request();
                        req.extensions_mut()
                            .insert(
                                GrpcMethod::new("HubService", "GetUserNameProofsByFid"),
                            );
                        self.inner.unary(req, path, codec).await
                    }
                    /// Verifications
                    pub async fn get_verification(
                        &mut self,
                        request: impl tonic::IntoRequest<super::VerificationRequest>,
                    ) -> std::result::Result<
                        tonic::Response<super::Message>,
                        tonic::Status,
                    > {
                        self.inner
                            .ready()
                            .await
                            .map_err(|e| {
                                tonic::Status::new(
                                    tonic::Code::Unknown,
                                    {
                                        let res = ::alloc::fmt::format(
                                            format_args!("Service was not ready: {0}", e.into()),
                                        );
                                        res
                                    },
                                )
                            })?;
                        let codec = tonic::codec::ProstCodec::default();
                        let path = http::uri::PathAndQuery::from_static(
                            "/HubService/GetVerification",
                        );
                        let mut req = request.into_request();
                        req.extensions_mut()
                            .insert(GrpcMethod::new("HubService", "GetVerification"));
                        self.inner.unary(req, path, codec).await
                    }
                    pub async fn get_verifications_by_fid(
                        &mut self,
                        request: impl tonic::IntoRequest<super::FidRequest>,
                    ) -> std::result::Result<
                        tonic::Response<super::MessagesResponse>,
                        tonic::Status,
                    > {
                        self.inner
                            .ready()
                            .await
                            .map_err(|e| {
                                tonic::Status::new(
                                    tonic::Code::Unknown,
                                    {
                                        let res = ::alloc::fmt::format(
                                            format_args!("Service was not ready: {0}", e.into()),
                                        );
                                        res
                                    },
                                )
                            })?;
                        let codec = tonic::codec::ProstCodec::default();
                        let path = http::uri::PathAndQuery::from_static(
                            "/HubService/GetVerificationsByFid",
                        );
                        let mut req = request.into_request();
                        req.extensions_mut()
                            .insert(
                                GrpcMethod::new("HubService", "GetVerificationsByFid"),
                            );
                        self.inner.unary(req, path, codec).await
                    }
                    /// Signer
                    pub async fn get_signer(
                        &mut self,
                        request: impl tonic::IntoRequest<super::SignerRequest>,
                    ) -> std::result::Result<
                        tonic::Response<super::Message>,
                        tonic::Status,
                    > {
                        self.inner
                            .ready()
                            .await
                            .map_err(|e| {
                                tonic::Status::new(
                                    tonic::Code::Unknown,
                                    {
                                        let res = ::alloc::fmt::format(
                                            format_args!("Service was not ready: {0}", e.into()),
                                        );
                                        res
                                    },
                                )
                            })?;
                        let codec = tonic::codec::ProstCodec::default();
                        let path = http::uri::PathAndQuery::from_static(
                            "/HubService/GetSigner",
                        );
                        let mut req = request.into_request();
                        req.extensions_mut()
                            .insert(GrpcMethod::new("HubService", "GetSigner"));
                        self.inner.unary(req, path, codec).await
                    }
                    pub async fn get_on_chain_signer(
                        &mut self,
                        request: impl tonic::IntoRequest<super::SignerRequest>,
                    ) -> std::result::Result<
                        tonic::Response<super::OnChainEvent>,
                        tonic::Status,
                    > {
                        self.inner
                            .ready()
                            .await
                            .map_err(|e| {
                                tonic::Status::new(
                                    tonic::Code::Unknown,
                                    {
                                        let res = ::alloc::fmt::format(
                                            format_args!("Service was not ready: {0}", e.into()),
                                        );
                                        res
                                    },
                                )
                            })?;
                        let codec = tonic::codec::ProstCodec::default();
                        let path = http::uri::PathAndQuery::from_static(
                            "/HubService/GetOnChainSigner",
                        );
                        let mut req = request.into_request();
                        req.extensions_mut()
                            .insert(GrpcMethod::new("HubService", "GetOnChainSigner"));
                        self.inner.unary(req, path, codec).await
                    }
                    pub async fn get_signers_by_fid(
                        &mut self,
                        request: impl tonic::IntoRequest<super::FidRequest>,
                    ) -> std::result::Result<
                        tonic::Response<super::MessagesResponse>,
                        tonic::Status,
                    > {
                        self.inner
                            .ready()
                            .await
                            .map_err(|e| {
                                tonic::Status::new(
                                    tonic::Code::Unknown,
                                    {
                                        let res = ::alloc::fmt::format(
                                            format_args!("Service was not ready: {0}", e.into()),
                                        );
                                        res
                                    },
                                )
                            })?;
                        let codec = tonic::codec::ProstCodec::default();
                        let path = http::uri::PathAndQuery::from_static(
                            "/HubService/GetSignersByFid",
                        );
                        let mut req = request.into_request();
                        req.extensions_mut()
                            .insert(GrpcMethod::new("HubService", "GetSignersByFid"));
                        self.inner.unary(req, path, codec).await
                    }
                    pub async fn get_id_registry_event(
                        &mut self,
                        request: impl tonic::IntoRequest<super::IdRegistryEventRequest>,
                    ) -> std::result::Result<
                        tonic::Response<super::IdRegistryEvent>,
                        tonic::Status,
                    > {
                        self.inner
                            .ready()
                            .await
                            .map_err(|e| {
                                tonic::Status::new(
                                    tonic::Code::Unknown,
                                    {
                                        let res = ::alloc::fmt::format(
                                            format_args!("Service was not ready: {0}", e.into()),
                                        );
                                        res
                                    },
                                )
                            })?;
                        let codec = tonic::codec::ProstCodec::default();
                        let path = http::uri::PathAndQuery::from_static(
                            "/HubService/GetIdRegistryEvent",
                        );
                        let mut req = request.into_request();
                        req.extensions_mut()
                            .insert(GrpcMethod::new("HubService", "GetIdRegistryEvent"));
                        self.inner.unary(req, path, codec).await
                    }
                    pub async fn get_id_registry_event_by_address(
                        &mut self,
                        request: impl tonic::IntoRequest<
                            super::IdRegistryEventByAddressRequest,
                        >,
                    ) -> std::result::Result<
                        tonic::Response<super::IdRegistryEvent>,
                        tonic::Status,
                    > {
                        self.inner
                            .ready()
                            .await
                            .map_err(|e| {
                                tonic::Status::new(
                                    tonic::Code::Unknown,
                                    {
                                        let res = ::alloc::fmt::format(
                                            format_args!("Service was not ready: {0}", e.into()),
                                        );
                                        res
                                    },
                                )
                            })?;
                        let codec = tonic::codec::ProstCodec::default();
                        let path = http::uri::PathAndQuery::from_static(
                            "/HubService/GetIdRegistryEventByAddress",
                        );
                        let mut req = request.into_request();
                        req.extensions_mut()
                            .insert(
                                GrpcMethod::new("HubService", "GetIdRegistryEventByAddress"),
                            );
                        self.inner.unary(req, path, codec).await
                    }
                    pub async fn get_fids(
                        &mut self,
                        request: impl tonic::IntoRequest<super::FidsRequest>,
                    ) -> std::result::Result<
                        tonic::Response<super::FidsResponse>,
                        tonic::Status,
                    > {
                        self.inner
                            .ready()
                            .await
                            .map_err(|e| {
                                tonic::Status::new(
                                    tonic::Code::Unknown,
                                    {
                                        let res = ::alloc::fmt::format(
                                            format_args!("Service was not ready: {0}", e.into()),
                                        );
                                        res
                                    },
                                )
                            })?;
                        let codec = tonic::codec::ProstCodec::default();
                        let path = http::uri::PathAndQuery::from_static(
                            "/HubService/GetFids",
                        );
                        let mut req = request.into_request();
                        req.extensions_mut()
                            .insert(GrpcMethod::new("HubService", "GetFids"));
                        self.inner.unary(req, path, codec).await
                    }
                    /// Links
                    pub async fn get_link(
                        &mut self,
                        request: impl tonic::IntoRequest<super::LinkRequest>,
                    ) -> std::result::Result<
                        tonic::Response<super::Message>,
                        tonic::Status,
                    > {
                        self.inner
                            .ready()
                            .await
                            .map_err(|e| {
                                tonic::Status::new(
                                    tonic::Code::Unknown,
                                    {
                                        let res = ::alloc::fmt::format(
                                            format_args!("Service was not ready: {0}", e.into()),
                                        );
                                        res
                                    },
                                )
                            })?;
                        let codec = tonic::codec::ProstCodec::default();
                        let path = http::uri::PathAndQuery::from_static(
                            "/HubService/GetLink",
                        );
                        let mut req = request.into_request();
                        req.extensions_mut()
                            .insert(GrpcMethod::new("HubService", "GetLink"));
                        self.inner.unary(req, path, codec).await
                    }
                    pub async fn get_links_by_fid(
                        &mut self,
                        request: impl tonic::IntoRequest<super::LinksByFidRequest>,
                    ) -> std::result::Result<
                        tonic::Response<super::MessagesResponse>,
                        tonic::Status,
                    > {
                        self.inner
                            .ready()
                            .await
                            .map_err(|e| {
                                tonic::Status::new(
                                    tonic::Code::Unknown,
                                    {
                                        let res = ::alloc::fmt::format(
                                            format_args!("Service was not ready: {0}", e.into()),
                                        );
                                        res
                                    },
                                )
                            })?;
                        let codec = tonic::codec::ProstCodec::default();
                        let path = http::uri::PathAndQuery::from_static(
                            "/HubService/GetLinksByFid",
                        );
                        let mut req = request.into_request();
                        req.extensions_mut()
                            .insert(GrpcMethod::new("HubService", "GetLinksByFid"));
                        self.inner.unary(req, path, codec).await
                    }
                    pub async fn get_links_by_target(
                        &mut self,
                        request: impl tonic::IntoRequest<super::LinksByTargetRequest>,
                    ) -> std::result::Result<
                        tonic::Response<super::MessagesResponse>,
                        tonic::Status,
                    > {
                        self.inner
                            .ready()
                            .await
                            .map_err(|e| {
                                tonic::Status::new(
                                    tonic::Code::Unknown,
                                    {
                                        let res = ::alloc::fmt::format(
                                            format_args!("Service was not ready: {0}", e.into()),
                                        );
                                        res
                                    },
                                )
                            })?;
                        let codec = tonic::codec::ProstCodec::default();
                        let path = http::uri::PathAndQuery::from_static(
                            "/HubService/GetLinksByTarget",
                        );
                        let mut req = request.into_request();
                        req.extensions_mut()
                            .insert(GrpcMethod::new("HubService", "GetLinksByTarget"));
                        self.inner.unary(req, path, codec).await
                    }
                    /// Bulk Methods
                    pub async fn get_all_cast_messages_by_fid(
                        &mut self,
                        request: impl tonic::IntoRequest<super::FidRequest>,
                    ) -> std::result::Result<
                        tonic::Response<super::MessagesResponse>,
                        tonic::Status,
                    > {
                        self.inner
                            .ready()
                            .await
                            .map_err(|e| {
                                tonic::Status::new(
                                    tonic::Code::Unknown,
                                    {
                                        let res = ::alloc::fmt::format(
                                            format_args!("Service was not ready: {0}", e.into()),
                                        );
                                        res
                                    },
                                )
                            })?;
                        let codec = tonic::codec::ProstCodec::default();
                        let path = http::uri::PathAndQuery::from_static(
                            "/HubService/GetAllCastMessagesByFid",
                        );
                        let mut req = request.into_request();
                        req.extensions_mut()
                            .insert(
                                GrpcMethod::new("HubService", "GetAllCastMessagesByFid"),
                            );
                        self.inner.unary(req, path, codec).await
                    }
                    pub async fn get_all_reaction_messages_by_fid(
                        &mut self,
                        request: impl tonic::IntoRequest<super::FidRequest>,
                    ) -> std::result::Result<
                        tonic::Response<super::MessagesResponse>,
                        tonic::Status,
                    > {
                        self.inner
                            .ready()
                            .await
                            .map_err(|e| {
                                tonic::Status::new(
                                    tonic::Code::Unknown,
                                    {
                                        let res = ::alloc::fmt::format(
                                            format_args!("Service was not ready: {0}", e.into()),
                                        );
                                        res
                                    },
                                )
                            })?;
                        let codec = tonic::codec::ProstCodec::default();
                        let path = http::uri::PathAndQuery::from_static(
                            "/HubService/GetAllReactionMessagesByFid",
                        );
                        let mut req = request.into_request();
                        req.extensions_mut()
                            .insert(
                                GrpcMethod::new("HubService", "GetAllReactionMessagesByFid"),
                            );
                        self.inner.unary(req, path, codec).await
                    }
                    pub async fn get_all_verification_messages_by_fid(
                        &mut self,
                        request: impl tonic::IntoRequest<super::FidRequest>,
                    ) -> std::result::Result<
                        tonic::Response<super::MessagesResponse>,
                        tonic::Status,
                    > {
                        self.inner
                            .ready()
                            .await
                            .map_err(|e| {
                                tonic::Status::new(
                                    tonic::Code::Unknown,
                                    {
                                        let res = ::alloc::fmt::format(
                                            format_args!("Service was not ready: {0}", e.into()),
                                        );
                                        res
                                    },
                                )
                            })?;
                        let codec = tonic::codec::ProstCodec::default();
                        let path = http::uri::PathAndQuery::from_static(
                            "/HubService/GetAllVerificationMessagesByFid",
                        );
                        let mut req = request.into_request();
                        req.extensions_mut()
                            .insert(
                                GrpcMethod::new(
                                    "HubService",
                                    "GetAllVerificationMessagesByFid",
                                ),
                            );
                        self.inner.unary(req, path, codec).await
                    }
                    pub async fn get_all_signer_messages_by_fid(
                        &mut self,
                        request: impl tonic::IntoRequest<super::FidRequest>,
                    ) -> std::result::Result<
                        tonic::Response<super::MessagesResponse>,
                        tonic::Status,
                    > {
                        self.inner
                            .ready()
                            .await
                            .map_err(|e| {
                                tonic::Status::new(
                                    tonic::Code::Unknown,
                                    {
                                        let res = ::alloc::fmt::format(
                                            format_args!("Service was not ready: {0}", e.into()),
                                        );
                                        res
                                    },
                                )
                            })?;
                        let codec = tonic::codec::ProstCodec::default();
                        let path = http::uri::PathAndQuery::from_static(
                            "/HubService/GetAllSignerMessagesByFid",
                        );
                        let mut req = request.into_request();
                        req.extensions_mut()
                            .insert(
                                GrpcMethod::new("HubService", "GetAllSignerMessagesByFid"),
                            );
                        self.inner.unary(req, path, codec).await
                    }
                    pub async fn get_all_user_data_messages_by_fid(
                        &mut self,
                        request: impl tonic::IntoRequest<super::FidRequest>,
                    ) -> std::result::Result<
                        tonic::Response<super::MessagesResponse>,
                        tonic::Status,
                    > {
                        self.inner
                            .ready()
                            .await
                            .map_err(|e| {
                                tonic::Status::new(
                                    tonic::Code::Unknown,
                                    {
                                        let res = ::alloc::fmt::format(
                                            format_args!("Service was not ready: {0}", e.into()),
                                        );
                                        res
                                    },
                                )
                            })?;
                        let codec = tonic::codec::ProstCodec::default();
                        let path = http::uri::PathAndQuery::from_static(
                            "/HubService/GetAllUserDataMessagesByFid",
                        );
                        let mut req = request.into_request();
                        req.extensions_mut()
                            .insert(
                                GrpcMethod::new("HubService", "GetAllUserDataMessagesByFid"),
                            );
                        self.inner.unary(req, path, codec).await
                    }
                    pub async fn get_all_link_messages_by_fid(
                        &mut self,
                        request: impl tonic::IntoRequest<super::FidRequest>,
                    ) -> std::result::Result<
                        tonic::Response<super::MessagesResponse>,
                        tonic::Status,
                    > {
                        self.inner
                            .ready()
                            .await
                            .map_err(|e| {
                                tonic::Status::new(
                                    tonic::Code::Unknown,
                                    {
                                        let res = ::alloc::fmt::format(
                                            format_args!("Service was not ready: {0}", e.into()),
                                        );
                                        res
                                    },
                                )
                            })?;
                        let codec = tonic::codec::ProstCodec::default();
                        let path = http::uri::PathAndQuery::from_static(
                            "/HubService/GetAllLinkMessagesByFid",
                        );
                        let mut req = request.into_request();
                        req.extensions_mut()
                            .insert(
                                GrpcMethod::new("HubService", "GetAllLinkMessagesByFid"),
                            );
                        self.inner.unary(req, path, codec).await
                    }
                    /// Sync Methods
                    pub async fn get_info(
                        &mut self,
                        request: impl tonic::IntoRequest<super::HubInfoRequest>,
                    ) -> std::result::Result<
                        tonic::Response<super::HubInfoResponse>,
                        tonic::Status,
                    > {
                        self.inner
                            .ready()
                            .await
                            .map_err(|e| {
                                tonic::Status::new(
                                    tonic::Code::Unknown,
                                    {
                                        let res = ::alloc::fmt::format(
                                            format_args!("Service was not ready: {0}", e.into()),
                                        );
                                        res
                                    },
                                )
                            })?;
                        let codec = tonic::codec::ProstCodec::default();
                        let path = http::uri::PathAndQuery::from_static(
                            "/HubService/GetInfo",
                        );
                        let mut req = request.into_request();
                        req.extensions_mut()
                            .insert(GrpcMethod::new("HubService", "GetInfo"));
                        self.inner.unary(req, path, codec).await
                    }
                    pub async fn get_sync_status(
                        &mut self,
                        request: impl tonic::IntoRequest<super::SyncStatusRequest>,
                    ) -> std::result::Result<
                        tonic::Response<super::SyncStatusResponse>,
                        tonic::Status,
                    > {
                        self.inner
                            .ready()
                            .await
                            .map_err(|e| {
                                tonic::Status::new(
                                    tonic::Code::Unknown,
                                    {
                                        let res = ::alloc::fmt::format(
                                            format_args!("Service was not ready: {0}", e.into()),
                                        );
                                        res
                                    },
                                )
                            })?;
                        let codec = tonic::codec::ProstCodec::default();
                        let path = http::uri::PathAndQuery::from_static(
                            "/HubService/GetSyncStatus",
                        );
                        let mut req = request.into_request();
                        req.extensions_mut()
                            .insert(GrpcMethod::new("HubService", "GetSyncStatus"));
                        self.inner.unary(req, path, codec).await
                    }
                    pub async fn get_all_sync_ids_by_prefix(
                        &mut self,
                        request: impl tonic::IntoRequest<super::TrieNodePrefix>,
                    ) -> std::result::Result<
                        tonic::Response<super::SyncIds>,
                        tonic::Status,
                    > {
                        self.inner
                            .ready()
                            .await
                            .map_err(|e| {
                                tonic::Status::new(
                                    tonic::Code::Unknown,
                                    {
                                        let res = ::alloc::fmt::format(
                                            format_args!("Service was not ready: {0}", e.into()),
                                        );
                                        res
                                    },
                                )
                            })?;
                        let codec = tonic::codec::ProstCodec::default();
                        let path = http::uri::PathAndQuery::from_static(
                            "/HubService/GetAllSyncIdsByPrefix",
                        );
                        let mut req = request.into_request();
                        req.extensions_mut()
                            .insert(
                                GrpcMethod::new("HubService", "GetAllSyncIdsByPrefix"),
                            );
                        self.inner.unary(req, path, codec).await
                    }
                    pub async fn get_all_messages_by_sync_ids(
                        &mut self,
                        request: impl tonic::IntoRequest<super::SyncIds>,
                    ) -> std::result::Result<
                        tonic::Response<super::MessagesResponse>,
                        tonic::Status,
                    > {
                        self.inner
                            .ready()
                            .await
                            .map_err(|e| {
                                tonic::Status::new(
                                    tonic::Code::Unknown,
                                    {
                                        let res = ::alloc::fmt::format(
                                            format_args!("Service was not ready: {0}", e.into()),
                                        );
                                        res
                                    },
                                )
                            })?;
                        let codec = tonic::codec::ProstCodec::default();
                        let path = http::uri::PathAndQuery::from_static(
                            "/HubService/GetAllMessagesBySyncIds",
                        );
                        let mut req = request.into_request();
                        req.extensions_mut()
                            .insert(
                                GrpcMethod::new("HubService", "GetAllMessagesBySyncIds"),
                            );
                        self.inner.unary(req, path, codec).await
                    }
                    pub async fn get_sync_metadata_by_prefix(
                        &mut self,
                        request: impl tonic::IntoRequest<super::TrieNodePrefix>,
                    ) -> std::result::Result<
                        tonic::Response<super::TrieNodeMetadataResponse>,
                        tonic::Status,
                    > {
                        self.inner
                            .ready()
                            .await
                            .map_err(|e| {
                                tonic::Status::new(
                                    tonic::Code::Unknown,
                                    {
                                        let res = ::alloc::fmt::format(
                                            format_args!("Service was not ready: {0}", e.into()),
                                        );
                                        res
                                    },
                                )
                            })?;
                        let codec = tonic::codec::ProstCodec::default();
                        let path = http::uri::PathAndQuery::from_static(
                            "/HubService/GetSyncMetadataByPrefix",
                        );
                        let mut req = request.into_request();
                        req.extensions_mut()
                            .insert(
                                GrpcMethod::new("HubService", "GetSyncMetadataByPrefix"),
                            );
                        self.inner.unary(req, path, codec).await
                    }
                    pub async fn get_sync_snapshot_by_prefix(
                        &mut self,
                        request: impl tonic::IntoRequest<super::TrieNodePrefix>,
                    ) -> std::result::Result<
                        tonic::Response<super::TrieNodeSnapshotResponse>,
                        tonic::Status,
                    > {
                        self.inner
                            .ready()
                            .await
                            .map_err(|e| {
                                tonic::Status::new(
                                    tonic::Code::Unknown,
                                    {
                                        let res = ::alloc::fmt::format(
                                            format_args!("Service was not ready: {0}", e.into()),
                                        );
                                        res
                                    },
                                )
                            })?;
                        let codec = tonic::codec::ProstCodec::default();
                        let path = http::uri::PathAndQuery::from_static(
                            "/HubService/GetSyncSnapshotByPrefix",
                        );
                        let mut req = request.into_request();
                        req.extensions_mut()
                            .insert(
                                GrpcMethod::new("HubService", "GetSyncSnapshotByPrefix"),
                            );
                        self.inner.unary(req, path, codec).await
                    }
                }
            }
            /// Generated client implementations.
            pub mod admin_service_client {
                #![allow(
                    unused_variables,
                    dead_code,
                    missing_docs,
                    clippy::let_unit_value
                )]
                use tonic::codegen::*;
                use tonic::codegen::http::Uri;
                pub struct AdminServiceClient<T> {
                    inner: tonic::client::Grpc<T>,
                }
                #[automatically_derived]
                impl<T: ::core::fmt::Debug> ::core::fmt::Debug
                for AdminServiceClient<T> {
                    fn fmt(
                        &self,
                        f: &mut ::core::fmt::Formatter,
                    ) -> ::core::fmt::Result {
                        ::core::fmt::Formatter::debug_struct_field1_finish(
                            f,
                            "AdminServiceClient",
                            "inner",
                            &&self.inner,
                        )
                    }
                }
                #[automatically_derived]
                impl<T: ::core::clone::Clone> ::core::clone::Clone
                for AdminServiceClient<T> {
                    #[inline]
                    fn clone(&self) -> AdminServiceClient<T> {
                        AdminServiceClient {
                            inner: ::core::clone::Clone::clone(&self.inner),
                        }
                    }
                }
                impl AdminServiceClient<tonic::transport::Channel> {
                    /// Attempt to create a new client by connecting to a given endpoint.
                    pub async fn connect<D>(
                        dst: D,
                    ) -> Result<Self, tonic::transport::Error>
                    where
                        D: TryInto<tonic::transport::Endpoint>,
                        D::Error: Into<StdError>,
                    {
                        let conn = tonic::transport::Endpoint::new(dst)?
                            .connect()
                            .await?;
                        Ok(Self::new(conn))
                    }
                }
                impl<T> AdminServiceClient<T>
                where
                    T: tonic::client::GrpcService<tonic::body::BoxBody>,
                    T::Error: Into<StdError>,
                    T::ResponseBody: Body<Data = Bytes> + Send + 'static,
                    <T::ResponseBody as Body>::Error: Into<StdError> + Send,
                {
                    pub fn new(inner: T) -> Self {
                        let inner = tonic::client::Grpc::new(inner);
                        Self { inner }
                    }
                    pub fn with_origin(inner: T, origin: Uri) -> Self {
                        let inner = tonic::client::Grpc::with_origin(inner, origin);
                        Self { inner }
                    }
                    pub fn with_interceptor<F>(
                        inner: T,
                        interceptor: F,
                    ) -> AdminServiceClient<InterceptedService<T, F>>
                    where
                        F: tonic::service::Interceptor,
                        T::ResponseBody: Default,
                        T: tonic::codegen::Service<
                            http::Request<tonic::body::BoxBody>,
                            Response = http::Response<
                                <T as tonic::client::GrpcService<
                                    tonic::body::BoxBody,
                                >>::ResponseBody,
                            >,
                        >,
                        <T as tonic::codegen::Service<
                            http::Request<tonic::body::BoxBody>,
                        >>::Error: Into<StdError> + Send + Sync,
                    {
                        AdminServiceClient::new(
                            InterceptedService::new(inner, interceptor),
                        )
                    }
                    /// Compress requests with the given encoding.
                    ///
                    /// This requires the server to support it otherwise it might respond with an
                    /// error.
                    #[must_use]
                    pub fn send_compressed(
                        mut self,
                        encoding: CompressionEncoding,
                    ) -> Self {
                        self.inner = self.inner.send_compressed(encoding);
                        self
                    }
                    /// Enable decompressing responses.
                    #[must_use]
                    pub fn accept_compressed(
                        mut self,
                        encoding: CompressionEncoding,
                    ) -> Self {
                        self.inner = self.inner.accept_compressed(encoding);
                        self
                    }
                    /// Limits the maximum size of a decoded message.
                    ///
                    /// Default: `4MB`
                    #[must_use]
                    pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
                        self.inner = self.inner.max_decoding_message_size(limit);
                        self
                    }
                    /// Limits the maximum size of an encoded message.
                    ///
                    /// Default: `usize::MAX`
                    #[must_use]
                    pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
                        self.inner = self.inner.max_encoding_message_size(limit);
                        self
                    }
                    pub async fn rebuild_sync_trie(
                        &mut self,
                        request: impl tonic::IntoRequest<super::Empty>,
                    ) -> std::result::Result<
                        tonic::Response<super::Empty>,
                        tonic::Status,
                    > {
                        self.inner
                            .ready()
                            .await
                            .map_err(|e| {
                                tonic::Status::new(
                                    tonic::Code::Unknown,
                                    {
                                        let res = ::alloc::fmt::format(
                                            format_args!("Service was not ready: {0}", e.into()),
                                        );
                                        res
                                    },
                                )
                            })?;
                        let codec = tonic::codec::ProstCodec::default();
                        let path = http::uri::PathAndQuery::from_static(
                            "/AdminService/RebuildSyncTrie",
                        );
                        let mut req = request.into_request();
                        req.extensions_mut()
                            .insert(GrpcMethod::new("AdminService", "RebuildSyncTrie"));
                        self.inner.unary(req, path, codec).await
                    }
                    pub async fn delete_all_messages_from_db(
                        &mut self,
                        request: impl tonic::IntoRequest<super::Empty>,
                    ) -> std::result::Result<
                        tonic::Response<super::Empty>,
                        tonic::Status,
                    > {
                        self.inner
                            .ready()
                            .await
                            .map_err(|e| {
                                tonic::Status::new(
                                    tonic::Code::Unknown,
                                    {
                                        let res = ::alloc::fmt::format(
                                            format_args!("Service was not ready: {0}", e.into()),
                                        );
                                        res
                                    },
                                )
                            })?;
                        let codec = tonic::codec::ProstCodec::default();
                        let path = http::uri::PathAndQuery::from_static(
                            "/AdminService/DeleteAllMessagesFromDb",
                        );
                        let mut req = request.into_request();
                        req.extensions_mut()
                            .insert(
                                GrpcMethod::new("AdminService", "DeleteAllMessagesFromDb"),
                            );
                        self.inner.unary(req, path, codec).await
                    }
                    pub async fn submit_id_registry_event(
                        &mut self,
                        request: impl tonic::IntoRequest<super::IdRegistryEvent>,
                    ) -> std::result::Result<
                        tonic::Response<super::IdRegistryEvent>,
                        tonic::Status,
                    > {
                        self.inner
                            .ready()
                            .await
                            .map_err(|e| {
                                tonic::Status::new(
                                    tonic::Code::Unknown,
                                    {
                                        let res = ::alloc::fmt::format(
                                            format_args!("Service was not ready: {0}", e.into()),
                                        );
                                        res
                                    },
                                )
                            })?;
                        let codec = tonic::codec::ProstCodec::default();
                        let path = http::uri::PathAndQuery::from_static(
                            "/AdminService/SubmitIdRegistryEvent",
                        );
                        let mut req = request.into_request();
                        req.extensions_mut()
                            .insert(
                                GrpcMethod::new("AdminService", "SubmitIdRegistryEvent"),
                            );
                        self.inner.unary(req, path, codec).await
                    }
                    pub async fn submit_name_registry_event(
                        &mut self,
                        request: impl tonic::IntoRequest<super::NameRegistryEvent>,
                    ) -> std::result::Result<
                        tonic::Response<super::NameRegistryEvent>,
                        tonic::Status,
                    > {
                        self.inner
                            .ready()
                            .await
                            .map_err(|e| {
                                tonic::Status::new(
                                    tonic::Code::Unknown,
                                    {
                                        let res = ::alloc::fmt::format(
                                            format_args!("Service was not ready: {0}", e.into()),
                                        );
                                        res
                                    },
                                )
                            })?;
                        let codec = tonic::codec::ProstCodec::default();
                        let path = http::uri::PathAndQuery::from_static(
                            "/AdminService/SubmitNameRegistryEvent",
                        );
                        let mut req = request.into_request();
                        req.extensions_mut()
                            .insert(
                                GrpcMethod::new("AdminService", "SubmitNameRegistryEvent"),
                            );
                        self.inner.unary(req, path, codec).await
                    }
                    pub async fn submit_on_chain_event(
                        &mut self,
                        request: impl tonic::IntoRequest<super::OnChainEvent>,
                    ) -> std::result::Result<
                        tonic::Response<super::OnChainEvent>,
                        tonic::Status,
                    > {
                        self.inner
                            .ready()
                            .await
                            .map_err(|e| {
                                tonic::Status::new(
                                    tonic::Code::Unknown,
                                    {
                                        let res = ::alloc::fmt::format(
                                            format_args!("Service was not ready: {0}", e.into()),
                                        );
                                        res
                                    },
                                )
                            })?;
                        let codec = tonic::codec::ProstCodec::default();
                        let path = http::uri::PathAndQuery::from_static(
                            "/AdminService/SubmitOnChainEvent",
                        );
                        let mut req = request.into_request();
                        req.extensions_mut()
                            .insert(
                                GrpcMethod::new("AdminService", "SubmitOnChainEvent"),
                            );
                        self.inner.unary(req, path, codec).await
                    }
                }
            }
            /// Generated server implementations.
            pub mod hub_service_server {
                #![allow(
                    unused_variables,
                    dead_code,
                    missing_docs,
                    clippy::let_unit_value
                )]
                use tonic::codegen::*;
                /// Generated trait containing gRPC methods that should be implemented for use with HubServiceServer.
                pub trait HubService: Send + Sync + 'static {
                    /// Submit Methods
                    #[must_use]
                    #[allow(clippy::type_complexity, clippy::type_repetition_in_bounds)]
                    fn submit_message<'life0, 'async_trait>(
                        &'life0 self,
                        request: tonic::Request<super::Message>,
                    ) -> ::core::pin::Pin<
                        Box<
                            dyn ::core::future::Future<
                                Output = std::result::Result<
                                    tonic::Response<super::Message>,
                                    tonic::Status,
                                >,
                            > + ::core::marker::Send + 'async_trait,
                        >,
                    >
                    where
                        'life0: 'async_trait,
                        Self: 'async_trait;
                    /// Server streaming response type for the Subscribe method.
                    type SubscribeStream: futures_core::Stream<
                            Item = std::result::Result<super::HubEvent, tonic::Status>,
                        >
                        + Send
                        + 'static;
                    /// Event Methods
                    #[must_use]
                    #[allow(clippy::type_complexity, clippy::type_repetition_in_bounds)]
                    fn subscribe<'life0, 'async_trait>(
                        &'life0 self,
                        request: tonic::Request<super::SubscribeRequest>,
                    ) -> ::core::pin::Pin<
                        Box<
                            dyn ::core::future::Future<
                                Output = std::result::Result<
                                    tonic::Response<Self::SubscribeStream>,
                                    tonic::Status,
                                >,
                            > + ::core::marker::Send + 'async_trait,
                        >,
                    >
                    where
                        'life0: 'async_trait,
                        Self: 'async_trait;
                    #[must_use]
                    #[allow(clippy::type_complexity, clippy::type_repetition_in_bounds)]
                    fn get_event<'life0, 'async_trait>(
                        &'life0 self,
                        request: tonic::Request<super::EventRequest>,
                    ) -> ::core::pin::Pin<
                        Box<
                            dyn ::core::future::Future<
                                Output = std::result::Result<
                                    tonic::Response<super::HubEvent>,
                                    tonic::Status,
                                >,
                            > + ::core::marker::Send + 'async_trait,
                        >,
                    >
                    where
                        'life0: 'async_trait,
                        Self: 'async_trait;
                    /// Casts
                    #[must_use]
                    #[allow(clippy::type_complexity, clippy::type_repetition_in_bounds)]
                    fn get_cast<'life0, 'async_trait>(
                        &'life0 self,
                        request: tonic::Request<super::CastId>,
                    ) -> ::core::pin::Pin<
                        Box<
                            dyn ::core::future::Future<
                                Output = std::result::Result<
                                    tonic::Response<super::Message>,
                                    tonic::Status,
                                >,
                            > + ::core::marker::Send + 'async_trait,
                        >,
                    >
                    where
                        'life0: 'async_trait,
                        Self: 'async_trait;
                    #[must_use]
                    #[allow(clippy::type_complexity, clippy::type_repetition_in_bounds)]
                    fn get_casts_by_fid<'life0, 'async_trait>(
                        &'life0 self,
                        request: tonic::Request<super::FidRequest>,
                    ) -> ::core::pin::Pin<
                        Box<
                            dyn ::core::future::Future<
                                Output = std::result::Result<
                                    tonic::Response<super::MessagesResponse>,
                                    tonic::Status,
                                >,
                            > + ::core::marker::Send + 'async_trait,
                        >,
                    >
                    where
                        'life0: 'async_trait,
                        Self: 'async_trait;
                    #[must_use]
                    #[allow(clippy::type_complexity, clippy::type_repetition_in_bounds)]
                    fn get_casts_by_parent<'life0, 'async_trait>(
                        &'life0 self,
                        request: tonic::Request<super::CastsByParentRequest>,
                    ) -> ::core::pin::Pin<
                        Box<
                            dyn ::core::future::Future<
                                Output = std::result::Result<
                                    tonic::Response<super::MessagesResponse>,
                                    tonic::Status,
                                >,
                            > + ::core::marker::Send + 'async_trait,
                        >,
                    >
                    where
                        'life0: 'async_trait,
                        Self: 'async_trait;
                    #[must_use]
                    #[allow(clippy::type_complexity, clippy::type_repetition_in_bounds)]
                    fn get_casts_by_mention<'life0, 'async_trait>(
                        &'life0 self,
                        request: tonic::Request<super::FidRequest>,
                    ) -> ::core::pin::Pin<
                        Box<
                            dyn ::core::future::Future<
                                Output = std::result::Result<
                                    tonic::Response<super::MessagesResponse>,
                                    tonic::Status,
                                >,
                            > + ::core::marker::Send + 'async_trait,
                        >,
                    >
                    where
                        'life0: 'async_trait,
                        Self: 'async_trait;
                    /// Reactions
                    #[must_use]
                    #[allow(clippy::type_complexity, clippy::type_repetition_in_bounds)]
                    fn get_reaction<'life0, 'async_trait>(
                        &'life0 self,
                        request: tonic::Request<super::ReactionRequest>,
                    ) -> ::core::pin::Pin<
                        Box<
                            dyn ::core::future::Future<
                                Output = std::result::Result<
                                    tonic::Response<super::Message>,
                                    tonic::Status,
                                >,
                            > + ::core::marker::Send + 'async_trait,
                        >,
                    >
                    where
                        'life0: 'async_trait,
                        Self: 'async_trait;
                    #[must_use]
                    #[allow(clippy::type_complexity, clippy::type_repetition_in_bounds)]
                    fn get_reactions_by_fid<'life0, 'async_trait>(
                        &'life0 self,
                        request: tonic::Request<super::ReactionsByFidRequest>,
                    ) -> ::core::pin::Pin<
                        Box<
                            dyn ::core::future::Future<
                                Output = std::result::Result<
                                    tonic::Response<super::MessagesResponse>,
                                    tonic::Status,
                                >,
                            > + ::core::marker::Send + 'async_trait,
                        >,
                    >
                    where
                        'life0: 'async_trait,
                        Self: 'async_trait;
                    #[must_use]
                    #[allow(clippy::type_complexity, clippy::type_repetition_in_bounds)]
                    fn get_reactions_by_cast<'life0, 'async_trait>(
                        &'life0 self,
                        request: tonic::Request<super::ReactionsByTargetRequest>,
                    ) -> ::core::pin::Pin<
                        Box<
                            dyn ::core::future::Future<
                                Output = std::result::Result<
                                    tonic::Response<super::MessagesResponse>,
                                    tonic::Status,
                                >,
                            > + ::core::marker::Send + 'async_trait,
                        >,
                    >
                    where
                        'life0: 'async_trait,
                        Self: 'async_trait;
                    #[must_use]
                    #[allow(clippy::type_complexity, clippy::type_repetition_in_bounds)]
                    fn get_reactions_by_target<'life0, 'async_trait>(
                        &'life0 self,
                        request: tonic::Request<super::ReactionsByTargetRequest>,
                    ) -> ::core::pin::Pin<
                        Box<
                            dyn ::core::future::Future<
                                Output = std::result::Result<
                                    tonic::Response<super::MessagesResponse>,
                                    tonic::Status,
                                >,
                            > + ::core::marker::Send + 'async_trait,
                        >,
                    >
                    where
                        'life0: 'async_trait,
                        Self: 'async_trait;
                    /// User Data
                    #[must_use]
                    #[allow(clippy::type_complexity, clippy::type_repetition_in_bounds)]
                    fn get_user_data<'life0, 'async_trait>(
                        &'life0 self,
                        request: tonic::Request<super::UserDataRequest>,
                    ) -> ::core::pin::Pin<
                        Box<
                            dyn ::core::future::Future<
                                Output = std::result::Result<
                                    tonic::Response<super::Message>,
                                    tonic::Status,
                                >,
                            > + ::core::marker::Send + 'async_trait,
                        >,
                    >
                    where
                        'life0: 'async_trait,
                        Self: 'async_trait;
                    #[must_use]
                    #[allow(clippy::type_complexity, clippy::type_repetition_in_bounds)]
                    fn get_user_data_by_fid<'life0, 'async_trait>(
                        &'life0 self,
                        request: tonic::Request<super::FidRequest>,
                    ) -> ::core::pin::Pin<
                        Box<
                            dyn ::core::future::Future<
                                Output = std::result::Result<
                                    tonic::Response<super::MessagesResponse>,
                                    tonic::Status,
                                >,
                            > + ::core::marker::Send + 'async_trait,
                        >,
                    >
                    where
                        'life0: 'async_trait,
                        Self: 'async_trait;
                    #[must_use]
                    #[allow(clippy::type_complexity, clippy::type_repetition_in_bounds)]
                    fn get_name_registry_event<'life0, 'async_trait>(
                        &'life0 self,
                        request: tonic::Request<super::NameRegistryEventRequest>,
                    ) -> ::core::pin::Pin<
                        Box<
                            dyn ::core::future::Future<
                                Output = std::result::Result<
                                    tonic::Response<super::NameRegistryEvent>,
                                    tonic::Status,
                                >,
                            > + ::core::marker::Send + 'async_trait,
                        >,
                    >
                    where
                        'life0: 'async_trait,
                        Self: 'async_trait;
                    #[must_use]
                    #[allow(clippy::type_complexity, clippy::type_repetition_in_bounds)]
                    fn get_on_chain_events<'life0, 'async_trait>(
                        &'life0 self,
                        request: tonic::Request<super::OnChainEventRequest>,
                    ) -> ::core::pin::Pin<
                        Box<
                            dyn ::core::future::Future<
                                Output = std::result::Result<
                                    tonic::Response<super::OnChainEventResponse>,
                                    tonic::Status,
                                >,
                            > + ::core::marker::Send + 'async_trait,
                        >,
                    >
                    where
                        'life0: 'async_trait,
                        Self: 'async_trait;
                    #[must_use]
                    #[allow(clippy::type_complexity, clippy::type_repetition_in_bounds)]
                    fn get_current_storage_limits_by_fid<'life0, 'async_trait>(
                        &'life0 self,
                        request: tonic::Request<super::FidRequest>,
                    ) -> ::core::pin::Pin<
                        Box<
                            dyn ::core::future::Future<
                                Output = std::result::Result<
                                    tonic::Response<super::StorageLimitsResponse>,
                                    tonic::Status,
                                >,
                            > + ::core::marker::Send + 'async_trait,
                        >,
                    >
                    where
                        'life0: 'async_trait,
                        Self: 'async_trait;
                    /// Username Proof
                    #[must_use]
                    #[allow(clippy::type_complexity, clippy::type_repetition_in_bounds)]
                    fn get_username_proof<'life0, 'async_trait>(
                        &'life0 self,
                        request: tonic::Request<super::UsernameProofRequest>,
                    ) -> ::core::pin::Pin<
                        Box<
                            dyn ::core::future::Future<
                                Output = std::result::Result<
                                    tonic::Response<super::UserNameProof>,
                                    tonic::Status,
                                >,
                            > + ::core::marker::Send + 'async_trait,
                        >,
                    >
                    where
                        'life0: 'async_trait,
                        Self: 'async_trait;
                    #[must_use]
                    #[allow(clippy::type_complexity, clippy::type_repetition_in_bounds)]
                    fn get_user_name_proofs_by_fid<'life0, 'async_trait>(
                        &'life0 self,
                        request: tonic::Request<super::FidRequest>,
                    ) -> ::core::pin::Pin<
                        Box<
                            dyn ::core::future::Future<
                                Output = std::result::Result<
                                    tonic::Response<super::UsernameProofsResponse>,
                                    tonic::Status,
                                >,
                            > + ::core::marker::Send + 'async_trait,
                        >,
                    >
                    where
                        'life0: 'async_trait,
                        Self: 'async_trait;
                    /// Verifications
                    #[must_use]
                    #[allow(clippy::type_complexity, clippy::type_repetition_in_bounds)]
                    fn get_verification<'life0, 'async_trait>(
                        &'life0 self,
                        request: tonic::Request<super::VerificationRequest>,
                    ) -> ::core::pin::Pin<
                        Box<
                            dyn ::core::future::Future<
                                Output = std::result::Result<
                                    tonic::Response<super::Message>,
                                    tonic::Status,
                                >,
                            > + ::core::marker::Send + 'async_trait,
                        >,
                    >
                    where
                        'life0: 'async_trait,
                        Self: 'async_trait;
                    #[must_use]
                    #[allow(clippy::type_complexity, clippy::type_repetition_in_bounds)]
                    fn get_verifications_by_fid<'life0, 'async_trait>(
                        &'life0 self,
                        request: tonic::Request<super::FidRequest>,
                    ) -> ::core::pin::Pin<
                        Box<
                            dyn ::core::future::Future<
                                Output = std::result::Result<
                                    tonic::Response<super::MessagesResponse>,
                                    tonic::Status,
                                >,
                            > + ::core::marker::Send + 'async_trait,
                        >,
                    >
                    where
                        'life0: 'async_trait,
                        Self: 'async_trait;
                    /// Signer
                    #[must_use]
                    #[allow(clippy::type_complexity, clippy::type_repetition_in_bounds)]
                    fn get_signer<'life0, 'async_trait>(
                        &'life0 self,
                        request: tonic::Request<super::SignerRequest>,
                    ) -> ::core::pin::Pin<
                        Box<
                            dyn ::core::future::Future<
                                Output = std::result::Result<
                                    tonic::Response<super::Message>,
                                    tonic::Status,
                                >,
                            > + ::core::marker::Send + 'async_trait,
                        >,
                    >
                    where
                        'life0: 'async_trait,
                        Self: 'async_trait;
                    #[must_use]
                    #[allow(clippy::type_complexity, clippy::type_repetition_in_bounds)]
                    fn get_on_chain_signer<'life0, 'async_trait>(
                        &'life0 self,
                        request: tonic::Request<super::SignerRequest>,
                    ) -> ::core::pin::Pin<
                        Box<
                            dyn ::core::future::Future<
                                Output = std::result::Result<
                                    tonic::Response<super::OnChainEvent>,
                                    tonic::Status,
                                >,
                            > + ::core::marker::Send + 'async_trait,
                        >,
                    >
                    where
                        'life0: 'async_trait,
                        Self: 'async_trait;
                    #[must_use]
                    #[allow(clippy::type_complexity, clippy::type_repetition_in_bounds)]
                    fn get_signers_by_fid<'life0, 'async_trait>(
                        &'life0 self,
                        request: tonic::Request<super::FidRequest>,
                    ) -> ::core::pin::Pin<
                        Box<
                            dyn ::core::future::Future<
                                Output = std::result::Result<
                                    tonic::Response<super::MessagesResponse>,
                                    tonic::Status,
                                >,
                            > + ::core::marker::Send + 'async_trait,
                        >,
                    >
                    where
                        'life0: 'async_trait,
                        Self: 'async_trait;
                    #[must_use]
                    #[allow(clippy::type_complexity, clippy::type_repetition_in_bounds)]
                    fn get_id_registry_event<'life0, 'async_trait>(
                        &'life0 self,
                        request: tonic::Request<super::IdRegistryEventRequest>,
                    ) -> ::core::pin::Pin<
                        Box<
                            dyn ::core::future::Future<
                                Output = std::result::Result<
                                    tonic::Response<super::IdRegistryEvent>,
                                    tonic::Status,
                                >,
                            > + ::core::marker::Send + 'async_trait,
                        >,
                    >
                    where
                        'life0: 'async_trait,
                        Self: 'async_trait;
                    #[must_use]
                    #[allow(clippy::type_complexity, clippy::type_repetition_in_bounds)]
                    fn get_id_registry_event_by_address<'life0, 'async_trait>(
                        &'life0 self,
                        request: tonic::Request<super::IdRegistryEventByAddressRequest>,
                    ) -> ::core::pin::Pin<
                        Box<
                            dyn ::core::future::Future<
                                Output = std::result::Result<
                                    tonic::Response<super::IdRegistryEvent>,
                                    tonic::Status,
                                >,
                            > + ::core::marker::Send + 'async_trait,
                        >,
                    >
                    where
                        'life0: 'async_trait,
                        Self: 'async_trait;
                    #[must_use]
                    #[allow(clippy::type_complexity, clippy::type_repetition_in_bounds)]
                    fn get_fids<'life0, 'async_trait>(
                        &'life0 self,
                        request: tonic::Request<super::FidsRequest>,
                    ) -> ::core::pin::Pin<
                        Box<
                            dyn ::core::future::Future<
                                Output = std::result::Result<
                                    tonic::Response<super::FidsResponse>,
                                    tonic::Status,
                                >,
                            > + ::core::marker::Send + 'async_trait,
                        >,
                    >
                    where
                        'life0: 'async_trait,
                        Self: 'async_trait;
                    /// Links
                    #[must_use]
                    #[allow(clippy::type_complexity, clippy::type_repetition_in_bounds)]
                    fn get_link<'life0, 'async_trait>(
                        &'life0 self,
                        request: tonic::Request<super::LinkRequest>,
                    ) -> ::core::pin::Pin<
                        Box<
                            dyn ::core::future::Future<
                                Output = std::result::Result<
                                    tonic::Response<super::Message>,
                                    tonic::Status,
                                >,
                            > + ::core::marker::Send + 'async_trait,
                        >,
                    >
                    where
                        'life0: 'async_trait,
                        Self: 'async_trait;
                    #[must_use]
                    #[allow(clippy::type_complexity, clippy::type_repetition_in_bounds)]
                    fn get_links_by_fid<'life0, 'async_trait>(
                        &'life0 self,
                        request: tonic::Request<super::LinksByFidRequest>,
                    ) -> ::core::pin::Pin<
                        Box<
                            dyn ::core::future::Future<
                                Output = std::result::Result<
                                    tonic::Response<super::MessagesResponse>,
                                    tonic::Status,
                                >,
                            > + ::core::marker::Send + 'async_trait,
                        >,
                    >
                    where
                        'life0: 'async_trait,
                        Self: 'async_trait;
                    #[must_use]
                    #[allow(clippy::type_complexity, clippy::type_repetition_in_bounds)]
                    fn get_links_by_target<'life0, 'async_trait>(
                        &'life0 self,
                        request: tonic::Request<super::LinksByTargetRequest>,
                    ) -> ::core::pin::Pin<
                        Box<
                            dyn ::core::future::Future<
                                Output = std::result::Result<
                                    tonic::Response<super::MessagesResponse>,
                                    tonic::Status,
                                >,
                            > + ::core::marker::Send + 'async_trait,
                        >,
                    >
                    where
                        'life0: 'async_trait,
                        Self: 'async_trait;
                    /// Bulk Methods
                    #[must_use]
                    #[allow(clippy::type_complexity, clippy::type_repetition_in_bounds)]
                    fn get_all_cast_messages_by_fid<'life0, 'async_trait>(
                        &'life0 self,
                        request: tonic::Request<super::FidRequest>,
                    ) -> ::core::pin::Pin<
                        Box<
                            dyn ::core::future::Future<
                                Output = std::result::Result<
                                    tonic::Response<super::MessagesResponse>,
                                    tonic::Status,
                                >,
                            > + ::core::marker::Send + 'async_trait,
                        >,
                    >
                    where
                        'life0: 'async_trait,
                        Self: 'async_trait;
                    #[must_use]
                    #[allow(clippy::type_complexity, clippy::type_repetition_in_bounds)]
                    fn get_all_reaction_messages_by_fid<'life0, 'async_trait>(
                        &'life0 self,
                        request: tonic::Request<super::FidRequest>,
                    ) -> ::core::pin::Pin<
                        Box<
                            dyn ::core::future::Future<
                                Output = std::result::Result<
                                    tonic::Response<super::MessagesResponse>,
                                    tonic::Status,
                                >,
                            > + ::core::marker::Send + 'async_trait,
                        >,
                    >
                    where
                        'life0: 'async_trait,
                        Self: 'async_trait;
                    #[must_use]
                    #[allow(clippy::type_complexity, clippy::type_repetition_in_bounds)]
                    fn get_all_verification_messages_by_fid<'life0, 'async_trait>(
                        &'life0 self,
                        request: tonic::Request<super::FidRequest>,
                    ) -> ::core::pin::Pin<
                        Box<
                            dyn ::core::future::Future<
                                Output = std::result::Result<
                                    tonic::Response<super::MessagesResponse>,
                                    tonic::Status,
                                >,
                            > + ::core::marker::Send + 'async_trait,
                        >,
                    >
                    where
                        'life0: 'async_trait,
                        Self: 'async_trait;
                    #[must_use]
                    #[allow(clippy::type_complexity, clippy::type_repetition_in_bounds)]
                    fn get_all_signer_messages_by_fid<'life0, 'async_trait>(
                        &'life0 self,
                        request: tonic::Request<super::FidRequest>,
                    ) -> ::core::pin::Pin<
                        Box<
                            dyn ::core::future::Future<
                                Output = std::result::Result<
                                    tonic::Response<super::MessagesResponse>,
                                    tonic::Status,
                                >,
                            > + ::core::marker::Send + 'async_trait,
                        >,
                    >
                    where
                        'life0: 'async_trait,
                        Self: 'async_trait;
                    #[must_use]
                    #[allow(clippy::type_complexity, clippy::type_repetition_in_bounds)]
                    fn get_all_user_data_messages_by_fid<'life0, 'async_trait>(
                        &'life0 self,
                        request: tonic::Request<super::FidRequest>,
                    ) -> ::core::pin::Pin<
                        Box<
                            dyn ::core::future::Future<
                                Output = std::result::Result<
                                    tonic::Response<super::MessagesResponse>,
                                    tonic::Status,
                                >,
                            > + ::core::marker::Send + 'async_trait,
                        >,
                    >
                    where
                        'life0: 'async_trait,
                        Self: 'async_trait;
                    #[must_use]
                    #[allow(clippy::type_complexity, clippy::type_repetition_in_bounds)]
                    fn get_all_link_messages_by_fid<'life0, 'async_trait>(
                        &'life0 self,
                        request: tonic::Request<super::FidRequest>,
                    ) -> ::core::pin::Pin<
                        Box<
                            dyn ::core::future::Future<
                                Output = std::result::Result<
                                    tonic::Response<super::MessagesResponse>,
                                    tonic::Status,
                                >,
                            > + ::core::marker::Send + 'async_trait,
                        >,
                    >
                    where
                        'life0: 'async_trait,
                        Self: 'async_trait;
                    /// Sync Methods
                    #[must_use]
                    #[allow(clippy::type_complexity, clippy::type_repetition_in_bounds)]
                    fn get_info<'life0, 'async_trait>(
                        &'life0 self,
                        request: tonic::Request<super::HubInfoRequest>,
                    ) -> ::core::pin::Pin<
                        Box<
                            dyn ::core::future::Future<
                                Output = std::result::Result<
                                    tonic::Response<super::HubInfoResponse>,
                                    tonic::Status,
                                >,
                            > + ::core::marker::Send + 'async_trait,
                        >,
                    >
                    where
                        'life0: 'async_trait,
                        Self: 'async_trait;
                    #[must_use]
                    #[allow(clippy::type_complexity, clippy::type_repetition_in_bounds)]
                    fn get_sync_status<'life0, 'async_trait>(
                        &'life0 self,
                        request: tonic::Request<super::SyncStatusRequest>,
                    ) -> ::core::pin::Pin<
                        Box<
                            dyn ::core::future::Future<
                                Output = std::result::Result<
                                    tonic::Response<super::SyncStatusResponse>,
                                    tonic::Status,
                                >,
                            > + ::core::marker::Send + 'async_trait,
                        >,
                    >
                    where
                        'life0: 'async_trait,
                        Self: 'async_trait;
                    #[must_use]
                    #[allow(clippy::type_complexity, clippy::type_repetition_in_bounds)]
                    fn get_all_sync_ids_by_prefix<'life0, 'async_trait>(
                        &'life0 self,
                        request: tonic::Request<super::TrieNodePrefix>,
                    ) -> ::core::pin::Pin<
                        Box<
                            dyn ::core::future::Future<
                                Output = std::result::Result<
                                    tonic::Response<super::SyncIds>,
                                    tonic::Status,
                                >,
                            > + ::core::marker::Send + 'async_trait,
                        >,
                    >
                    where
                        'life0: 'async_trait,
                        Self: 'async_trait;
                    #[must_use]
                    #[allow(clippy::type_complexity, clippy::type_repetition_in_bounds)]
                    fn get_all_messages_by_sync_ids<'life0, 'async_trait>(
                        &'life0 self,
                        request: tonic::Request<super::SyncIds>,
                    ) -> ::core::pin::Pin<
                        Box<
                            dyn ::core::future::Future<
                                Output = std::result::Result<
                                    tonic::Response<super::MessagesResponse>,
                                    tonic::Status,
                                >,
                            > + ::core::marker::Send + 'async_trait,
                        >,
                    >
                    where
                        'life0: 'async_trait,
                        Self: 'async_trait;
                    #[must_use]
                    #[allow(clippy::type_complexity, clippy::type_repetition_in_bounds)]
                    fn get_sync_metadata_by_prefix<'life0, 'async_trait>(
                        &'life0 self,
                        request: tonic::Request<super::TrieNodePrefix>,
                    ) -> ::core::pin::Pin<
                        Box<
                            dyn ::core::future::Future<
                                Output = std::result::Result<
                                    tonic::Response<super::TrieNodeMetadataResponse>,
                                    tonic::Status,
                                >,
                            > + ::core::marker::Send + 'async_trait,
                        >,
                    >
                    where
                        'life0: 'async_trait,
                        Self: 'async_trait;
                    #[must_use]
                    #[allow(clippy::type_complexity, clippy::type_repetition_in_bounds)]
                    fn get_sync_snapshot_by_prefix<'life0, 'async_trait>(
                        &'life0 self,
                        request: tonic::Request<super::TrieNodePrefix>,
                    ) -> ::core::pin::Pin<
                        Box<
                            dyn ::core::future::Future<
                                Output = std::result::Result<
                                    tonic::Response<super::TrieNodeSnapshotResponse>,
                                    tonic::Status,
                                >,
                            > + ::core::marker::Send + 'async_trait,
                        >,
                    >
                    where
                        'life0: 'async_trait,
                        Self: 'async_trait;
                }
                pub struct HubServiceServer<T: HubService> {
                    inner: _Inner<T>,
                    accept_compression_encodings: EnabledCompressionEncodings,
                    send_compression_encodings: EnabledCompressionEncodings,
                    max_decoding_message_size: Option<usize>,
                    max_encoding_message_size: Option<usize>,
                }
                #[automatically_derived]
                impl<T: ::core::fmt::Debug + HubService> ::core::fmt::Debug
                for HubServiceServer<T> {
                    fn fmt(
                        &self,
                        f: &mut ::core::fmt::Formatter,
                    ) -> ::core::fmt::Result {
                        ::core::fmt::Formatter::debug_struct_field5_finish(
                            f,
                            "HubServiceServer",
                            "inner",
                            &self.inner,
                            "accept_compression_encodings",
                            &self.accept_compression_encodings,
                            "send_compression_encodings",
                            &self.send_compression_encodings,
                            "max_decoding_message_size",
                            &self.max_decoding_message_size,
                            "max_encoding_message_size",
                            &&self.max_encoding_message_size,
                        )
                    }
                }
                struct _Inner<T>(Arc<T>);
                impl<T: HubService> HubServiceServer<T> {
                    pub fn new(inner: T) -> Self {
                        Self::from_arc(Arc::new(inner))
                    }
                    pub fn from_arc(inner: Arc<T>) -> Self {
                        let inner = _Inner(inner);
                        Self {
                            inner,
                            accept_compression_encodings: Default::default(),
                            send_compression_encodings: Default::default(),
                            max_decoding_message_size: None,
                            max_encoding_message_size: None,
                        }
                    }
                    pub fn with_interceptor<F>(
                        inner: T,
                        interceptor: F,
                    ) -> InterceptedService<Self, F>
                    where
                        F: tonic::service::Interceptor,
                    {
                        InterceptedService::new(Self::new(inner), interceptor)
                    }
                    /// Enable decompressing requests with the given encoding.
                    #[must_use]
                    pub fn accept_compressed(
                        mut self,
                        encoding: CompressionEncoding,
                    ) -> Self {
                        self.accept_compression_encodings.enable(encoding);
                        self
                    }
                    /// Compress responses with the given encoding, if the client supports it.
                    #[must_use]
                    pub fn send_compressed(
                        mut self,
                        encoding: CompressionEncoding,
                    ) -> Self {
                        self.send_compression_encodings.enable(encoding);
                        self
                    }
                    /// Limits the maximum size of a decoded message.
                    ///
                    /// Default: `4MB`
                    #[must_use]
                    pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
                        self.max_decoding_message_size = Some(limit);
                        self
                    }
                    /// Limits the maximum size of an encoded message.
                    ///
                    /// Default: `usize::MAX`
                    #[must_use]
                    pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
                        self.max_encoding_message_size = Some(limit);
                        self
                    }
                }
                impl<T, B> tonic::codegen::Service<http::Request<B>>
                for HubServiceServer<T>
                where
                    T: HubService,
                    B: Body + Send + 'static,
                    B::Error: Into<StdError> + Send + 'static,
                {
                    type Response = http::Response<tonic::body::BoxBody>;
                    type Error = std::convert::Infallible;
                    type Future = BoxFuture<Self::Response, Self::Error>;
                    fn poll_ready(
                        &mut self,
                        _cx: &mut Context<'_>,
                    ) -> Poll<std::result::Result<(), Self::Error>> {
                        Poll::Ready(Ok(()))
                    }
                    fn call(&mut self, req: http::Request<B>) -> Self::Future {
                        let inner = self.inner.clone();
                        match req.uri().path() {
                            "/HubService/SubmitMessage" => {
                                #[allow(non_camel_case_types)]
                                struct SubmitMessageSvc<T: HubService>(pub Arc<T>);
                                impl<
                                    T: HubService,
                                > tonic::server::UnaryService<super::Message>
                                for SubmitMessageSvc<T> {
                                    type Response = super::Message;
                                    type Future = BoxFuture<
                                        tonic::Response<Self::Response>,
                                        tonic::Status,
                                    >;
                                    fn call(
                                        &mut self,
                                        request: tonic::Request<super::Message>,
                                    ) -> Self::Future {
                                        let inner = Arc::clone(&self.0);
                                        let fut = async move {
                                            (*inner).submit_message(request).await
                                        };
                                        Box::pin(fut)
                                    }
                                }
                                let accept_compression_encodings = self
                                    .accept_compression_encodings;
                                let send_compression_encodings = self
                                    .send_compression_encodings;
                                let max_decoding_message_size = self
                                    .max_decoding_message_size;
                                let max_encoding_message_size = self
                                    .max_encoding_message_size;
                                let inner = self.inner.clone();
                                let fut = async move {
                                    let inner = inner.0;
                                    let method = SubmitMessageSvc(inner);
                                    let codec = tonic::codec::ProstCodec::default();
                                    let mut grpc = tonic::server::Grpc::new(codec)
                                        .apply_compression_config(
                                            accept_compression_encodings,
                                            send_compression_encodings,
                                        )
                                        .apply_max_message_size_config(
                                            max_decoding_message_size,
                                            max_encoding_message_size,
                                        );
                                    let res = grpc.unary(method, req).await;
                                    Ok(res)
                                };
                                Box::pin(fut)
                            }
                            "/HubService/Subscribe" => {
                                #[allow(non_camel_case_types)]
                                struct SubscribeSvc<T: HubService>(pub Arc<T>);
                                impl<
                                    T: HubService,
                                > tonic::server::ServerStreamingService<
                                    super::SubscribeRequest,
                                > for SubscribeSvc<T> {
                                    type Response = super::HubEvent;
                                    type ResponseStream = T::SubscribeStream;
                                    type Future = BoxFuture<
                                        tonic::Response<Self::ResponseStream>,
                                        tonic::Status,
                                    >;
                                    fn call(
                                        &mut self,
                                        request: tonic::Request<super::SubscribeRequest>,
                                    ) -> Self::Future {
                                        let inner = Arc::clone(&self.0);
                                        let fut = async move { (*inner).subscribe(request).await };
                                        Box::pin(fut)
                                    }
                                }
                                let accept_compression_encodings = self
                                    .accept_compression_encodings;
                                let send_compression_encodings = self
                                    .send_compression_encodings;
                                let max_decoding_message_size = self
                                    .max_decoding_message_size;
                                let max_encoding_message_size = self
                                    .max_encoding_message_size;
                                let inner = self.inner.clone();
                                let fut = async move {
                                    let inner = inner.0;
                                    let method = SubscribeSvc(inner);
                                    let codec = tonic::codec::ProstCodec::default();
                                    let mut grpc = tonic::server::Grpc::new(codec)
                                        .apply_compression_config(
                                            accept_compression_encodings,
                                            send_compression_encodings,
                                        )
                                        .apply_max_message_size_config(
                                            max_decoding_message_size,
                                            max_encoding_message_size,
                                        );
                                    let res = grpc.server_streaming(method, req).await;
                                    Ok(res)
                                };
                                Box::pin(fut)
                            }
                            "/HubService/GetEvent" => {
                                #[allow(non_camel_case_types)]
                                struct GetEventSvc<T: HubService>(pub Arc<T>);
                                impl<
                                    T: HubService,
                                > tonic::server::UnaryService<super::EventRequest>
                                for GetEventSvc<T> {
                                    type Response = super::HubEvent;
                                    type Future = BoxFuture<
                                        tonic::Response<Self::Response>,
                                        tonic::Status,
                                    >;
                                    fn call(
                                        &mut self,
                                        request: tonic::Request<super::EventRequest>,
                                    ) -> Self::Future {
                                        let inner = Arc::clone(&self.0);
                                        let fut = async move { (*inner).get_event(request).await };
                                        Box::pin(fut)
                                    }
                                }
                                let accept_compression_encodings = self
                                    .accept_compression_encodings;
                                let send_compression_encodings = self
                                    .send_compression_encodings;
                                let max_decoding_message_size = self
                                    .max_decoding_message_size;
                                let max_encoding_message_size = self
                                    .max_encoding_message_size;
                                let inner = self.inner.clone();
                                let fut = async move {
                                    let inner = inner.0;
                                    let method = GetEventSvc(inner);
                                    let codec = tonic::codec::ProstCodec::default();
                                    let mut grpc = tonic::server::Grpc::new(codec)
                                        .apply_compression_config(
                                            accept_compression_encodings,
                                            send_compression_encodings,
                                        )
                                        .apply_max_message_size_config(
                                            max_decoding_message_size,
                                            max_encoding_message_size,
                                        );
                                    let res = grpc.unary(method, req).await;
                                    Ok(res)
                                };
                                Box::pin(fut)
                            }
                            "/HubService/GetCast" => {
                                #[allow(non_camel_case_types)]
                                struct GetCastSvc<T: HubService>(pub Arc<T>);
                                impl<
                                    T: HubService,
                                > tonic::server::UnaryService<super::CastId>
                                for GetCastSvc<T> {
                                    type Response = super::Message;
                                    type Future = BoxFuture<
                                        tonic::Response<Self::Response>,
                                        tonic::Status,
                                    >;
                                    fn call(
                                        &mut self,
                                        request: tonic::Request<super::CastId>,
                                    ) -> Self::Future {
                                        let inner = Arc::clone(&self.0);
                                        let fut = async move { (*inner).get_cast(request).await };
                                        Box::pin(fut)
                                    }
                                }
                                let accept_compression_encodings = self
                                    .accept_compression_encodings;
                                let send_compression_encodings = self
                                    .send_compression_encodings;
                                let max_decoding_message_size = self
                                    .max_decoding_message_size;
                                let max_encoding_message_size = self
                                    .max_encoding_message_size;
                                let inner = self.inner.clone();
                                let fut = async move {
                                    let inner = inner.0;
                                    let method = GetCastSvc(inner);
                                    let codec = tonic::codec::ProstCodec::default();
                                    let mut grpc = tonic::server::Grpc::new(codec)
                                        .apply_compression_config(
                                            accept_compression_encodings,
                                            send_compression_encodings,
                                        )
                                        .apply_max_message_size_config(
                                            max_decoding_message_size,
                                            max_encoding_message_size,
                                        );
                                    let res = grpc.unary(method, req).await;
                                    Ok(res)
                                };
                                Box::pin(fut)
                            }
                            "/HubService/GetCastsByFid" => {
                                #[allow(non_camel_case_types)]
                                struct GetCastsByFidSvc<T: HubService>(pub Arc<T>);
                                impl<
                                    T: HubService,
                                > tonic::server::UnaryService<super::FidRequest>
                                for GetCastsByFidSvc<T> {
                                    type Response = super::MessagesResponse;
                                    type Future = BoxFuture<
                                        tonic::Response<Self::Response>,
                                        tonic::Status,
                                    >;
                                    fn call(
                                        &mut self,
                                        request: tonic::Request<super::FidRequest>,
                                    ) -> Self::Future {
                                        let inner = Arc::clone(&self.0);
                                        let fut = async move {
                                            (*inner).get_casts_by_fid(request).await
                                        };
                                        Box::pin(fut)
                                    }
                                }
                                let accept_compression_encodings = self
                                    .accept_compression_encodings;
                                let send_compression_encodings = self
                                    .send_compression_encodings;
                                let max_decoding_message_size = self
                                    .max_decoding_message_size;
                                let max_encoding_message_size = self
                                    .max_encoding_message_size;
                                let inner = self.inner.clone();
                                let fut = async move {
                                    let inner = inner.0;
                                    let method = GetCastsByFidSvc(inner);
                                    let codec = tonic::codec::ProstCodec::default();
                                    let mut grpc = tonic::server::Grpc::new(codec)
                                        .apply_compression_config(
                                            accept_compression_encodings,
                                            send_compression_encodings,
                                        )
                                        .apply_max_message_size_config(
                                            max_decoding_message_size,
                                            max_encoding_message_size,
                                        );
                                    let res = grpc.unary(method, req).await;
                                    Ok(res)
                                };
                                Box::pin(fut)
                            }
                            "/HubService/GetCastsByParent" => {
                                #[allow(non_camel_case_types)]
                                struct GetCastsByParentSvc<T: HubService>(pub Arc<T>);
                                impl<
                                    T: HubService,
                                > tonic::server::UnaryService<super::CastsByParentRequest>
                                for GetCastsByParentSvc<T> {
                                    type Response = super::MessagesResponse;
                                    type Future = BoxFuture<
                                        tonic::Response<Self::Response>,
                                        tonic::Status,
                                    >;
                                    fn call(
                                        &mut self,
                                        request: tonic::Request<super::CastsByParentRequest>,
                                    ) -> Self::Future {
                                        let inner = Arc::clone(&self.0);
                                        let fut = async move {
                                            (*inner).get_casts_by_parent(request).await
                                        };
                                        Box::pin(fut)
                                    }
                                }
                                let accept_compression_encodings = self
                                    .accept_compression_encodings;
                                let send_compression_encodings = self
                                    .send_compression_encodings;
                                let max_decoding_message_size = self
                                    .max_decoding_message_size;
                                let max_encoding_message_size = self
                                    .max_encoding_message_size;
                                let inner = self.inner.clone();
                                let fut = async move {
                                    let inner = inner.0;
                                    let method = GetCastsByParentSvc(inner);
                                    let codec = tonic::codec::ProstCodec::default();
                                    let mut grpc = tonic::server::Grpc::new(codec)
                                        .apply_compression_config(
                                            accept_compression_encodings,
                                            send_compression_encodings,
                                        )
                                        .apply_max_message_size_config(
                                            max_decoding_message_size,
                                            max_encoding_message_size,
                                        );
                                    let res = grpc.unary(method, req).await;
                                    Ok(res)
                                };
                                Box::pin(fut)
                            }
                            "/HubService/GetCastsByMention" => {
                                #[allow(non_camel_case_types)]
                                struct GetCastsByMentionSvc<T: HubService>(pub Arc<T>);
                                impl<
                                    T: HubService,
                                > tonic::server::UnaryService<super::FidRequest>
                                for GetCastsByMentionSvc<T> {
                                    type Response = super::MessagesResponse;
                                    type Future = BoxFuture<
                                        tonic::Response<Self::Response>,
                                        tonic::Status,
                                    >;
                                    fn call(
                                        &mut self,
                                        request: tonic::Request<super::FidRequest>,
                                    ) -> Self::Future {
                                        let inner = Arc::clone(&self.0);
                                        let fut = async move {
                                            (*inner).get_casts_by_mention(request).await
                                        };
                                        Box::pin(fut)
                                    }
                                }
                                let accept_compression_encodings = self
                                    .accept_compression_encodings;
                                let send_compression_encodings = self
                                    .send_compression_encodings;
                                let max_decoding_message_size = self
                                    .max_decoding_message_size;
                                let max_encoding_message_size = self
                                    .max_encoding_message_size;
                                let inner = self.inner.clone();
                                let fut = async move {
                                    let inner = inner.0;
                                    let method = GetCastsByMentionSvc(inner);
                                    let codec = tonic::codec::ProstCodec::default();
                                    let mut grpc = tonic::server::Grpc::new(codec)
                                        .apply_compression_config(
                                            accept_compression_encodings,
                                            send_compression_encodings,
                                        )
                                        .apply_max_message_size_config(
                                            max_decoding_message_size,
                                            max_encoding_message_size,
                                        );
                                    let res = grpc.unary(method, req).await;
                                    Ok(res)
                                };
                                Box::pin(fut)
                            }
                            "/HubService/GetReaction" => {
                                #[allow(non_camel_case_types)]
                                struct GetReactionSvc<T: HubService>(pub Arc<T>);
                                impl<
                                    T: HubService,
                                > tonic::server::UnaryService<super::ReactionRequest>
                                for GetReactionSvc<T> {
                                    type Response = super::Message;
                                    type Future = BoxFuture<
                                        tonic::Response<Self::Response>,
                                        tonic::Status,
                                    >;
                                    fn call(
                                        &mut self,
                                        request: tonic::Request<super::ReactionRequest>,
                                    ) -> Self::Future {
                                        let inner = Arc::clone(&self.0);
                                        let fut = async move {
                                            (*inner).get_reaction(request).await
                                        };
                                        Box::pin(fut)
                                    }
                                }
                                let accept_compression_encodings = self
                                    .accept_compression_encodings;
                                let send_compression_encodings = self
                                    .send_compression_encodings;
                                let max_decoding_message_size = self
                                    .max_decoding_message_size;
                                let max_encoding_message_size = self
                                    .max_encoding_message_size;
                                let inner = self.inner.clone();
                                let fut = async move {
                                    let inner = inner.0;
                                    let method = GetReactionSvc(inner);
                                    let codec = tonic::codec::ProstCodec::default();
                                    let mut grpc = tonic::server::Grpc::new(codec)
                                        .apply_compression_config(
                                            accept_compression_encodings,
                                            send_compression_encodings,
                                        )
                                        .apply_max_message_size_config(
                                            max_decoding_message_size,
                                            max_encoding_message_size,
                                        );
                                    let res = grpc.unary(method, req).await;
                                    Ok(res)
                                };
                                Box::pin(fut)
                            }
                            "/HubService/GetReactionsByFid" => {
                                #[allow(non_camel_case_types)]
                                struct GetReactionsByFidSvc<T: HubService>(pub Arc<T>);
                                impl<
                                    T: HubService,
                                > tonic::server::UnaryService<super::ReactionsByFidRequest>
                                for GetReactionsByFidSvc<T> {
                                    type Response = super::MessagesResponse;
                                    type Future = BoxFuture<
                                        tonic::Response<Self::Response>,
                                        tonic::Status,
                                    >;
                                    fn call(
                                        &mut self,
                                        request: tonic::Request<super::ReactionsByFidRequest>,
                                    ) -> Self::Future {
                                        let inner = Arc::clone(&self.0);
                                        let fut = async move {
                                            (*inner).get_reactions_by_fid(request).await
                                        };
                                        Box::pin(fut)
                                    }
                                }
                                let accept_compression_encodings = self
                                    .accept_compression_encodings;
                                let send_compression_encodings = self
                                    .send_compression_encodings;
                                let max_decoding_message_size = self
                                    .max_decoding_message_size;
                                let max_encoding_message_size = self
                                    .max_encoding_message_size;
                                let inner = self.inner.clone();
                                let fut = async move {
                                    let inner = inner.0;
                                    let method = GetReactionsByFidSvc(inner);
                                    let codec = tonic::codec::ProstCodec::default();
                                    let mut grpc = tonic::server::Grpc::new(codec)
                                        .apply_compression_config(
                                            accept_compression_encodings,
                                            send_compression_encodings,
                                        )
                                        .apply_max_message_size_config(
                                            max_decoding_message_size,
                                            max_encoding_message_size,
                                        );
                                    let res = grpc.unary(method, req).await;
                                    Ok(res)
                                };
                                Box::pin(fut)
                            }
                            "/HubService/GetReactionsByCast" => {
                                #[allow(non_camel_case_types)]
                                struct GetReactionsByCastSvc<T: HubService>(pub Arc<T>);
                                impl<
                                    T: HubService,
                                > tonic::server::UnaryService<
                                    super::ReactionsByTargetRequest,
                                > for GetReactionsByCastSvc<T> {
                                    type Response = super::MessagesResponse;
                                    type Future = BoxFuture<
                                        tonic::Response<Self::Response>,
                                        tonic::Status,
                                    >;
                                    fn call(
                                        &mut self,
                                        request: tonic::Request<super::ReactionsByTargetRequest>,
                                    ) -> Self::Future {
                                        let inner = Arc::clone(&self.0);
                                        let fut = async move {
                                            (*inner).get_reactions_by_cast(request).await
                                        };
                                        Box::pin(fut)
                                    }
                                }
                                let accept_compression_encodings = self
                                    .accept_compression_encodings;
                                let send_compression_encodings = self
                                    .send_compression_encodings;
                                let max_decoding_message_size = self
                                    .max_decoding_message_size;
                                let max_encoding_message_size = self
                                    .max_encoding_message_size;
                                let inner = self.inner.clone();
                                let fut = async move {
                                    let inner = inner.0;
                                    let method = GetReactionsByCastSvc(inner);
                                    let codec = tonic::codec::ProstCodec::default();
                                    let mut grpc = tonic::server::Grpc::new(codec)
                                        .apply_compression_config(
                                            accept_compression_encodings,
                                            send_compression_encodings,
                                        )
                                        .apply_max_message_size_config(
                                            max_decoding_message_size,
                                            max_encoding_message_size,
                                        );
                                    let res = grpc.unary(method, req).await;
                                    Ok(res)
                                };
                                Box::pin(fut)
                            }
                            "/HubService/GetReactionsByTarget" => {
                                #[allow(non_camel_case_types)]
                                struct GetReactionsByTargetSvc<T: HubService>(pub Arc<T>);
                                impl<
                                    T: HubService,
                                > tonic::server::UnaryService<
                                    super::ReactionsByTargetRequest,
                                > for GetReactionsByTargetSvc<T> {
                                    type Response = super::MessagesResponse;
                                    type Future = BoxFuture<
                                        tonic::Response<Self::Response>,
                                        tonic::Status,
                                    >;
                                    fn call(
                                        &mut self,
                                        request: tonic::Request<super::ReactionsByTargetRequest>,
                                    ) -> Self::Future {
                                        let inner = Arc::clone(&self.0);
                                        let fut = async move {
                                            (*inner).get_reactions_by_target(request).await
                                        };
                                        Box::pin(fut)
                                    }
                                }
                                let accept_compression_encodings = self
                                    .accept_compression_encodings;
                                let send_compression_encodings = self
                                    .send_compression_encodings;
                                let max_decoding_message_size = self
                                    .max_decoding_message_size;
                                let max_encoding_message_size = self
                                    .max_encoding_message_size;
                                let inner = self.inner.clone();
                                let fut = async move {
                                    let inner = inner.0;
                                    let method = GetReactionsByTargetSvc(inner);
                                    let codec = tonic::codec::ProstCodec::default();
                                    let mut grpc = tonic::server::Grpc::new(codec)
                                        .apply_compression_config(
                                            accept_compression_encodings,
                                            send_compression_encodings,
                                        )
                                        .apply_max_message_size_config(
                                            max_decoding_message_size,
                                            max_encoding_message_size,
                                        );
                                    let res = grpc.unary(method, req).await;
                                    Ok(res)
                                };
                                Box::pin(fut)
                            }
                            "/HubService/GetUserData" => {
                                #[allow(non_camel_case_types)]
                                struct GetUserDataSvc<T: HubService>(pub Arc<T>);
                                impl<
                                    T: HubService,
                                > tonic::server::UnaryService<super::UserDataRequest>
                                for GetUserDataSvc<T> {
                                    type Response = super::Message;
                                    type Future = BoxFuture<
                                        tonic::Response<Self::Response>,
                                        tonic::Status,
                                    >;
                                    fn call(
                                        &mut self,
                                        request: tonic::Request<super::UserDataRequest>,
                                    ) -> Self::Future {
                                        let inner = Arc::clone(&self.0);
                                        let fut = async move {
                                            (*inner).get_user_data(request).await
                                        };
                                        Box::pin(fut)
                                    }
                                }
                                let accept_compression_encodings = self
                                    .accept_compression_encodings;
                                let send_compression_encodings = self
                                    .send_compression_encodings;
                                let max_decoding_message_size = self
                                    .max_decoding_message_size;
                                let max_encoding_message_size = self
                                    .max_encoding_message_size;
                                let inner = self.inner.clone();
                                let fut = async move {
                                    let inner = inner.0;
                                    let method = GetUserDataSvc(inner);
                                    let codec = tonic::codec::ProstCodec::default();
                                    let mut grpc = tonic::server::Grpc::new(codec)
                                        .apply_compression_config(
                                            accept_compression_encodings,
                                            send_compression_encodings,
                                        )
                                        .apply_max_message_size_config(
                                            max_decoding_message_size,
                                            max_encoding_message_size,
                                        );
                                    let res = grpc.unary(method, req).await;
                                    Ok(res)
                                };
                                Box::pin(fut)
                            }
                            "/HubService/GetUserDataByFid" => {
                                #[allow(non_camel_case_types)]
                                struct GetUserDataByFidSvc<T: HubService>(pub Arc<T>);
                                impl<
                                    T: HubService,
                                > tonic::server::UnaryService<super::FidRequest>
                                for GetUserDataByFidSvc<T> {
                                    type Response = super::MessagesResponse;
                                    type Future = BoxFuture<
                                        tonic::Response<Self::Response>,
                                        tonic::Status,
                                    >;
                                    fn call(
                                        &mut self,
                                        request: tonic::Request<super::FidRequest>,
                                    ) -> Self::Future {
                                        let inner = Arc::clone(&self.0);
                                        let fut = async move {
                                            (*inner).get_user_data_by_fid(request).await
                                        };
                                        Box::pin(fut)
                                    }
                                }
                                let accept_compression_encodings = self
                                    .accept_compression_encodings;
                                let send_compression_encodings = self
                                    .send_compression_encodings;
                                let max_decoding_message_size = self
                                    .max_decoding_message_size;
                                let max_encoding_message_size = self
                                    .max_encoding_message_size;
                                let inner = self.inner.clone();
                                let fut = async move {
                                    let inner = inner.0;
                                    let method = GetUserDataByFidSvc(inner);
                                    let codec = tonic::codec::ProstCodec::default();
                                    let mut grpc = tonic::server::Grpc::new(codec)
                                        .apply_compression_config(
                                            accept_compression_encodings,
                                            send_compression_encodings,
                                        )
                                        .apply_max_message_size_config(
                                            max_decoding_message_size,
                                            max_encoding_message_size,
                                        );
                                    let res = grpc.unary(method, req).await;
                                    Ok(res)
                                };
                                Box::pin(fut)
                            }
                            "/HubService/GetNameRegistryEvent" => {
                                #[allow(non_camel_case_types)]
                                struct GetNameRegistryEventSvc<T: HubService>(pub Arc<T>);
                                impl<
                                    T: HubService,
                                > tonic::server::UnaryService<
                                    super::NameRegistryEventRequest,
                                > for GetNameRegistryEventSvc<T> {
                                    type Response = super::NameRegistryEvent;
                                    type Future = BoxFuture<
                                        tonic::Response<Self::Response>,
                                        tonic::Status,
                                    >;
                                    fn call(
                                        &mut self,
                                        request: tonic::Request<super::NameRegistryEventRequest>,
                                    ) -> Self::Future {
                                        let inner = Arc::clone(&self.0);
                                        let fut = async move {
                                            (*inner).get_name_registry_event(request).await
                                        };
                                        Box::pin(fut)
                                    }
                                }
                                let accept_compression_encodings = self
                                    .accept_compression_encodings;
                                let send_compression_encodings = self
                                    .send_compression_encodings;
                                let max_decoding_message_size = self
                                    .max_decoding_message_size;
                                let max_encoding_message_size = self
                                    .max_encoding_message_size;
                                let inner = self.inner.clone();
                                let fut = async move {
                                    let inner = inner.0;
                                    let method = GetNameRegistryEventSvc(inner);
                                    let codec = tonic::codec::ProstCodec::default();
                                    let mut grpc = tonic::server::Grpc::new(codec)
                                        .apply_compression_config(
                                            accept_compression_encodings,
                                            send_compression_encodings,
                                        )
                                        .apply_max_message_size_config(
                                            max_decoding_message_size,
                                            max_encoding_message_size,
                                        );
                                    let res = grpc.unary(method, req).await;
                                    Ok(res)
                                };
                                Box::pin(fut)
                            }
                            "/HubService/GetOnChainEvents" => {
                                #[allow(non_camel_case_types)]
                                struct GetOnChainEventsSvc<T: HubService>(pub Arc<T>);
                                impl<
                                    T: HubService,
                                > tonic::server::UnaryService<super::OnChainEventRequest>
                                for GetOnChainEventsSvc<T> {
                                    type Response = super::OnChainEventResponse;
                                    type Future = BoxFuture<
                                        tonic::Response<Self::Response>,
                                        tonic::Status,
                                    >;
                                    fn call(
                                        &mut self,
                                        request: tonic::Request<super::OnChainEventRequest>,
                                    ) -> Self::Future {
                                        let inner = Arc::clone(&self.0);
                                        let fut = async move {
                                            (*inner).get_on_chain_events(request).await
                                        };
                                        Box::pin(fut)
                                    }
                                }
                                let accept_compression_encodings = self
                                    .accept_compression_encodings;
                                let send_compression_encodings = self
                                    .send_compression_encodings;
                                let max_decoding_message_size = self
                                    .max_decoding_message_size;
                                let max_encoding_message_size = self
                                    .max_encoding_message_size;
                                let inner = self.inner.clone();
                                let fut = async move {
                                    let inner = inner.0;
                                    let method = GetOnChainEventsSvc(inner);
                                    let codec = tonic::codec::ProstCodec::default();
                                    let mut grpc = tonic::server::Grpc::new(codec)
                                        .apply_compression_config(
                                            accept_compression_encodings,
                                            send_compression_encodings,
                                        )
                                        .apply_max_message_size_config(
                                            max_decoding_message_size,
                                            max_encoding_message_size,
                                        );
                                    let res = grpc.unary(method, req).await;
                                    Ok(res)
                                };
                                Box::pin(fut)
                            }
                            "/HubService/GetCurrentStorageLimitsByFid" => {
                                #[allow(non_camel_case_types)]
                                struct GetCurrentStorageLimitsByFidSvc<T: HubService>(
                                    pub Arc<T>,
                                );
                                impl<
                                    T: HubService,
                                > tonic::server::UnaryService<super::FidRequest>
                                for GetCurrentStorageLimitsByFidSvc<T> {
                                    type Response = super::StorageLimitsResponse;
                                    type Future = BoxFuture<
                                        tonic::Response<Self::Response>,
                                        tonic::Status,
                                    >;
                                    fn call(
                                        &mut self,
                                        request: tonic::Request<super::FidRequest>,
                                    ) -> Self::Future {
                                        let inner = Arc::clone(&self.0);
                                        let fut = async move {
                                            (*inner).get_current_storage_limits_by_fid(request).await
                                        };
                                        Box::pin(fut)
                                    }
                                }
                                let accept_compression_encodings = self
                                    .accept_compression_encodings;
                                let send_compression_encodings = self
                                    .send_compression_encodings;
                                let max_decoding_message_size = self
                                    .max_decoding_message_size;
                                let max_encoding_message_size = self
                                    .max_encoding_message_size;
                                let inner = self.inner.clone();
                                let fut = async move {
                                    let inner = inner.0;
                                    let method = GetCurrentStorageLimitsByFidSvc(inner);
                                    let codec = tonic::codec::ProstCodec::default();
                                    let mut grpc = tonic::server::Grpc::new(codec)
                                        .apply_compression_config(
                                            accept_compression_encodings,
                                            send_compression_encodings,
                                        )
                                        .apply_max_message_size_config(
                                            max_decoding_message_size,
                                            max_encoding_message_size,
                                        );
                                    let res = grpc.unary(method, req).await;
                                    Ok(res)
                                };
                                Box::pin(fut)
                            }
                            "/HubService/GetUsernameProof" => {
                                #[allow(non_camel_case_types)]
                                struct GetUsernameProofSvc<T: HubService>(pub Arc<T>);
                                impl<
                                    T: HubService,
                                > tonic::server::UnaryService<super::UsernameProofRequest>
                                for GetUsernameProofSvc<T> {
                                    type Response = super::UserNameProof;
                                    type Future = BoxFuture<
                                        tonic::Response<Self::Response>,
                                        tonic::Status,
                                    >;
                                    fn call(
                                        &mut self,
                                        request: tonic::Request<super::UsernameProofRequest>,
                                    ) -> Self::Future {
                                        let inner = Arc::clone(&self.0);
                                        let fut = async move {
                                            (*inner).get_username_proof(request).await
                                        };
                                        Box::pin(fut)
                                    }
                                }
                                let accept_compression_encodings = self
                                    .accept_compression_encodings;
                                let send_compression_encodings = self
                                    .send_compression_encodings;
                                let max_decoding_message_size = self
                                    .max_decoding_message_size;
                                let max_encoding_message_size = self
                                    .max_encoding_message_size;
                                let inner = self.inner.clone();
                                let fut = async move {
                                    let inner = inner.0;
                                    let method = GetUsernameProofSvc(inner);
                                    let codec = tonic::codec::ProstCodec::default();
                                    let mut grpc = tonic::server::Grpc::new(codec)
                                        .apply_compression_config(
                                            accept_compression_encodings,
                                            send_compression_encodings,
                                        )
                                        .apply_max_message_size_config(
                                            max_decoding_message_size,
                                            max_encoding_message_size,
                                        );
                                    let res = grpc.unary(method, req).await;
                                    Ok(res)
                                };
                                Box::pin(fut)
                            }
                            "/HubService/GetUserNameProofsByFid" => {
                                #[allow(non_camel_case_types)]
                                struct GetUserNameProofsByFidSvc<T: HubService>(pub Arc<T>);
                                impl<
                                    T: HubService,
                                > tonic::server::UnaryService<super::FidRequest>
                                for GetUserNameProofsByFidSvc<T> {
                                    type Response = super::UsernameProofsResponse;
                                    type Future = BoxFuture<
                                        tonic::Response<Self::Response>,
                                        tonic::Status,
                                    >;
                                    fn call(
                                        &mut self,
                                        request: tonic::Request<super::FidRequest>,
                                    ) -> Self::Future {
                                        let inner = Arc::clone(&self.0);
                                        let fut = async move {
                                            (*inner).get_user_name_proofs_by_fid(request).await
                                        };
                                        Box::pin(fut)
                                    }
                                }
                                let accept_compression_encodings = self
                                    .accept_compression_encodings;
                                let send_compression_encodings = self
                                    .send_compression_encodings;
                                let max_decoding_message_size = self
                                    .max_decoding_message_size;
                                let max_encoding_message_size = self
                                    .max_encoding_message_size;
                                let inner = self.inner.clone();
                                let fut = async move {
                                    let inner = inner.0;
                                    let method = GetUserNameProofsByFidSvc(inner);
                                    let codec = tonic::codec::ProstCodec::default();
                                    let mut grpc = tonic::server::Grpc::new(codec)
                                        .apply_compression_config(
                                            accept_compression_encodings,
                                            send_compression_encodings,
                                        )
                                        .apply_max_message_size_config(
                                            max_decoding_message_size,
                                            max_encoding_message_size,
                                        );
                                    let res = grpc.unary(method, req).await;
                                    Ok(res)
                                };
                                Box::pin(fut)
                            }
                            "/HubService/GetVerification" => {
                                #[allow(non_camel_case_types)]
                                struct GetVerificationSvc<T: HubService>(pub Arc<T>);
                                impl<
                                    T: HubService,
                                > tonic::server::UnaryService<super::VerificationRequest>
                                for GetVerificationSvc<T> {
                                    type Response = super::Message;
                                    type Future = BoxFuture<
                                        tonic::Response<Self::Response>,
                                        tonic::Status,
                                    >;
                                    fn call(
                                        &mut self,
                                        request: tonic::Request<super::VerificationRequest>,
                                    ) -> Self::Future {
                                        let inner = Arc::clone(&self.0);
                                        let fut = async move {
                                            (*inner).get_verification(request).await
                                        };
                                        Box::pin(fut)
                                    }
                                }
                                let accept_compression_encodings = self
                                    .accept_compression_encodings;
                                let send_compression_encodings = self
                                    .send_compression_encodings;
                                let max_decoding_message_size = self
                                    .max_decoding_message_size;
                                let max_encoding_message_size = self
                                    .max_encoding_message_size;
                                let inner = self.inner.clone();
                                let fut = async move {
                                    let inner = inner.0;
                                    let method = GetVerificationSvc(inner);
                                    let codec = tonic::codec::ProstCodec::default();
                                    let mut grpc = tonic::server::Grpc::new(codec)
                                        .apply_compression_config(
                                            accept_compression_encodings,
                                            send_compression_encodings,
                                        )
                                        .apply_max_message_size_config(
                                            max_decoding_message_size,
                                            max_encoding_message_size,
                                        );
                                    let res = grpc.unary(method, req).await;
                                    Ok(res)
                                };
                                Box::pin(fut)
                            }
                            "/HubService/GetVerificationsByFid" => {
                                #[allow(non_camel_case_types)]
                                struct GetVerificationsByFidSvc<T: HubService>(pub Arc<T>);
                                impl<
                                    T: HubService,
                                > tonic::server::UnaryService<super::FidRequest>
                                for GetVerificationsByFidSvc<T> {
                                    type Response = super::MessagesResponse;
                                    type Future = BoxFuture<
                                        tonic::Response<Self::Response>,
                                        tonic::Status,
                                    >;
                                    fn call(
                                        &mut self,
                                        request: tonic::Request<super::FidRequest>,
                                    ) -> Self::Future {
                                        let inner = Arc::clone(&self.0);
                                        let fut = async move {
                                            (*inner).get_verifications_by_fid(request).await
                                        };
                                        Box::pin(fut)
                                    }
                                }
                                let accept_compression_encodings = self
                                    .accept_compression_encodings;
                                let send_compression_encodings = self
                                    .send_compression_encodings;
                                let max_decoding_message_size = self
                                    .max_decoding_message_size;
                                let max_encoding_message_size = self
                                    .max_encoding_message_size;
                                let inner = self.inner.clone();
                                let fut = async move {
                                    let inner = inner.0;
                                    let method = GetVerificationsByFidSvc(inner);
                                    let codec = tonic::codec::ProstCodec::default();
                                    let mut grpc = tonic::server::Grpc::new(codec)
                                        .apply_compression_config(
                                            accept_compression_encodings,
                                            send_compression_encodings,
                                        )
                                        .apply_max_message_size_config(
                                            max_decoding_message_size,
                                            max_encoding_message_size,
                                        );
                                    let res = grpc.unary(method, req).await;
                                    Ok(res)
                                };
                                Box::pin(fut)
                            }
                            "/HubService/GetSigner" => {
                                #[allow(non_camel_case_types)]
                                struct GetSignerSvc<T: HubService>(pub Arc<T>);
                                impl<
                                    T: HubService,
                                > tonic::server::UnaryService<super::SignerRequest>
                                for GetSignerSvc<T> {
                                    type Response = super::Message;
                                    type Future = BoxFuture<
                                        tonic::Response<Self::Response>,
                                        tonic::Status,
                                    >;
                                    fn call(
                                        &mut self,
                                        request: tonic::Request<super::SignerRequest>,
                                    ) -> Self::Future {
                                        let inner = Arc::clone(&self.0);
                                        let fut = async move { (*inner).get_signer(request).await };
                                        Box::pin(fut)
                                    }
                                }
                                let accept_compression_encodings = self
                                    .accept_compression_encodings;
                                let send_compression_encodings = self
                                    .send_compression_encodings;
                                let max_decoding_message_size = self
                                    .max_decoding_message_size;
                                let max_encoding_message_size = self
                                    .max_encoding_message_size;
                                let inner = self.inner.clone();
                                let fut = async move {
                                    let inner = inner.0;
                                    let method = GetSignerSvc(inner);
                                    let codec = tonic::codec::ProstCodec::default();
                                    let mut grpc = tonic::server::Grpc::new(codec)
                                        .apply_compression_config(
                                            accept_compression_encodings,
                                            send_compression_encodings,
                                        )
                                        .apply_max_message_size_config(
                                            max_decoding_message_size,
                                            max_encoding_message_size,
                                        );
                                    let res = grpc.unary(method, req).await;
                                    Ok(res)
                                };
                                Box::pin(fut)
                            }
                            "/HubService/GetOnChainSigner" => {
                                #[allow(non_camel_case_types)]
                                struct GetOnChainSignerSvc<T: HubService>(pub Arc<T>);
                                impl<
                                    T: HubService,
                                > tonic::server::UnaryService<super::SignerRequest>
                                for GetOnChainSignerSvc<T> {
                                    type Response = super::OnChainEvent;
                                    type Future = BoxFuture<
                                        tonic::Response<Self::Response>,
                                        tonic::Status,
                                    >;
                                    fn call(
                                        &mut self,
                                        request: tonic::Request<super::SignerRequest>,
                                    ) -> Self::Future {
                                        let inner = Arc::clone(&self.0);
                                        let fut = async move {
                                            (*inner).get_on_chain_signer(request).await
                                        };
                                        Box::pin(fut)
                                    }
                                }
                                let accept_compression_encodings = self
                                    .accept_compression_encodings;
                                let send_compression_encodings = self
                                    .send_compression_encodings;
                                let max_decoding_message_size = self
                                    .max_decoding_message_size;
                                let max_encoding_message_size = self
                                    .max_encoding_message_size;
                                let inner = self.inner.clone();
                                let fut = async move {
                                    let inner = inner.0;
                                    let method = GetOnChainSignerSvc(inner);
                                    let codec = tonic::codec::ProstCodec::default();
                                    let mut grpc = tonic::server::Grpc::new(codec)
                                        .apply_compression_config(
                                            accept_compression_encodings,
                                            send_compression_encodings,
                                        )
                                        .apply_max_message_size_config(
                                            max_decoding_message_size,
                                            max_encoding_message_size,
                                        );
                                    let res = grpc.unary(method, req).await;
                                    Ok(res)
                                };
                                Box::pin(fut)
                            }
                            "/HubService/GetSignersByFid" => {
                                #[allow(non_camel_case_types)]
                                struct GetSignersByFidSvc<T: HubService>(pub Arc<T>);
                                impl<
                                    T: HubService,
                                > tonic::server::UnaryService<super::FidRequest>
                                for GetSignersByFidSvc<T> {
                                    type Response = super::MessagesResponse;
                                    type Future = BoxFuture<
                                        tonic::Response<Self::Response>,
                                        tonic::Status,
                                    >;
                                    fn call(
                                        &mut self,
                                        request: tonic::Request<super::FidRequest>,
                                    ) -> Self::Future {
                                        let inner = Arc::clone(&self.0);
                                        let fut = async move {
                                            (*inner).get_signers_by_fid(request).await
                                        };
                                        Box::pin(fut)
                                    }
                                }
                                let accept_compression_encodings = self
                                    .accept_compression_encodings;
                                let send_compression_encodings = self
                                    .send_compression_encodings;
                                let max_decoding_message_size = self
                                    .max_decoding_message_size;
                                let max_encoding_message_size = self
                                    .max_encoding_message_size;
                                let inner = self.inner.clone();
                                let fut = async move {
                                    let inner = inner.0;
                                    let method = GetSignersByFidSvc(inner);
                                    let codec = tonic::codec::ProstCodec::default();
                                    let mut grpc = tonic::server::Grpc::new(codec)
                                        .apply_compression_config(
                                            accept_compression_encodings,
                                            send_compression_encodings,
                                        )
                                        .apply_max_message_size_config(
                                            max_decoding_message_size,
                                            max_encoding_message_size,
                                        );
                                    let res = grpc.unary(method, req).await;
                                    Ok(res)
                                };
                                Box::pin(fut)
                            }
                            "/HubService/GetIdRegistryEvent" => {
                                #[allow(non_camel_case_types)]
                                struct GetIdRegistryEventSvc<T: HubService>(pub Arc<T>);
                                impl<
                                    T: HubService,
                                > tonic::server::UnaryService<super::IdRegistryEventRequest>
                                for GetIdRegistryEventSvc<T> {
                                    type Response = super::IdRegistryEvent;
                                    type Future = BoxFuture<
                                        tonic::Response<Self::Response>,
                                        tonic::Status,
                                    >;
                                    fn call(
                                        &mut self,
                                        request: tonic::Request<super::IdRegistryEventRequest>,
                                    ) -> Self::Future {
                                        let inner = Arc::clone(&self.0);
                                        let fut = async move {
                                            (*inner).get_id_registry_event(request).await
                                        };
                                        Box::pin(fut)
                                    }
                                }
                                let accept_compression_encodings = self
                                    .accept_compression_encodings;
                                let send_compression_encodings = self
                                    .send_compression_encodings;
                                let max_decoding_message_size = self
                                    .max_decoding_message_size;
                                let max_encoding_message_size = self
                                    .max_encoding_message_size;
                                let inner = self.inner.clone();
                                let fut = async move {
                                    let inner = inner.0;
                                    let method = GetIdRegistryEventSvc(inner);
                                    let codec = tonic::codec::ProstCodec::default();
                                    let mut grpc = tonic::server::Grpc::new(codec)
                                        .apply_compression_config(
                                            accept_compression_encodings,
                                            send_compression_encodings,
                                        )
                                        .apply_max_message_size_config(
                                            max_decoding_message_size,
                                            max_encoding_message_size,
                                        );
                                    let res = grpc.unary(method, req).await;
                                    Ok(res)
                                };
                                Box::pin(fut)
                            }
                            "/HubService/GetIdRegistryEventByAddress" => {
                                #[allow(non_camel_case_types)]
                                struct GetIdRegistryEventByAddressSvc<T: HubService>(
                                    pub Arc<T>,
                                );
                                impl<
                                    T: HubService,
                                > tonic::server::UnaryService<
                                    super::IdRegistryEventByAddressRequest,
                                > for GetIdRegistryEventByAddressSvc<T> {
                                    type Response = super::IdRegistryEvent;
                                    type Future = BoxFuture<
                                        tonic::Response<Self::Response>,
                                        tonic::Status,
                                    >;
                                    fn call(
                                        &mut self,
                                        request: tonic::Request<
                                            super::IdRegistryEventByAddressRequest,
                                        >,
                                    ) -> Self::Future {
                                        let inner = Arc::clone(&self.0);
                                        let fut = async move {
                                            (*inner).get_id_registry_event_by_address(request).await
                                        };
                                        Box::pin(fut)
                                    }
                                }
                                let accept_compression_encodings = self
                                    .accept_compression_encodings;
                                let send_compression_encodings = self
                                    .send_compression_encodings;
                                let max_decoding_message_size = self
                                    .max_decoding_message_size;
                                let max_encoding_message_size = self
                                    .max_encoding_message_size;
                                let inner = self.inner.clone();
                                let fut = async move {
                                    let inner = inner.0;
                                    let method = GetIdRegistryEventByAddressSvc(inner);
                                    let codec = tonic::codec::ProstCodec::default();
                                    let mut grpc = tonic::server::Grpc::new(codec)
                                        .apply_compression_config(
                                            accept_compression_encodings,
                                            send_compression_encodings,
                                        )
                                        .apply_max_message_size_config(
                                            max_decoding_message_size,
                                            max_encoding_message_size,
                                        );
                                    let res = grpc.unary(method, req).await;
                                    Ok(res)
                                };
                                Box::pin(fut)
                            }
                            "/HubService/GetFids" => {
                                #[allow(non_camel_case_types)]
                                struct GetFidsSvc<T: HubService>(pub Arc<T>);
                                impl<
                                    T: HubService,
                                > tonic::server::UnaryService<super::FidsRequest>
                                for GetFidsSvc<T> {
                                    type Response = super::FidsResponse;
                                    type Future = BoxFuture<
                                        tonic::Response<Self::Response>,
                                        tonic::Status,
                                    >;
                                    fn call(
                                        &mut self,
                                        request: tonic::Request<super::FidsRequest>,
                                    ) -> Self::Future {
                                        let inner = Arc::clone(&self.0);
                                        let fut = async move { (*inner).get_fids(request).await };
                                        Box::pin(fut)
                                    }
                                }
                                let accept_compression_encodings = self
                                    .accept_compression_encodings;
                                let send_compression_encodings = self
                                    .send_compression_encodings;
                                let max_decoding_message_size = self
                                    .max_decoding_message_size;
                                let max_encoding_message_size = self
                                    .max_encoding_message_size;
                                let inner = self.inner.clone();
                                let fut = async move {
                                    let inner = inner.0;
                                    let method = GetFidsSvc(inner);
                                    let codec = tonic::codec::ProstCodec::default();
                                    let mut grpc = tonic::server::Grpc::new(codec)
                                        .apply_compression_config(
                                            accept_compression_encodings,
                                            send_compression_encodings,
                                        )
                                        .apply_max_message_size_config(
                                            max_decoding_message_size,
                                            max_encoding_message_size,
                                        );
                                    let res = grpc.unary(method, req).await;
                                    Ok(res)
                                };
                                Box::pin(fut)
                            }
                            "/HubService/GetLink" => {
                                #[allow(non_camel_case_types)]
                                struct GetLinkSvc<T: HubService>(pub Arc<T>);
                                impl<
                                    T: HubService,
                                > tonic::server::UnaryService<super::LinkRequest>
                                for GetLinkSvc<T> {
                                    type Response = super::Message;
                                    type Future = BoxFuture<
                                        tonic::Response<Self::Response>,
                                        tonic::Status,
                                    >;
                                    fn call(
                                        &mut self,
                                        request: tonic::Request<super::LinkRequest>,
                                    ) -> Self::Future {
                                        let inner = Arc::clone(&self.0);
                                        let fut = async move { (*inner).get_link(request).await };
                                        Box::pin(fut)
                                    }
                                }
                                let accept_compression_encodings = self
                                    .accept_compression_encodings;
                                let send_compression_encodings = self
                                    .send_compression_encodings;
                                let max_decoding_message_size = self
                                    .max_decoding_message_size;
                                let max_encoding_message_size = self
                                    .max_encoding_message_size;
                                let inner = self.inner.clone();
                                let fut = async move {
                                    let inner = inner.0;
                                    let method = GetLinkSvc(inner);
                                    let codec = tonic::codec::ProstCodec::default();
                                    let mut grpc = tonic::server::Grpc::new(codec)
                                        .apply_compression_config(
                                            accept_compression_encodings,
                                            send_compression_encodings,
                                        )
                                        .apply_max_message_size_config(
                                            max_decoding_message_size,
                                            max_encoding_message_size,
                                        );
                                    let res = grpc.unary(method, req).await;
                                    Ok(res)
                                };
                                Box::pin(fut)
                            }
                            "/HubService/GetLinksByFid" => {
                                #[allow(non_camel_case_types)]
                                struct GetLinksByFidSvc<T: HubService>(pub Arc<T>);
                                impl<
                                    T: HubService,
                                > tonic::server::UnaryService<super::LinksByFidRequest>
                                for GetLinksByFidSvc<T> {
                                    type Response = super::MessagesResponse;
                                    type Future = BoxFuture<
                                        tonic::Response<Self::Response>,
                                        tonic::Status,
                                    >;
                                    fn call(
                                        &mut self,
                                        request: tonic::Request<super::LinksByFidRequest>,
                                    ) -> Self::Future {
                                        let inner = Arc::clone(&self.0);
                                        let fut = async move {
                                            (*inner).get_links_by_fid(request).await
                                        };
                                        Box::pin(fut)
                                    }
                                }
                                let accept_compression_encodings = self
                                    .accept_compression_encodings;
                                let send_compression_encodings = self
                                    .send_compression_encodings;
                                let max_decoding_message_size = self
                                    .max_decoding_message_size;
                                let max_encoding_message_size = self
                                    .max_encoding_message_size;
                                let inner = self.inner.clone();
                                let fut = async move {
                                    let inner = inner.0;
                                    let method = GetLinksByFidSvc(inner);
                                    let codec = tonic::codec::ProstCodec::default();
                                    let mut grpc = tonic::server::Grpc::new(codec)
                                        .apply_compression_config(
                                            accept_compression_encodings,
                                            send_compression_encodings,
                                        )
                                        .apply_max_message_size_config(
                                            max_decoding_message_size,
                                            max_encoding_message_size,
                                        );
                                    let res = grpc.unary(method, req).await;
                                    Ok(res)
                                };
                                Box::pin(fut)
                            }
                            "/HubService/GetLinksByTarget" => {
                                #[allow(non_camel_case_types)]
                                struct GetLinksByTargetSvc<T: HubService>(pub Arc<T>);
                                impl<
                                    T: HubService,
                                > tonic::server::UnaryService<super::LinksByTargetRequest>
                                for GetLinksByTargetSvc<T> {
                                    type Response = super::MessagesResponse;
                                    type Future = BoxFuture<
                                        tonic::Response<Self::Response>,
                                        tonic::Status,
                                    >;
                                    fn call(
                                        &mut self,
                                        request: tonic::Request<super::LinksByTargetRequest>,
                                    ) -> Self::Future {
                                        let inner = Arc::clone(&self.0);
                                        let fut = async move {
                                            (*inner).get_links_by_target(request).await
                                        };
                                        Box::pin(fut)
                                    }
                                }
                                let accept_compression_encodings = self
                                    .accept_compression_encodings;
                                let send_compression_encodings = self
                                    .send_compression_encodings;
                                let max_decoding_message_size = self
                                    .max_decoding_message_size;
                                let max_encoding_message_size = self
                                    .max_encoding_message_size;
                                let inner = self.inner.clone();
                                let fut = async move {
                                    let inner = inner.0;
                                    let method = GetLinksByTargetSvc(inner);
                                    let codec = tonic::codec::ProstCodec::default();
                                    let mut grpc = tonic::server::Grpc::new(codec)
                                        .apply_compression_config(
                                            accept_compression_encodings,
                                            send_compression_encodings,
                                        )
                                        .apply_max_message_size_config(
                                            max_decoding_message_size,
                                            max_encoding_message_size,
                                        );
                                    let res = grpc.unary(method, req).await;
                                    Ok(res)
                                };
                                Box::pin(fut)
                            }
                            "/HubService/GetAllCastMessagesByFid" => {
                                #[allow(non_camel_case_types)]
                                struct GetAllCastMessagesByFidSvc<T: HubService>(
                                    pub Arc<T>,
                                );
                                impl<
                                    T: HubService,
                                > tonic::server::UnaryService<super::FidRequest>
                                for GetAllCastMessagesByFidSvc<T> {
                                    type Response = super::MessagesResponse;
                                    type Future = BoxFuture<
                                        tonic::Response<Self::Response>,
                                        tonic::Status,
                                    >;
                                    fn call(
                                        &mut self,
                                        request: tonic::Request<super::FidRequest>,
                                    ) -> Self::Future {
                                        let inner = Arc::clone(&self.0);
                                        let fut = async move {
                                            (*inner).get_all_cast_messages_by_fid(request).await
                                        };
                                        Box::pin(fut)
                                    }
                                }
                                let accept_compression_encodings = self
                                    .accept_compression_encodings;
                                let send_compression_encodings = self
                                    .send_compression_encodings;
                                let max_decoding_message_size = self
                                    .max_decoding_message_size;
                                let max_encoding_message_size = self
                                    .max_encoding_message_size;
                                let inner = self.inner.clone();
                                let fut = async move {
                                    let inner = inner.0;
                                    let method = GetAllCastMessagesByFidSvc(inner);
                                    let codec = tonic::codec::ProstCodec::default();
                                    let mut grpc = tonic::server::Grpc::new(codec)
                                        .apply_compression_config(
                                            accept_compression_encodings,
                                            send_compression_encodings,
                                        )
                                        .apply_max_message_size_config(
                                            max_decoding_message_size,
                                            max_encoding_message_size,
                                        );
                                    let res = grpc.unary(method, req).await;
                                    Ok(res)
                                };
                                Box::pin(fut)
                            }
                            "/HubService/GetAllReactionMessagesByFid" => {
                                #[allow(non_camel_case_types)]
                                struct GetAllReactionMessagesByFidSvc<T: HubService>(
                                    pub Arc<T>,
                                );
                                impl<
                                    T: HubService,
                                > tonic::server::UnaryService<super::FidRequest>
                                for GetAllReactionMessagesByFidSvc<T> {
                                    type Response = super::MessagesResponse;
                                    type Future = BoxFuture<
                                        tonic::Response<Self::Response>,
                                        tonic::Status,
                                    >;
                                    fn call(
                                        &mut self,
                                        request: tonic::Request<super::FidRequest>,
                                    ) -> Self::Future {
                                        let inner = Arc::clone(&self.0);
                                        let fut = async move {
                                            (*inner).get_all_reaction_messages_by_fid(request).await
                                        };
                                        Box::pin(fut)
                                    }
                                }
                                let accept_compression_encodings = self
                                    .accept_compression_encodings;
                                let send_compression_encodings = self
                                    .send_compression_encodings;
                                let max_decoding_message_size = self
                                    .max_decoding_message_size;
                                let max_encoding_message_size = self
                                    .max_encoding_message_size;
                                let inner = self.inner.clone();
                                let fut = async move {
                                    let inner = inner.0;
                                    let method = GetAllReactionMessagesByFidSvc(inner);
                                    let codec = tonic::codec::ProstCodec::default();
                                    let mut grpc = tonic::server::Grpc::new(codec)
                                        .apply_compression_config(
                                            accept_compression_encodings,
                                            send_compression_encodings,
                                        )
                                        .apply_max_message_size_config(
                                            max_decoding_message_size,
                                            max_encoding_message_size,
                                        );
                                    let res = grpc.unary(method, req).await;
                                    Ok(res)
                                };
                                Box::pin(fut)
                            }
                            "/HubService/GetAllVerificationMessagesByFid" => {
                                #[allow(non_camel_case_types)]
                                struct GetAllVerificationMessagesByFidSvc<T: HubService>(
                                    pub Arc<T>,
                                );
                                impl<
                                    T: HubService,
                                > tonic::server::UnaryService<super::FidRequest>
                                for GetAllVerificationMessagesByFidSvc<T> {
                                    type Response = super::MessagesResponse;
                                    type Future = BoxFuture<
                                        tonic::Response<Self::Response>,
                                        tonic::Status,
                                    >;
                                    fn call(
                                        &mut self,
                                        request: tonic::Request<super::FidRequest>,
                                    ) -> Self::Future {
                                        let inner = Arc::clone(&self.0);
                                        let fut = async move {
                                            (*inner).get_all_verification_messages_by_fid(request).await
                                        };
                                        Box::pin(fut)
                                    }
                                }
                                let accept_compression_encodings = self
                                    .accept_compression_encodings;
                                let send_compression_encodings = self
                                    .send_compression_encodings;
                                let max_decoding_message_size = self
                                    .max_decoding_message_size;
                                let max_encoding_message_size = self
                                    .max_encoding_message_size;
                                let inner = self.inner.clone();
                                let fut = async move {
                                    let inner = inner.0;
                                    let method = GetAllVerificationMessagesByFidSvc(inner);
                                    let codec = tonic::codec::ProstCodec::default();
                                    let mut grpc = tonic::server::Grpc::new(codec)
                                        .apply_compression_config(
                                            accept_compression_encodings,
                                            send_compression_encodings,
                                        )
                                        .apply_max_message_size_config(
                                            max_decoding_message_size,
                                            max_encoding_message_size,
                                        );
                                    let res = grpc.unary(method, req).await;
                                    Ok(res)
                                };
                                Box::pin(fut)
                            }
                            "/HubService/GetAllSignerMessagesByFid" => {
                                #[allow(non_camel_case_types)]
                                struct GetAllSignerMessagesByFidSvc<T: HubService>(
                                    pub Arc<T>,
                                );
                                impl<
                                    T: HubService,
                                > tonic::server::UnaryService<super::FidRequest>
                                for GetAllSignerMessagesByFidSvc<T> {
                                    type Response = super::MessagesResponse;
                                    type Future = BoxFuture<
                                        tonic::Response<Self::Response>,
                                        tonic::Status,
                                    >;
                                    fn call(
                                        &mut self,
                                        request: tonic::Request<super::FidRequest>,
                                    ) -> Self::Future {
                                        let inner = Arc::clone(&self.0);
                                        let fut = async move {
                                            (*inner).get_all_signer_messages_by_fid(request).await
                                        };
                                        Box::pin(fut)
                                    }
                                }
                                let accept_compression_encodings = self
                                    .accept_compression_encodings;
                                let send_compression_encodings = self
                                    .send_compression_encodings;
                                let max_decoding_message_size = self
                                    .max_decoding_message_size;
                                let max_encoding_message_size = self
                                    .max_encoding_message_size;
                                let inner = self.inner.clone();
                                let fut = async move {
                                    let inner = inner.0;
                                    let method = GetAllSignerMessagesByFidSvc(inner);
                                    let codec = tonic::codec::ProstCodec::default();
                                    let mut grpc = tonic::server::Grpc::new(codec)
                                        .apply_compression_config(
                                            accept_compression_encodings,
                                            send_compression_encodings,
                                        )
                                        .apply_max_message_size_config(
                                            max_decoding_message_size,
                                            max_encoding_message_size,
                                        );
                                    let res = grpc.unary(method, req).await;
                                    Ok(res)
                                };
                                Box::pin(fut)
                            }
                            "/HubService/GetAllUserDataMessagesByFid" => {
                                #[allow(non_camel_case_types)]
                                struct GetAllUserDataMessagesByFidSvc<T: HubService>(
                                    pub Arc<T>,
                                );
                                impl<
                                    T: HubService,
                                > tonic::server::UnaryService<super::FidRequest>
                                for GetAllUserDataMessagesByFidSvc<T> {
                                    type Response = super::MessagesResponse;
                                    type Future = BoxFuture<
                                        tonic::Response<Self::Response>,
                                        tonic::Status,
                                    >;
                                    fn call(
                                        &mut self,
                                        request: tonic::Request<super::FidRequest>,
                                    ) -> Self::Future {
                                        let inner = Arc::clone(&self.0);
                                        let fut = async move {
                                            (*inner).get_all_user_data_messages_by_fid(request).await
                                        };
                                        Box::pin(fut)
                                    }
                                }
                                let accept_compression_encodings = self
                                    .accept_compression_encodings;
                                let send_compression_encodings = self
                                    .send_compression_encodings;
                                let max_decoding_message_size = self
                                    .max_decoding_message_size;
                                let max_encoding_message_size = self
                                    .max_encoding_message_size;
                                let inner = self.inner.clone();
                                let fut = async move {
                                    let inner = inner.0;
                                    let method = GetAllUserDataMessagesByFidSvc(inner);
                                    let codec = tonic::codec::ProstCodec::default();
                                    let mut grpc = tonic::server::Grpc::new(codec)
                                        .apply_compression_config(
                                            accept_compression_encodings,
                                            send_compression_encodings,
                                        )
                                        .apply_max_message_size_config(
                                            max_decoding_message_size,
                                            max_encoding_message_size,
                                        );
                                    let res = grpc.unary(method, req).await;
                                    Ok(res)
                                };
                                Box::pin(fut)
                            }
                            "/HubService/GetAllLinkMessagesByFid" => {
                                #[allow(non_camel_case_types)]
                                struct GetAllLinkMessagesByFidSvc<T: HubService>(
                                    pub Arc<T>,
                                );
                                impl<
                                    T: HubService,
                                > tonic::server::UnaryService<super::FidRequest>
                                for GetAllLinkMessagesByFidSvc<T> {
                                    type Response = super::MessagesResponse;
                                    type Future = BoxFuture<
                                        tonic::Response<Self::Response>,
                                        tonic::Status,
                                    >;
                                    fn call(
                                        &mut self,
                                        request: tonic::Request<super::FidRequest>,
                                    ) -> Self::Future {
                                        let inner = Arc::clone(&self.0);
                                        let fut = async move {
                                            (*inner).get_all_link_messages_by_fid(request).await
                                        };
                                        Box::pin(fut)
                                    }
                                }
                                let accept_compression_encodings = self
                                    .accept_compression_encodings;
                                let send_compression_encodings = self
                                    .send_compression_encodings;
                                let max_decoding_message_size = self
                                    .max_decoding_message_size;
                                let max_encoding_message_size = self
                                    .max_encoding_message_size;
                                let inner = self.inner.clone();
                                let fut = async move {
                                    let inner = inner.0;
                                    let method = GetAllLinkMessagesByFidSvc(inner);
                                    let codec = tonic::codec::ProstCodec::default();
                                    let mut grpc = tonic::server::Grpc::new(codec)
                                        .apply_compression_config(
                                            accept_compression_encodings,
                                            send_compression_encodings,
                                        )
                                        .apply_max_message_size_config(
                                            max_decoding_message_size,
                                            max_encoding_message_size,
                                        );
                                    let res = grpc.unary(method, req).await;
                                    Ok(res)
                                };
                                Box::pin(fut)
                            }
                            "/HubService/GetInfo" => {
                                #[allow(non_camel_case_types)]
                                struct GetInfoSvc<T: HubService>(pub Arc<T>);
                                impl<
                                    T: HubService,
                                > tonic::server::UnaryService<super::HubInfoRequest>
                                for GetInfoSvc<T> {
                                    type Response = super::HubInfoResponse;
                                    type Future = BoxFuture<
                                        tonic::Response<Self::Response>,
                                        tonic::Status,
                                    >;
                                    fn call(
                                        &mut self,
                                        request: tonic::Request<super::HubInfoRequest>,
                                    ) -> Self::Future {
                                        let inner = Arc::clone(&self.0);
                                        let fut = async move { (*inner).get_info(request).await };
                                        Box::pin(fut)
                                    }
                                }
                                let accept_compression_encodings = self
                                    .accept_compression_encodings;
                                let send_compression_encodings = self
                                    .send_compression_encodings;
                                let max_decoding_message_size = self
                                    .max_decoding_message_size;
                                let max_encoding_message_size = self
                                    .max_encoding_message_size;
                                let inner = self.inner.clone();
                                let fut = async move {
                                    let inner = inner.0;
                                    let method = GetInfoSvc(inner);
                                    let codec = tonic::codec::ProstCodec::default();
                                    let mut grpc = tonic::server::Grpc::new(codec)
                                        .apply_compression_config(
                                            accept_compression_encodings,
                                            send_compression_encodings,
                                        )
                                        .apply_max_message_size_config(
                                            max_decoding_message_size,
                                            max_encoding_message_size,
                                        );
                                    let res = grpc.unary(method, req).await;
                                    Ok(res)
                                };
                                Box::pin(fut)
                            }
                            "/HubService/GetSyncStatus" => {
                                #[allow(non_camel_case_types)]
                                struct GetSyncStatusSvc<T: HubService>(pub Arc<T>);
                                impl<
                                    T: HubService,
                                > tonic::server::UnaryService<super::SyncStatusRequest>
                                for GetSyncStatusSvc<T> {
                                    type Response = super::SyncStatusResponse;
                                    type Future = BoxFuture<
                                        tonic::Response<Self::Response>,
                                        tonic::Status,
                                    >;
                                    fn call(
                                        &mut self,
                                        request: tonic::Request<super::SyncStatusRequest>,
                                    ) -> Self::Future {
                                        let inner = Arc::clone(&self.0);
                                        let fut = async move {
                                            (*inner).get_sync_status(request).await
                                        };
                                        Box::pin(fut)
                                    }
                                }
                                let accept_compression_encodings = self
                                    .accept_compression_encodings;
                                let send_compression_encodings = self
                                    .send_compression_encodings;
                                let max_decoding_message_size = self
                                    .max_decoding_message_size;
                                let max_encoding_message_size = self
                                    .max_encoding_message_size;
                                let inner = self.inner.clone();
                                let fut = async move {
                                    let inner = inner.0;
                                    let method = GetSyncStatusSvc(inner);
                                    let codec = tonic::codec::ProstCodec::default();
                                    let mut grpc = tonic::server::Grpc::new(codec)
                                        .apply_compression_config(
                                            accept_compression_encodings,
                                            send_compression_encodings,
                                        )
                                        .apply_max_message_size_config(
                                            max_decoding_message_size,
                                            max_encoding_message_size,
                                        );
                                    let res = grpc.unary(method, req).await;
                                    Ok(res)
                                };
                                Box::pin(fut)
                            }
                            "/HubService/GetAllSyncIdsByPrefix" => {
                                #[allow(non_camel_case_types)]
                                struct GetAllSyncIdsByPrefixSvc<T: HubService>(pub Arc<T>);
                                impl<
                                    T: HubService,
                                > tonic::server::UnaryService<super::TrieNodePrefix>
                                for GetAllSyncIdsByPrefixSvc<T> {
                                    type Response = super::SyncIds;
                                    type Future = BoxFuture<
                                        tonic::Response<Self::Response>,
                                        tonic::Status,
                                    >;
                                    fn call(
                                        &mut self,
                                        request: tonic::Request<super::TrieNodePrefix>,
                                    ) -> Self::Future {
                                        let inner = Arc::clone(&self.0);
                                        let fut = async move {
                                            (*inner).get_all_sync_ids_by_prefix(request).await
                                        };
                                        Box::pin(fut)
                                    }
                                }
                                let accept_compression_encodings = self
                                    .accept_compression_encodings;
                                let send_compression_encodings = self
                                    .send_compression_encodings;
                                let max_decoding_message_size = self
                                    .max_decoding_message_size;
                                let max_encoding_message_size = self
                                    .max_encoding_message_size;
                                let inner = self.inner.clone();
                                let fut = async move {
                                    let inner = inner.0;
                                    let method = GetAllSyncIdsByPrefixSvc(inner);
                                    let codec = tonic::codec::ProstCodec::default();
                                    let mut grpc = tonic::server::Grpc::new(codec)
                                        .apply_compression_config(
                                            accept_compression_encodings,
                                            send_compression_encodings,
                                        )
                                        .apply_max_message_size_config(
                                            max_decoding_message_size,
                                            max_encoding_message_size,
                                        );
                                    let res = grpc.unary(method, req).await;
                                    Ok(res)
                                };
                                Box::pin(fut)
                            }
                            "/HubService/GetAllMessagesBySyncIds" => {
                                #[allow(non_camel_case_types)]
                                struct GetAllMessagesBySyncIdsSvc<T: HubService>(
                                    pub Arc<T>,
                                );
                                impl<
                                    T: HubService,
                                > tonic::server::UnaryService<super::SyncIds>
                                for GetAllMessagesBySyncIdsSvc<T> {
                                    type Response = super::MessagesResponse;
                                    type Future = BoxFuture<
                                        tonic::Response<Self::Response>,
                                        tonic::Status,
                                    >;
                                    fn call(
                                        &mut self,
                                        request: tonic::Request<super::SyncIds>,
                                    ) -> Self::Future {
                                        let inner = Arc::clone(&self.0);
                                        let fut = async move {
                                            (*inner).get_all_messages_by_sync_ids(request).await
                                        };
                                        Box::pin(fut)
                                    }
                                }
                                let accept_compression_encodings = self
                                    .accept_compression_encodings;
                                let send_compression_encodings = self
                                    .send_compression_encodings;
                                let max_decoding_message_size = self
                                    .max_decoding_message_size;
                                let max_encoding_message_size = self
                                    .max_encoding_message_size;
                                let inner = self.inner.clone();
                                let fut = async move {
                                    let inner = inner.0;
                                    let method = GetAllMessagesBySyncIdsSvc(inner);
                                    let codec = tonic::codec::ProstCodec::default();
                                    let mut grpc = tonic::server::Grpc::new(codec)
                                        .apply_compression_config(
                                            accept_compression_encodings,
                                            send_compression_encodings,
                                        )
                                        .apply_max_message_size_config(
                                            max_decoding_message_size,
                                            max_encoding_message_size,
                                        );
                                    let res = grpc.unary(method, req).await;
                                    Ok(res)
                                };
                                Box::pin(fut)
                            }
                            "/HubService/GetSyncMetadataByPrefix" => {
                                #[allow(non_camel_case_types)]
                                struct GetSyncMetadataByPrefixSvc<T: HubService>(
                                    pub Arc<T>,
                                );
                                impl<
                                    T: HubService,
                                > tonic::server::UnaryService<super::TrieNodePrefix>
                                for GetSyncMetadataByPrefixSvc<T> {
                                    type Response = super::TrieNodeMetadataResponse;
                                    type Future = BoxFuture<
                                        tonic::Response<Self::Response>,
                                        tonic::Status,
                                    >;
                                    fn call(
                                        &mut self,
                                        request: tonic::Request<super::TrieNodePrefix>,
                                    ) -> Self::Future {
                                        let inner = Arc::clone(&self.0);
                                        let fut = async move {
                                            (*inner).get_sync_metadata_by_prefix(request).await
                                        };
                                        Box::pin(fut)
                                    }
                                }
                                let accept_compression_encodings = self
                                    .accept_compression_encodings;
                                let send_compression_encodings = self
                                    .send_compression_encodings;
                                let max_decoding_message_size = self
                                    .max_decoding_message_size;
                                let max_encoding_message_size = self
                                    .max_encoding_message_size;
                                let inner = self.inner.clone();
                                let fut = async move {
                                    let inner = inner.0;
                                    let method = GetSyncMetadataByPrefixSvc(inner);
                                    let codec = tonic::codec::ProstCodec::default();
                                    let mut grpc = tonic::server::Grpc::new(codec)
                                        .apply_compression_config(
                                            accept_compression_encodings,
                                            send_compression_encodings,
                                        )
                                        .apply_max_message_size_config(
                                            max_decoding_message_size,
                                            max_encoding_message_size,
                                        );
                                    let res = grpc.unary(method, req).await;
                                    Ok(res)
                                };
                                Box::pin(fut)
                            }
                            "/HubService/GetSyncSnapshotByPrefix" => {
                                #[allow(non_camel_case_types)]
                                struct GetSyncSnapshotByPrefixSvc<T: HubService>(
                                    pub Arc<T>,
                                );
                                impl<
                                    T: HubService,
                                > tonic::server::UnaryService<super::TrieNodePrefix>
                                for GetSyncSnapshotByPrefixSvc<T> {
                                    type Response = super::TrieNodeSnapshotResponse;
                                    type Future = BoxFuture<
                                        tonic::Response<Self::Response>,
                                        tonic::Status,
                                    >;
                                    fn call(
                                        &mut self,
                                        request: tonic::Request<super::TrieNodePrefix>,
                                    ) -> Self::Future {
                                        let inner = Arc::clone(&self.0);
                                        let fut = async move {
                                            (*inner).get_sync_snapshot_by_prefix(request).await
                                        };
                                        Box::pin(fut)
                                    }
                                }
                                let accept_compression_encodings = self
                                    .accept_compression_encodings;
                                let send_compression_encodings = self
                                    .send_compression_encodings;
                                let max_decoding_message_size = self
                                    .max_decoding_message_size;
                                let max_encoding_message_size = self
                                    .max_encoding_message_size;
                                let inner = self.inner.clone();
                                let fut = async move {
                                    let inner = inner.0;
                                    let method = GetSyncSnapshotByPrefixSvc(inner);
                                    let codec = tonic::codec::ProstCodec::default();
                                    let mut grpc = tonic::server::Grpc::new(codec)
                                        .apply_compression_config(
                                            accept_compression_encodings,
                                            send_compression_encodings,
                                        )
                                        .apply_max_message_size_config(
                                            max_decoding_message_size,
                                            max_encoding_message_size,
                                        );
                                    let res = grpc.unary(method, req).await;
                                    Ok(res)
                                };
                                Box::pin(fut)
                            }
                            _ => {
                                Box::pin(async move {
                                    Ok(
                                        http::Response::builder()
                                            .status(200)
                                            .header("grpc-status", "12")
                                            .header("content-type", "application/grpc")
                                            .body(empty_body())
                                            .unwrap(),
                                    )
                                })
                            }
                        }
                    }
                }
                impl<T: HubService> Clone for HubServiceServer<T> {
                    fn clone(&self) -> Self {
                        let inner = self.inner.clone();
                        Self {
                            inner,
                            accept_compression_encodings: self
                                .accept_compression_encodings,
                            send_compression_encodings: self.send_compression_encodings,
                            max_decoding_message_size: self.max_decoding_message_size,
                            max_encoding_message_size: self.max_encoding_message_size,
                        }
                    }
                }
                impl<T: HubService> Clone for _Inner<T> {
                    fn clone(&self) -> Self {
                        Self(Arc::clone(&self.0))
                    }
                }
                impl<T: std::fmt::Debug> std::fmt::Debug for _Inner<T> {
                    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        f.write_fmt(format_args!("{0:?}", self.0))
                    }
                }
                impl<T: HubService> tonic::server::NamedService for HubServiceServer<T> {
                    const NAME: &'static str = "HubService";
                }
            }
            /// Generated server implementations.
            pub mod admin_service_server {
                #![allow(
                    unused_variables,
                    dead_code,
                    missing_docs,
                    clippy::let_unit_value
                )]
                use tonic::codegen::*;
                /// Generated trait containing gRPC methods that should be implemented for use with AdminServiceServer.
                pub trait AdminService: Send + Sync + 'static {
                    #[must_use]
                    #[allow(clippy::type_complexity, clippy::type_repetition_in_bounds)]
                    fn rebuild_sync_trie<'life0, 'async_trait>(
                        &'life0 self,
                        request: tonic::Request<super::Empty>,
                    ) -> ::core::pin::Pin<
                        Box<
                            dyn ::core::future::Future<
                                Output = std::result::Result<
                                    tonic::Response<super::Empty>,
                                    tonic::Status,
                                >,
                            > + ::core::marker::Send + 'async_trait,
                        >,
                    >
                    where
                        'life0: 'async_trait,
                        Self: 'async_trait;
                    #[must_use]
                    #[allow(clippy::type_complexity, clippy::type_repetition_in_bounds)]
                    fn delete_all_messages_from_db<'life0, 'async_trait>(
                        &'life0 self,
                        request: tonic::Request<super::Empty>,
                    ) -> ::core::pin::Pin<
                        Box<
                            dyn ::core::future::Future<
                                Output = std::result::Result<
                                    tonic::Response<super::Empty>,
                                    tonic::Status,
                                >,
                            > + ::core::marker::Send + 'async_trait,
                        >,
                    >
                    where
                        'life0: 'async_trait,
                        Self: 'async_trait;
                    #[must_use]
                    #[allow(clippy::type_complexity, clippy::type_repetition_in_bounds)]
                    fn submit_id_registry_event<'life0, 'async_trait>(
                        &'life0 self,
                        request: tonic::Request<super::IdRegistryEvent>,
                    ) -> ::core::pin::Pin<
                        Box<
                            dyn ::core::future::Future<
                                Output = std::result::Result<
                                    tonic::Response<super::IdRegistryEvent>,
                                    tonic::Status,
                                >,
                            > + ::core::marker::Send + 'async_trait,
                        >,
                    >
                    where
                        'life0: 'async_trait,
                        Self: 'async_trait;
                    #[must_use]
                    #[allow(clippy::type_complexity, clippy::type_repetition_in_bounds)]
                    fn submit_name_registry_event<'life0, 'async_trait>(
                        &'life0 self,
                        request: tonic::Request<super::NameRegistryEvent>,
                    ) -> ::core::pin::Pin<
                        Box<
                            dyn ::core::future::Future<
                                Output = std::result::Result<
                                    tonic::Response<super::NameRegistryEvent>,
                                    tonic::Status,
                                >,
                            > + ::core::marker::Send + 'async_trait,
                        >,
                    >
                    where
                        'life0: 'async_trait,
                        Self: 'async_trait;
                    #[must_use]
                    #[allow(clippy::type_complexity, clippy::type_repetition_in_bounds)]
                    fn submit_on_chain_event<'life0, 'async_trait>(
                        &'life0 self,
                        request: tonic::Request<super::OnChainEvent>,
                    ) -> ::core::pin::Pin<
                        Box<
                            dyn ::core::future::Future<
                                Output = std::result::Result<
                                    tonic::Response<super::OnChainEvent>,
                                    tonic::Status,
                                >,
                            > + ::core::marker::Send + 'async_trait,
                        >,
                    >
                    where
                        'life0: 'async_trait,
                        Self: 'async_trait;
                }
                pub struct AdminServiceServer<T: AdminService> {
                    inner: _Inner<T>,
                    accept_compression_encodings: EnabledCompressionEncodings,
                    send_compression_encodings: EnabledCompressionEncodings,
                    max_decoding_message_size: Option<usize>,
                    max_encoding_message_size: Option<usize>,
                }
                #[automatically_derived]
                impl<T: ::core::fmt::Debug + AdminService> ::core::fmt::Debug
                for AdminServiceServer<T> {
                    fn fmt(
                        &self,
                        f: &mut ::core::fmt::Formatter,
                    ) -> ::core::fmt::Result {
                        ::core::fmt::Formatter::debug_struct_field5_finish(
                            f,
                            "AdminServiceServer",
                            "inner",
                            &self.inner,
                            "accept_compression_encodings",
                            &self.accept_compression_encodings,
                            "send_compression_encodings",
                            &self.send_compression_encodings,
                            "max_decoding_message_size",
                            &self.max_decoding_message_size,
                            "max_encoding_message_size",
                            &&self.max_encoding_message_size,
                        )
                    }
                }
                struct _Inner<T>(Arc<T>);
                impl<T: AdminService> AdminServiceServer<T> {
                    pub fn new(inner: T) -> Self {
                        Self::from_arc(Arc::new(inner))
                    }
                    pub fn from_arc(inner: Arc<T>) -> Self {
                        let inner = _Inner(inner);
                        Self {
                            inner,
                            accept_compression_encodings: Default::default(),
                            send_compression_encodings: Default::default(),
                            max_decoding_message_size: None,
                            max_encoding_message_size: None,
                        }
                    }
                    pub fn with_interceptor<F>(
                        inner: T,
                        interceptor: F,
                    ) -> InterceptedService<Self, F>
                    where
                        F: tonic::service::Interceptor,
                    {
                        InterceptedService::new(Self::new(inner), interceptor)
                    }
                    /// Enable decompressing requests with the given encoding.
                    #[must_use]
                    pub fn accept_compressed(
                        mut self,
                        encoding: CompressionEncoding,
                    ) -> Self {
                        self.accept_compression_encodings.enable(encoding);
                        self
                    }
                    /// Compress responses with the given encoding, if the client supports it.
                    #[must_use]
                    pub fn send_compressed(
                        mut self,
                        encoding: CompressionEncoding,
                    ) -> Self {
                        self.send_compression_encodings.enable(encoding);
                        self
                    }
                    /// Limits the maximum size of a decoded message.
                    ///
                    /// Default: `4MB`
                    #[must_use]
                    pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
                        self.max_decoding_message_size = Some(limit);
                        self
                    }
                    /// Limits the maximum size of an encoded message.
                    ///
                    /// Default: `usize::MAX`
                    #[must_use]
                    pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
                        self.max_encoding_message_size = Some(limit);
                        self
                    }
                }
                impl<T, B> tonic::codegen::Service<http::Request<B>>
                for AdminServiceServer<T>
                where
                    T: AdminService,
                    B: Body + Send + 'static,
                    B::Error: Into<StdError> + Send + 'static,
                {
                    type Response = http::Response<tonic::body::BoxBody>;
                    type Error = std::convert::Infallible;
                    type Future = BoxFuture<Self::Response, Self::Error>;
                    fn poll_ready(
                        &mut self,
                        _cx: &mut Context<'_>,
                    ) -> Poll<std::result::Result<(), Self::Error>> {
                        Poll::Ready(Ok(()))
                    }
                    fn call(&mut self, req: http::Request<B>) -> Self::Future {
                        let inner = self.inner.clone();
                        match req.uri().path() {
                            "/AdminService/RebuildSyncTrie" => {
                                #[allow(non_camel_case_types)]
                                struct RebuildSyncTrieSvc<T: AdminService>(pub Arc<T>);
                                impl<
                                    T: AdminService,
                                > tonic::server::UnaryService<super::Empty>
                                for RebuildSyncTrieSvc<T> {
                                    type Response = super::Empty;
                                    type Future = BoxFuture<
                                        tonic::Response<Self::Response>,
                                        tonic::Status,
                                    >;
                                    fn call(
                                        &mut self,
                                        request: tonic::Request<super::Empty>,
                                    ) -> Self::Future {
                                        let inner = Arc::clone(&self.0);
                                        let fut = async move {
                                            (*inner).rebuild_sync_trie(request).await
                                        };
                                        Box::pin(fut)
                                    }
                                }
                                let accept_compression_encodings = self
                                    .accept_compression_encodings;
                                let send_compression_encodings = self
                                    .send_compression_encodings;
                                let max_decoding_message_size = self
                                    .max_decoding_message_size;
                                let max_encoding_message_size = self
                                    .max_encoding_message_size;
                                let inner = self.inner.clone();
                                let fut = async move {
                                    let inner = inner.0;
                                    let method = RebuildSyncTrieSvc(inner);
                                    let codec = tonic::codec::ProstCodec::default();
                                    let mut grpc = tonic::server::Grpc::new(codec)
                                        .apply_compression_config(
                                            accept_compression_encodings,
                                            send_compression_encodings,
                                        )
                                        .apply_max_message_size_config(
                                            max_decoding_message_size,
                                            max_encoding_message_size,
                                        );
                                    let res = grpc.unary(method, req).await;
                                    Ok(res)
                                };
                                Box::pin(fut)
                            }
                            "/AdminService/DeleteAllMessagesFromDb" => {
                                #[allow(non_camel_case_types)]
                                struct DeleteAllMessagesFromDbSvc<T: AdminService>(
                                    pub Arc<T>,
                                );
                                impl<
                                    T: AdminService,
                                > tonic::server::UnaryService<super::Empty>
                                for DeleteAllMessagesFromDbSvc<T> {
                                    type Response = super::Empty;
                                    type Future = BoxFuture<
                                        tonic::Response<Self::Response>,
                                        tonic::Status,
                                    >;
                                    fn call(
                                        &mut self,
                                        request: tonic::Request<super::Empty>,
                                    ) -> Self::Future {
                                        let inner = Arc::clone(&self.0);
                                        let fut = async move {
                                            (*inner).delete_all_messages_from_db(request).await
                                        };
                                        Box::pin(fut)
                                    }
                                }
                                let accept_compression_encodings = self
                                    .accept_compression_encodings;
                                let send_compression_encodings = self
                                    .send_compression_encodings;
                                let max_decoding_message_size = self
                                    .max_decoding_message_size;
                                let max_encoding_message_size = self
                                    .max_encoding_message_size;
                                let inner = self.inner.clone();
                                let fut = async move {
                                    let inner = inner.0;
                                    let method = DeleteAllMessagesFromDbSvc(inner);
                                    let codec = tonic::codec::ProstCodec::default();
                                    let mut grpc = tonic::server::Grpc::new(codec)
                                        .apply_compression_config(
                                            accept_compression_encodings,
                                            send_compression_encodings,
                                        )
                                        .apply_max_message_size_config(
                                            max_decoding_message_size,
                                            max_encoding_message_size,
                                        );
                                    let res = grpc.unary(method, req).await;
                                    Ok(res)
                                };
                                Box::pin(fut)
                            }
                            "/AdminService/SubmitIdRegistryEvent" => {
                                #[allow(non_camel_case_types)]
                                struct SubmitIdRegistryEventSvc<T: AdminService>(
                                    pub Arc<T>,
                                );
                                impl<
                                    T: AdminService,
                                > tonic::server::UnaryService<super::IdRegistryEvent>
                                for SubmitIdRegistryEventSvc<T> {
                                    type Response = super::IdRegistryEvent;
                                    type Future = BoxFuture<
                                        tonic::Response<Self::Response>,
                                        tonic::Status,
                                    >;
                                    fn call(
                                        &mut self,
                                        request: tonic::Request<super::IdRegistryEvent>,
                                    ) -> Self::Future {
                                        let inner = Arc::clone(&self.0);
                                        let fut = async move {
                                            (*inner).submit_id_registry_event(request).await
                                        };
                                        Box::pin(fut)
                                    }
                                }
                                let accept_compression_encodings = self
                                    .accept_compression_encodings;
                                let send_compression_encodings = self
                                    .send_compression_encodings;
                                let max_decoding_message_size = self
                                    .max_decoding_message_size;
                                let max_encoding_message_size = self
                                    .max_encoding_message_size;
                                let inner = self.inner.clone();
                                let fut = async move {
                                    let inner = inner.0;
                                    let method = SubmitIdRegistryEventSvc(inner);
                                    let codec = tonic::codec::ProstCodec::default();
                                    let mut grpc = tonic::server::Grpc::new(codec)
                                        .apply_compression_config(
                                            accept_compression_encodings,
                                            send_compression_encodings,
                                        )
                                        .apply_max_message_size_config(
                                            max_decoding_message_size,
                                            max_encoding_message_size,
                                        );
                                    let res = grpc.unary(method, req).await;
                                    Ok(res)
                                };
                                Box::pin(fut)
                            }
                            "/AdminService/SubmitNameRegistryEvent" => {
                                #[allow(non_camel_case_types)]
                                struct SubmitNameRegistryEventSvc<T: AdminService>(
                                    pub Arc<T>,
                                );
                                impl<
                                    T: AdminService,
                                > tonic::server::UnaryService<super::NameRegistryEvent>
                                for SubmitNameRegistryEventSvc<T> {
                                    type Response = super::NameRegistryEvent;
                                    type Future = BoxFuture<
                                        tonic::Response<Self::Response>,
                                        tonic::Status,
                                    >;
                                    fn call(
                                        &mut self,
                                        request: tonic::Request<super::NameRegistryEvent>,
                                    ) -> Self::Future {
                                        let inner = Arc::clone(&self.0);
                                        let fut = async move {
                                            (*inner).submit_name_registry_event(request).await
                                        };
                                        Box::pin(fut)
                                    }
                                }
                                let accept_compression_encodings = self
                                    .accept_compression_encodings;
                                let send_compression_encodings = self
                                    .send_compression_encodings;
                                let max_decoding_message_size = self
                                    .max_decoding_message_size;
                                let max_encoding_message_size = self
                                    .max_encoding_message_size;
                                let inner = self.inner.clone();
                                let fut = async move {
                                    let inner = inner.0;
                                    let method = SubmitNameRegistryEventSvc(inner);
                                    let codec = tonic::codec::ProstCodec::default();
                                    let mut grpc = tonic::server::Grpc::new(codec)
                                        .apply_compression_config(
                                            accept_compression_encodings,
                                            send_compression_encodings,
                                        )
                                        .apply_max_message_size_config(
                                            max_decoding_message_size,
                                            max_encoding_message_size,
                                        );
                                    let res = grpc.unary(method, req).await;
                                    Ok(res)
                                };
                                Box::pin(fut)
                            }
                            "/AdminService/SubmitOnChainEvent" => {
                                #[allow(non_camel_case_types)]
                                struct SubmitOnChainEventSvc<T: AdminService>(pub Arc<T>);
                                impl<
                                    T: AdminService,
                                > tonic::server::UnaryService<super::OnChainEvent>
                                for SubmitOnChainEventSvc<T> {
                                    type Response = super::OnChainEvent;
                                    type Future = BoxFuture<
                                        tonic::Response<Self::Response>,
                                        tonic::Status,
                                    >;
                                    fn call(
                                        &mut self,
                                        request: tonic::Request<super::OnChainEvent>,
                                    ) -> Self::Future {
                                        let inner = Arc::clone(&self.0);
                                        let fut = async move {
                                            (*inner).submit_on_chain_event(request).await
                                        };
                                        Box::pin(fut)
                                    }
                                }
                                let accept_compression_encodings = self
                                    .accept_compression_encodings;
                                let send_compression_encodings = self
                                    .send_compression_encodings;
                                let max_decoding_message_size = self
                                    .max_decoding_message_size;
                                let max_encoding_message_size = self
                                    .max_encoding_message_size;
                                let inner = self.inner.clone();
                                let fut = async move {
                                    let inner = inner.0;
                                    let method = SubmitOnChainEventSvc(inner);
                                    let codec = tonic::codec::ProstCodec::default();
                                    let mut grpc = tonic::server::Grpc::new(codec)
                                        .apply_compression_config(
                                            accept_compression_encodings,
                                            send_compression_encodings,
                                        )
                                        .apply_max_message_size_config(
                                            max_decoding_message_size,
                                            max_encoding_message_size,
                                        );
                                    let res = grpc.unary(method, req).await;
                                    Ok(res)
                                };
                                Box::pin(fut)
                            }
                            _ => {
                                Box::pin(async move {
                                    Ok(
                                        http::Response::builder()
                                            .status(200)
                                            .header("grpc-status", "12")
                                            .header("content-type", "application/grpc")
                                            .body(empty_body())
                                            .unwrap(),
                                    )
                                })
                            }
                        }
                    }
                }
                impl<T: AdminService> Clone for AdminServiceServer<T> {
                    fn clone(&self) -> Self {
                        let inner = self.inner.clone();
                        Self {
                            inner,
                            accept_compression_encodings: self
                                .accept_compression_encodings,
                            send_compression_encodings: self.send_compression_encodings,
                            max_decoding_message_size: self.max_decoding_message_size,
                            max_encoding_message_size: self.max_encoding_message_size,
                        }
                    }
                }
                impl<T: AdminService> Clone for _Inner<T> {
                    fn clone(&self) -> Self {
                        Self(Arc::clone(&self.0))
                    }
                }
                impl<T: std::fmt::Debug> std::fmt::Debug for _Inner<T> {
                    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        f.write_fmt(format_args!("{0:?}", self.0))
                    }
                }
                impl<T: AdminService> tonic::server::NamedService
                for AdminServiceServer<T> {
                    const NAME: &'static str = "AdminService";
                }
            }
            #[allow(clippy::derive_partial_eq_without_eq)]
            pub struct DbTrieNode {
                #[prost(bytes = "vec", tag = "1")]
                pub key: ::prost::alloc::vec::Vec<u8>,
                #[prost(uint32, repeated, tag = "2")]
                pub child_chars: ::prost::alloc::vec::Vec<u32>,
                #[prost(uint32, tag = "3")]
                pub items: u32,
                #[prost(bytes = "vec", tag = "4")]
                pub hash: ::prost::alloc::vec::Vec<u8>,
            }
            #[automatically_derived]
            #[allow(clippy::derive_partial_eq_without_eq)]
            impl ::core::clone::Clone for DbTrieNode {
                #[inline]
                fn clone(&self) -> DbTrieNode {
                    DbTrieNode {
                        key: ::core::clone::Clone::clone(&self.key),
                        child_chars: ::core::clone::Clone::clone(&self.child_chars),
                        items: ::core::clone::Clone::clone(&self.items),
                        hash: ::core::clone::Clone::clone(&self.hash),
                    }
                }
            }
            #[allow(clippy::derive_partial_eq_without_eq)]
            #[automatically_derived]
            impl ::core::marker::StructuralPartialEq for DbTrieNode {}
            #[automatically_derived]
            #[allow(clippy::derive_partial_eq_without_eq)]
            impl ::core::cmp::PartialEq for DbTrieNode {
                #[inline]
                fn eq(&self, other: &DbTrieNode) -> bool {
                    self.key == other.key && self.child_chars == other.child_chars
                        && self.items == other.items && self.hash == other.hash
                }
            }
            impl ::prost::Message for DbTrieNode {
                #[allow(unused_variables)]
                fn encode_raw<B>(&self, buf: &mut B)
                where
                    B: ::prost::bytes::BufMut,
                {
                    if self.key != b"" as &[u8] {
                        ::prost::encoding::bytes::encode(1u32, &self.key, buf);
                    }
                    ::prost::encoding::uint32::encode_packed(
                        2u32,
                        &self.child_chars,
                        buf,
                    );
                    if self.items != 0u32 {
                        ::prost::encoding::uint32::encode(3u32, &self.items, buf);
                    }
                    if self.hash != b"" as &[u8] {
                        ::prost::encoding::bytes::encode(4u32, &self.hash, buf);
                    }
                }
                #[allow(unused_variables)]
                fn merge_field<B>(
                    &mut self,
                    tag: u32,
                    wire_type: ::prost::encoding::WireType,
                    buf: &mut B,
                    ctx: ::prost::encoding::DecodeContext,
                ) -> ::core::result::Result<(), ::prost::DecodeError>
                where
                    B: ::prost::bytes::Buf,
                {
                    const STRUCT_NAME: &'static str = "DbTrieNode";
                    match tag {
                        1u32 => {
                            let mut value = &mut self.key;
                            ::prost::encoding::bytes::merge(wire_type, value, buf, ctx)
                                .map_err(|mut error| {
                                    error.push(STRUCT_NAME, "key");
                                    error
                                })
                        }
                        2u32 => {
                            let mut value = &mut self.child_chars;
                            ::prost::encoding::uint32::merge_repeated(
                                    wire_type,
                                    value,
                                    buf,
                                    ctx,
                                )
                                .map_err(|mut error| {
                                    error.push(STRUCT_NAME, "child_chars");
                                    error
                                })
                        }
                        3u32 => {
                            let mut value = &mut self.items;
                            ::prost::encoding::uint32::merge(wire_type, value, buf, ctx)
                                .map_err(|mut error| {
                                    error.push(STRUCT_NAME, "items");
                                    error
                                })
                        }
                        4u32 => {
                            let mut value = &mut self.hash;
                            ::prost::encoding::bytes::merge(wire_type, value, buf, ctx)
                                .map_err(|mut error| {
                                    error.push(STRUCT_NAME, "hash");
                                    error
                                })
                        }
                        _ => ::prost::encoding::skip_field(wire_type, tag, buf, ctx),
                    }
                }
                #[inline]
                fn encoded_len(&self) -> usize {
                    0
                        + if self.key != b"" as &[u8] {
                            ::prost::encoding::bytes::encoded_len(1u32, &self.key)
                        } else {
                            0
                        }
                        + ::prost::encoding::uint32::encoded_len_packed(
                            2u32,
                            &self.child_chars,
                        )
                        + if self.items != 0u32 {
                            ::prost::encoding::uint32::encoded_len(3u32, &self.items)
                        } else {
                            0
                        }
                        + if self.hash != b"" as &[u8] {
                            ::prost::encoding::bytes::encoded_len(4u32, &self.hash)
                        } else {
                            0
                        }
                }
                fn clear(&mut self) {
                    self.key.clear();
                    self.child_chars.clear();
                    self.items = 0u32;
                    self.hash.clear();
                }
            }
            impl ::core::default::Default for DbTrieNode {
                fn default() -> Self {
                    DbTrieNode {
                        key: ::core::default::Default::default(),
                        child_chars: ::prost::alloc::vec::Vec::new(),
                        items: 0u32,
                        hash: ::core::default::Default::default(),
                    }
                }
            }
            impl ::core::fmt::Debug for DbTrieNode {
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    let mut builder = f.debug_struct("DbTrieNode");
                    let builder = {
                        let wrapper = {
                            fn ScalarWrapper<T>(v: T) -> T {
                                v
                            }
                            ScalarWrapper(&self.key)
                        };
                        builder.field("key", &wrapper)
                    };
                    let builder = {
                        let wrapper = {
                            struct ScalarWrapper<'a>(&'a ::prost::alloc::vec::Vec<u32>);
                            impl<'a> ::core::fmt::Debug for ScalarWrapper<'a> {
                                fn fmt(
                                    &self,
                                    f: &mut ::core::fmt::Formatter,
                                ) -> ::core::fmt::Result {
                                    let mut vec_builder = f.debug_list();
                                    for v in self.0 {
                                        fn Inner<T>(v: T) -> T {
                                            v
                                        }
                                        vec_builder.entry(&Inner(v));
                                    }
                                    vec_builder.finish()
                                }
                            }
                            ScalarWrapper(&self.child_chars)
                        };
                        builder.field("child_chars", &wrapper)
                    };
                    let builder = {
                        let wrapper = {
                            fn ScalarWrapper<T>(v: T) -> T {
                                v
                            }
                            ScalarWrapper(&self.items)
                        };
                        builder.field("items", &wrapper)
                    };
                    let builder = {
                        let wrapper = {
                            fn ScalarWrapper<T>(v: T) -> T {
                                v
                            }
                            ScalarWrapper(&self.hash)
                        };
                        builder.field("hash", &wrapper)
                    };
                    builder.finish()
                }
            }
        }
    }
    pub mod signers {
        mod ed25519_signer {}
        mod signer {}
    }
    pub mod time {
        use super::errors::*;
        const FARCASTER_EPOCH: u64 = 1609459200000;
        pub fn get_farcaster_time() -> Result<u64, HubError> {
            to_farcaster_time(
                std::time::SystemTime::now()
                    .duration_since(std::time::UNIX_EPOCH)
                    .unwrap()
                    .as_millis() as u64,
            )
        }
        pub fn to_farcaster_time(time: u64) -> Result<u64, HubError> {
            if time < FARCASTER_EPOCH {
                return Err(
                    HubError::BadRequest(
                        BadRequestType::InvalidParam,
                        "time must be after Farcaster epoch (01/01/2022)".to_string(),
                    ),
                );
            }
            let seconds_since_epoch = (time - FARCASTER_EPOCH) / 1000;
            if seconds_since_epoch > 2u64.pow(32) - 1 {
                return Err(
                    HubError::BadRequest(
                        BadRequestType::InvalidParam,
                        "time too far in future".to_string(),
                    ),
                );
            }
            Ok(seconds_since_epoch)
        }
        pub fn from_farcaster_time(time: u64) -> Result<u64, HubError> {
            Ok(time * 1000 + FARCASTER_EPOCH)
        }
    }
    pub mod username_proof {
        pub struct UserNameProofClaim {
            name: String,
            owner: String,
            timestamp: u64,
        }
        impl UserNameProofClaim {
            fn new(name: String, owner: String, timestamp: u64) -> Self {
                Self { name, owner, timestamp }
            }
        }
    }
}
mod network {
    mod p2p {
        mod gossip_behaviour {
            use libp2p::allow_block_list::{self, AllowedPeers, BlockedPeers};
            use libp2p::gossipsub::self;
            use libp2p::swarm::NetworkBehaviour;
            pub struct GossipBehaviour {
                pub(crate) gossipsub: gossipsub::Behaviour,
                pub(crate) allowed_peers: allow_block_list::Behaviour<AllowedPeers>,
                pub(crate) blocked_peers: allow_block_list::Behaviour<BlockedPeers>,
            }
            ///`NetworkBehaviour::ToSwarm` produced by GossipBehaviour.
            pub enum GossipBehaviourEvent
            where
                gossipsub::Behaviour: ::libp2p::swarm::derive_prelude::NetworkBehaviour,
                allow_block_list::Behaviour<
                    AllowedPeers,
                >: ::libp2p::swarm::derive_prelude::NetworkBehaviour,
                allow_block_list::Behaviour<
                    BlockedPeers,
                >: ::libp2p::swarm::derive_prelude::NetworkBehaviour,
            {
                Gossipsub(
                    <gossipsub::Behaviour as ::libp2p::swarm::derive_prelude::NetworkBehaviour>::ToSwarm,
                ),
                AllowedPeers(
                    <allow_block_list::Behaviour<
                        AllowedPeers,
                    > as ::libp2p::swarm::derive_prelude::NetworkBehaviour>::ToSwarm,
                ),
                BlockedPeers(
                    <allow_block_list::Behaviour<
                        BlockedPeers,
                    > as ::libp2p::swarm::derive_prelude::NetworkBehaviour>::ToSwarm,
                ),
            }
            impl ::core::fmt::Debug for GossipBehaviourEvent
            where
                gossipsub::Behaviour: ::libp2p::swarm::derive_prelude::NetworkBehaviour,
                allow_block_list::Behaviour<
                    AllowedPeers,
                >: ::libp2p::swarm::derive_prelude::NetworkBehaviour,
                allow_block_list::Behaviour<
                    BlockedPeers,
                >: ::libp2p::swarm::derive_prelude::NetworkBehaviour,
                <gossipsub::Behaviour as ::libp2p::swarm::derive_prelude::NetworkBehaviour>::ToSwarm: ::core::fmt::Debug,
                <allow_block_list::Behaviour<
                    AllowedPeers,
                > as ::libp2p::swarm::derive_prelude::NetworkBehaviour>::ToSwarm: ::core::fmt::Debug,
                <allow_block_list::Behaviour<
                    BlockedPeers,
                > as ::libp2p::swarm::derive_prelude::NetworkBehaviour>::ToSwarm: ::core::fmt::Debug,
            {
                fn fmt(
                    &self,
                    f: &mut std::fmt::Formatter<'_>,
                ) -> Result<(), std::fmt::Error> {
                    match &self {
                        GossipBehaviourEvent::Gossipsub(event) => {
                            f.write_fmt(
                                format_args!("{0}: {1:?}", "GossipBehaviourEvent", event),
                            )
                        }
                        GossipBehaviourEvent::AllowedPeers(event) => {
                            f.write_fmt(
                                format_args!("{0}: {1:?}", "GossipBehaviourEvent", event),
                            )
                        }
                        GossipBehaviourEvent::BlockedPeers(event) => {
                            f.write_fmt(
                                format_args!("{0}: {1:?}", "GossipBehaviourEvent", event),
                            )
                        }
                    }
                }
            }
            impl ::libp2p::swarm::derive_prelude::NetworkBehaviour for GossipBehaviour
            where
                gossipsub::Behaviour: ::libp2p::swarm::derive_prelude::NetworkBehaviour,
                allow_block_list::Behaviour<
                    AllowedPeers,
                >: ::libp2p::swarm::derive_prelude::NetworkBehaviour,
                allow_block_list::Behaviour<
                    BlockedPeers,
                >: ::libp2p::swarm::derive_prelude::NetworkBehaviour,
            {
                type ConnectionHandler = ::libp2p::swarm::derive_prelude::ConnectionHandlerSelect<
                    ::libp2p::swarm::derive_prelude::ConnectionHandlerSelect<
                        ::libp2p::swarm::derive_prelude::THandler<gossipsub::Behaviour>,
                        ::libp2p::swarm::derive_prelude::THandler<
                            allow_block_list::Behaviour<AllowedPeers>,
                        >,
                    >,
                    ::libp2p::swarm::derive_prelude::THandler<
                        allow_block_list::Behaviour<BlockedPeers>,
                    >,
                >;
                type ToSwarm = GossipBehaviourEvent;
                #[allow(clippy::needless_question_mark)]
                fn handle_pending_inbound_connection(
                    &mut self,
                    connection_id: ::libp2p::swarm::derive_prelude::ConnectionId,
                    local_addr: &::libp2p::swarm::derive_prelude::Multiaddr,
                    remote_addr: &::libp2p::swarm::derive_prelude::Multiaddr,
                ) -> Result<(), ::libp2p::swarm::derive_prelude::ConnectionDenied> {
                    ::libp2p::swarm::derive_prelude::NetworkBehaviour::handle_pending_inbound_connection(
                        &mut self.gossipsub,
                        connection_id,
                        local_addr,
                        remote_addr,
                    )?;
                    ::libp2p::swarm::derive_prelude::NetworkBehaviour::handle_pending_inbound_connection(
                        &mut self.allowed_peers,
                        connection_id,
                        local_addr,
                        remote_addr,
                    )?;
                    ::libp2p::swarm::derive_prelude::NetworkBehaviour::handle_pending_inbound_connection(
                        &mut self.blocked_peers,
                        connection_id,
                        local_addr,
                        remote_addr,
                    )?;
                    Ok(())
                }
                #[allow(clippy::needless_question_mark)]
                fn handle_established_inbound_connection(
                    &mut self,
                    connection_id: ::libp2p::swarm::derive_prelude::ConnectionId,
                    peer: ::libp2p::swarm::derive_prelude::PeerId,
                    local_addr: &::libp2p::swarm::derive_prelude::Multiaddr,
                    remote_addr: &::libp2p::swarm::derive_prelude::Multiaddr,
                ) -> Result<
                    ::libp2p::swarm::derive_prelude::THandler<Self>,
                    ::libp2p::swarm::derive_prelude::ConnectionDenied,
                > {
                    Ok(
                        ::libp2p::swarm::derive_prelude::ConnectionHandler::select(
                            ::libp2p::swarm::derive_prelude::ConnectionHandler::select(
                                self
                                    .gossipsub
                                    .handle_established_inbound_connection(
                                        connection_id,
                                        peer,
                                        local_addr,
                                        remote_addr,
                                    )?,
                                self
                                    .allowed_peers
                                    .handle_established_inbound_connection(
                                        connection_id,
                                        peer,
                                        local_addr,
                                        remote_addr,
                                    )?,
                            ),
                            self
                                .blocked_peers
                                .handle_established_inbound_connection(
                                    connection_id,
                                    peer,
                                    local_addr,
                                    remote_addr,
                                )?,
                        ),
                    )
                }
                #[allow(clippy::needless_question_mark)]
                fn handle_pending_outbound_connection(
                    &mut self,
                    connection_id: ::libp2p::swarm::derive_prelude::ConnectionId,
                    maybe_peer: Option<::libp2p::swarm::derive_prelude::PeerId>,
                    addresses: &[::libp2p::swarm::derive_prelude::Multiaddr],
                    effective_role: ::libp2p::swarm::derive_prelude::Endpoint,
                ) -> Result<
                    ::std::vec::Vec<::libp2p::swarm::derive_prelude::Multiaddr>,
                    ::libp2p::swarm::derive_prelude::ConnectionDenied,
                > {
                    let mut combined_addresses = ::alloc::vec::Vec::new();
                    combined_addresses
                        .extend(
                            ::libp2p::swarm::derive_prelude::NetworkBehaviour::handle_pending_outbound_connection(
                                &mut self.gossipsub,
                                connection_id,
                                maybe_peer,
                                addresses,
                                effective_role,
                            )?,
                        );
                    combined_addresses
                        .extend(
                            ::libp2p::swarm::derive_prelude::NetworkBehaviour::handle_pending_outbound_connection(
                                &mut self.allowed_peers,
                                connection_id,
                                maybe_peer,
                                addresses,
                                effective_role,
                            )?,
                        );
                    combined_addresses
                        .extend(
                            ::libp2p::swarm::derive_prelude::NetworkBehaviour::handle_pending_outbound_connection(
                                &mut self.blocked_peers,
                                connection_id,
                                maybe_peer,
                                addresses,
                                effective_role,
                            )?,
                        );
                    Ok(combined_addresses)
                }
                #[allow(clippy::needless_question_mark)]
                fn handle_established_outbound_connection(
                    &mut self,
                    connection_id: ::libp2p::swarm::derive_prelude::ConnectionId,
                    peer: ::libp2p::swarm::derive_prelude::PeerId,
                    addr: &::libp2p::swarm::derive_prelude::Multiaddr,
                    role_override: ::libp2p::swarm::derive_prelude::Endpoint,
                ) -> Result<
                    ::libp2p::swarm::derive_prelude::THandler<Self>,
                    ::libp2p::swarm::derive_prelude::ConnectionDenied,
                > {
                    Ok(
                        ::libp2p::swarm::derive_prelude::ConnectionHandler::select(
                            ::libp2p::swarm::derive_prelude::ConnectionHandler::select(
                                self
                                    .gossipsub
                                    .handle_established_outbound_connection(
                                        connection_id,
                                        peer,
                                        addr,
                                        role_override,
                                    )?,
                                self
                                    .allowed_peers
                                    .handle_established_outbound_connection(
                                        connection_id,
                                        peer,
                                        addr,
                                        role_override,
                                    )?,
                            ),
                            self
                                .blocked_peers
                                .handle_established_outbound_connection(
                                    connection_id,
                                    peer,
                                    addr,
                                    role_override,
                                )?,
                        ),
                    )
                }
                fn on_connection_handler_event(
                    &mut self,
                    peer_id: ::libp2p::swarm::derive_prelude::PeerId,
                    connection_id: ::libp2p::swarm::derive_prelude::ConnectionId,
                    event: ::libp2p::swarm::derive_prelude::THandlerOutEvent<Self>,
                ) {
                    match event {
                        ::libp2p::swarm::derive_prelude::Either::Left(
                            ::libp2p::swarm::derive_prelude::Either::Left(ev),
                        ) => {
                            ::libp2p::swarm::derive_prelude::NetworkBehaviour::on_connection_handler_event(
                                &mut self.gossipsub,
                                peer_id,
                                connection_id,
                                ev,
                            )
                        }
                        ::libp2p::swarm::derive_prelude::Either::Left(
                            ::libp2p::swarm::derive_prelude::Either::Right(ev),
                        ) => {
                            ::libp2p::swarm::derive_prelude::NetworkBehaviour::on_connection_handler_event(
                                &mut self.allowed_peers,
                                peer_id,
                                connection_id,
                                ev,
                            )
                        }
                        ::libp2p::swarm::derive_prelude::Either::Right(ev) => {
                            ::libp2p::swarm::derive_prelude::NetworkBehaviour::on_connection_handler_event(
                                &mut self.blocked_peers,
                                peer_id,
                                connection_id,
                                ev,
                            )
                        }
                    }
                }
                fn poll(
                    &mut self,
                    cx: &mut std::task::Context,
                    poll_params: &mut impl ::libp2p::swarm::derive_prelude::PollParameters,
                ) -> std::task::Poll<
                    ::libp2p::swarm::derive_prelude::ToSwarm<
                        Self::ToSwarm,
                        ::libp2p::swarm::derive_prelude::THandlerInEvent<Self>,
                    >,
                > {
                    use ::libp2p::swarm::derive_prelude::futures::*;
                    match ::libp2p::swarm::derive_prelude::NetworkBehaviour::poll(
                        &mut self.gossipsub,
                        cx,
                        poll_params,
                    ) {
                        std::task::Poll::Ready(
                            ::libp2p::swarm::derive_prelude::ToSwarm::GenerateEvent(
                                event,
                            ),
                        ) => {
                            return std::task::Poll::Ready(
                                ::libp2p::swarm::derive_prelude::ToSwarm::GenerateEvent(
                                    GossipBehaviourEvent::Gossipsub(event),
                                ),
                            );
                        }
                        std::task::Poll::Ready(
                            ::libp2p::swarm::derive_prelude::ToSwarm::Dial { opts },
                        ) => {
                            return std::task::Poll::Ready(::libp2p::swarm::derive_prelude::ToSwarm::Dial {
                                opts,
                            });
                        }
                        std::task::Poll::Ready(
                            ::libp2p::swarm::derive_prelude::ToSwarm::ListenOn { opts },
                        ) => {
                            return std::task::Poll::Ready(::libp2p::swarm::derive_prelude::ToSwarm::ListenOn {
                                opts,
                            });
                        }
                        std::task::Poll::Ready(
                            ::libp2p::swarm::derive_prelude::ToSwarm::RemoveListener {
                                id,
                            },
                        ) => {
                            return std::task::Poll::Ready(::libp2p::swarm::derive_prelude::ToSwarm::RemoveListener {
                                id,
                            });
                        }
                        std::task::Poll::Ready(
                            ::libp2p::swarm::derive_prelude::ToSwarm::NotifyHandler {
                                peer_id,
                                handler,
                                event,
                            },
                        ) => {
                            return std::task::Poll::Ready(::libp2p::swarm::derive_prelude::ToSwarm::NotifyHandler {
                                peer_id,
                                handler,
                                event: ::libp2p::swarm::derive_prelude::Either::Left(
                                    ::libp2p::swarm::derive_prelude::Either::Left(event),
                                ),
                            });
                        }
                        std::task::Poll::Ready(
                            ::libp2p::swarm::derive_prelude::ToSwarm::NewExternalAddrCandidate(
                                addr,
                            ),
                        ) => {
                            return std::task::Poll::Ready(
                                ::libp2p::swarm::derive_prelude::ToSwarm::NewExternalAddrCandidate(
                                    addr,
                                ),
                            );
                        }
                        std::task::Poll::Ready(
                            ::libp2p::swarm::derive_prelude::ToSwarm::ExternalAddrConfirmed(
                                addr,
                            ),
                        ) => {
                            return std::task::Poll::Ready(
                                ::libp2p::swarm::derive_prelude::ToSwarm::ExternalAddrConfirmed(
                                    addr,
                                ),
                            );
                        }
                        std::task::Poll::Ready(
                            ::libp2p::swarm::derive_prelude::ToSwarm::ExternalAddrExpired(
                                addr,
                            ),
                        ) => {
                            return std::task::Poll::Ready(
                                ::libp2p::swarm::derive_prelude::ToSwarm::ExternalAddrExpired(
                                    addr,
                                ),
                            );
                        }
                        std::task::Poll::Ready(
                            ::libp2p::swarm::derive_prelude::ToSwarm::CloseConnection {
                                peer_id,
                                connection,
                            },
                        ) => {
                            return std::task::Poll::Ready(::libp2p::swarm::derive_prelude::ToSwarm::CloseConnection {
                                peer_id,
                                connection,
                            });
                        }
                        std::task::Poll::Pending => {}
                    }
                    match ::libp2p::swarm::derive_prelude::NetworkBehaviour::poll(
                        &mut self.allowed_peers,
                        cx,
                        poll_params,
                    ) {
                        std::task::Poll::Ready(
                            ::libp2p::swarm::derive_prelude::ToSwarm::GenerateEvent(
                                event,
                            ),
                        ) => {
                            return std::task::Poll::Ready(
                                ::libp2p::swarm::derive_prelude::ToSwarm::GenerateEvent(
                                    GossipBehaviourEvent::AllowedPeers(event),
                                ),
                            );
                        }
                        std::task::Poll::Ready(
                            ::libp2p::swarm::derive_prelude::ToSwarm::Dial { opts },
                        ) => {
                            return std::task::Poll::Ready(::libp2p::swarm::derive_prelude::ToSwarm::Dial {
                                opts,
                            });
                        }
                        std::task::Poll::Ready(
                            ::libp2p::swarm::derive_prelude::ToSwarm::ListenOn { opts },
                        ) => {
                            return std::task::Poll::Ready(::libp2p::swarm::derive_prelude::ToSwarm::ListenOn {
                                opts,
                            });
                        }
                        std::task::Poll::Ready(
                            ::libp2p::swarm::derive_prelude::ToSwarm::RemoveListener {
                                id,
                            },
                        ) => {
                            return std::task::Poll::Ready(::libp2p::swarm::derive_prelude::ToSwarm::RemoveListener {
                                id,
                            });
                        }
                        std::task::Poll::Ready(
                            ::libp2p::swarm::derive_prelude::ToSwarm::NotifyHandler {
                                peer_id,
                                handler,
                                event,
                            },
                        ) => {
                            return std::task::Poll::Ready(::libp2p::swarm::derive_prelude::ToSwarm::NotifyHandler {
                                peer_id,
                                handler,
                                event: ::libp2p::swarm::derive_prelude::Either::Left(
                                    ::libp2p::swarm::derive_prelude::Either::Right(event),
                                ),
                            });
                        }
                        std::task::Poll::Ready(
                            ::libp2p::swarm::derive_prelude::ToSwarm::NewExternalAddrCandidate(
                                addr,
                            ),
                        ) => {
                            return std::task::Poll::Ready(
                                ::libp2p::swarm::derive_prelude::ToSwarm::NewExternalAddrCandidate(
                                    addr,
                                ),
                            );
                        }
                        std::task::Poll::Ready(
                            ::libp2p::swarm::derive_prelude::ToSwarm::ExternalAddrConfirmed(
                                addr,
                            ),
                        ) => {
                            return std::task::Poll::Ready(
                                ::libp2p::swarm::derive_prelude::ToSwarm::ExternalAddrConfirmed(
                                    addr,
                                ),
                            );
                        }
                        std::task::Poll::Ready(
                            ::libp2p::swarm::derive_prelude::ToSwarm::ExternalAddrExpired(
                                addr,
                            ),
                        ) => {
                            return std::task::Poll::Ready(
                                ::libp2p::swarm::derive_prelude::ToSwarm::ExternalAddrExpired(
                                    addr,
                                ),
                            );
                        }
                        std::task::Poll::Ready(
                            ::libp2p::swarm::derive_prelude::ToSwarm::CloseConnection {
                                peer_id,
                                connection,
                            },
                        ) => {
                            return std::task::Poll::Ready(::libp2p::swarm::derive_prelude::ToSwarm::CloseConnection {
                                peer_id,
                                connection,
                            });
                        }
                        std::task::Poll::Pending => {}
                    }
                    match ::libp2p::swarm::derive_prelude::NetworkBehaviour::poll(
                        &mut self.blocked_peers,
                        cx,
                        poll_params,
                    ) {
                        std::task::Poll::Ready(
                            ::libp2p::swarm::derive_prelude::ToSwarm::GenerateEvent(
                                event,
                            ),
                        ) => {
                            return std::task::Poll::Ready(
                                ::libp2p::swarm::derive_prelude::ToSwarm::GenerateEvent(
                                    GossipBehaviourEvent::BlockedPeers(event),
                                ),
                            );
                        }
                        std::task::Poll::Ready(
                            ::libp2p::swarm::derive_prelude::ToSwarm::Dial { opts },
                        ) => {
                            return std::task::Poll::Ready(::libp2p::swarm::derive_prelude::ToSwarm::Dial {
                                opts,
                            });
                        }
                        std::task::Poll::Ready(
                            ::libp2p::swarm::derive_prelude::ToSwarm::ListenOn { opts },
                        ) => {
                            return std::task::Poll::Ready(::libp2p::swarm::derive_prelude::ToSwarm::ListenOn {
                                opts,
                            });
                        }
                        std::task::Poll::Ready(
                            ::libp2p::swarm::derive_prelude::ToSwarm::RemoveListener {
                                id,
                            },
                        ) => {
                            return std::task::Poll::Ready(::libp2p::swarm::derive_prelude::ToSwarm::RemoveListener {
                                id,
                            });
                        }
                        std::task::Poll::Ready(
                            ::libp2p::swarm::derive_prelude::ToSwarm::NotifyHandler {
                                peer_id,
                                handler,
                                event,
                            },
                        ) => {
                            return std::task::Poll::Ready(::libp2p::swarm::derive_prelude::ToSwarm::NotifyHandler {
                                peer_id,
                                handler,
                                event: ::libp2p::swarm::derive_prelude::Either::Right(event),
                            });
                        }
                        std::task::Poll::Ready(
                            ::libp2p::swarm::derive_prelude::ToSwarm::NewExternalAddrCandidate(
                                addr,
                            ),
                        ) => {
                            return std::task::Poll::Ready(
                                ::libp2p::swarm::derive_prelude::ToSwarm::NewExternalAddrCandidate(
                                    addr,
                                ),
                            );
                        }
                        std::task::Poll::Ready(
                            ::libp2p::swarm::derive_prelude::ToSwarm::ExternalAddrConfirmed(
                                addr,
                            ),
                        ) => {
                            return std::task::Poll::Ready(
                                ::libp2p::swarm::derive_prelude::ToSwarm::ExternalAddrConfirmed(
                                    addr,
                                ),
                            );
                        }
                        std::task::Poll::Ready(
                            ::libp2p::swarm::derive_prelude::ToSwarm::ExternalAddrExpired(
                                addr,
                            ),
                        ) => {
                            return std::task::Poll::Ready(
                                ::libp2p::swarm::derive_prelude::ToSwarm::ExternalAddrExpired(
                                    addr,
                                ),
                            );
                        }
                        std::task::Poll::Ready(
                            ::libp2p::swarm::derive_prelude::ToSwarm::CloseConnection {
                                peer_id,
                                connection,
                            },
                        ) => {
                            return std::task::Poll::Ready(::libp2p::swarm::derive_prelude::ToSwarm::CloseConnection {
                                peer_id,
                                connection,
                            });
                        }
                        std::task::Poll::Pending => {}
                    }
                    std::task::Poll::Pending
                }
                fn on_swarm_event(
                    &mut self,
                    event: ::libp2p::swarm::derive_prelude::FromSwarm<
                        Self::ConnectionHandler,
                    >,
                ) {
                    match event {
                        ::libp2p::swarm::derive_prelude::FromSwarm::ConnectionEstablished(
                            ::libp2p::swarm::derive_prelude::ConnectionEstablished {
                                peer_id,
                                connection_id,
                                endpoint,
                                failed_addresses,
                                other_established,
                            },
                        ) => {
                            self.gossipsub
                                .on_swarm_event(
                                    ::libp2p::swarm::derive_prelude::FromSwarm::ConnectionEstablished(::libp2p::swarm::derive_prelude::ConnectionEstablished {
                                        peer_id,
                                        connection_id,
                                        endpoint,
                                        failed_addresses,
                                        other_established,
                                    }),
                                );
                            self.allowed_peers
                                .on_swarm_event(
                                    ::libp2p::swarm::derive_prelude::FromSwarm::ConnectionEstablished(::libp2p::swarm::derive_prelude::ConnectionEstablished {
                                        peer_id,
                                        connection_id,
                                        endpoint,
                                        failed_addresses,
                                        other_established,
                                    }),
                                );
                            self.blocked_peers
                                .on_swarm_event(
                                    ::libp2p::swarm::derive_prelude::FromSwarm::ConnectionEstablished(::libp2p::swarm::derive_prelude::ConnectionEstablished {
                                        peer_id,
                                        connection_id,
                                        endpoint,
                                        failed_addresses,
                                        other_established,
                                    }),
                                );
                        }
                        ::libp2p::swarm::derive_prelude::FromSwarm::AddressChange(
                            ::libp2p::swarm::derive_prelude::AddressChange {
                                peer_id,
                                connection_id,
                                old,
                                new,
                            },
                        ) => {
                            self.gossipsub
                                .on_swarm_event(
                                    ::libp2p::swarm::derive_prelude::FromSwarm::AddressChange(::libp2p::swarm::derive_prelude::AddressChange {
                                        peer_id,
                                        connection_id,
                                        old,
                                        new,
                                    }),
                                );
                            self.allowed_peers
                                .on_swarm_event(
                                    ::libp2p::swarm::derive_prelude::FromSwarm::AddressChange(::libp2p::swarm::derive_prelude::AddressChange {
                                        peer_id,
                                        connection_id,
                                        old,
                                        new,
                                    }),
                                );
                            self.blocked_peers
                                .on_swarm_event(
                                    ::libp2p::swarm::derive_prelude::FromSwarm::AddressChange(::libp2p::swarm::derive_prelude::AddressChange {
                                        peer_id,
                                        connection_id,
                                        old,
                                        new,
                                    }),
                                );
                        }
                        ::libp2p::swarm::derive_prelude::FromSwarm::ConnectionClosed(
                            ::libp2p::swarm::derive_prelude::ConnectionClosed {
                                peer_id,
                                connection_id,
                                endpoint,
                                handler: handlers,
                                remaining_established,
                            },
                        ) => {
                            let (handlers, handler) = handlers.into_inner();
                            self.blocked_peers
                                .on_swarm_event(
                                    ::libp2p::swarm::derive_prelude::FromSwarm::ConnectionClosed(::libp2p::swarm::derive_prelude::ConnectionClosed {
                                        peer_id,
                                        connection_id,
                                        endpoint,
                                        handler,
                                        remaining_established,
                                    }),
                                );
                            let (handlers, handler) = handlers.into_inner();
                            self.allowed_peers
                                .on_swarm_event(
                                    ::libp2p::swarm::derive_prelude::FromSwarm::ConnectionClosed(::libp2p::swarm::derive_prelude::ConnectionClosed {
                                        peer_id,
                                        connection_id,
                                        endpoint,
                                        handler,
                                        remaining_established,
                                    }),
                                );
                            let handler = handlers;
                            self.gossipsub
                                .on_swarm_event(
                                    ::libp2p::swarm::derive_prelude::FromSwarm::ConnectionClosed(::libp2p::swarm::derive_prelude::ConnectionClosed {
                                        peer_id,
                                        connection_id,
                                        endpoint,
                                        handler,
                                        remaining_established,
                                    }),
                                );
                        }
                        ::libp2p::swarm::derive_prelude::FromSwarm::DialFailure(
                            ::libp2p::swarm::derive_prelude::DialFailure {
                                peer_id,
                                connection_id,
                                error,
                            },
                        ) => {
                            self.gossipsub
                                .on_swarm_event(
                                    ::libp2p::swarm::derive_prelude::FromSwarm::DialFailure(::libp2p::swarm::derive_prelude::DialFailure {
                                        peer_id,
                                        connection_id,
                                        error,
                                    }),
                                );
                            self.allowed_peers
                                .on_swarm_event(
                                    ::libp2p::swarm::derive_prelude::FromSwarm::DialFailure(::libp2p::swarm::derive_prelude::DialFailure {
                                        peer_id,
                                        connection_id,
                                        error,
                                    }),
                                );
                            self.blocked_peers
                                .on_swarm_event(
                                    ::libp2p::swarm::derive_prelude::FromSwarm::DialFailure(::libp2p::swarm::derive_prelude::DialFailure {
                                        peer_id,
                                        connection_id,
                                        error,
                                    }),
                                );
                        }
                        ::libp2p::swarm::derive_prelude::FromSwarm::ListenFailure(
                            ::libp2p::swarm::derive_prelude::ListenFailure {
                                local_addr,
                                send_back_addr,
                                connection_id,
                                error,
                            },
                        ) => {
                            self.gossipsub
                                .on_swarm_event(
                                    ::libp2p::swarm::derive_prelude::FromSwarm::ListenFailure(::libp2p::swarm::derive_prelude::ListenFailure {
                                        local_addr,
                                        send_back_addr,
                                        connection_id,
                                        error,
                                    }),
                                );
                            self.allowed_peers
                                .on_swarm_event(
                                    ::libp2p::swarm::derive_prelude::FromSwarm::ListenFailure(::libp2p::swarm::derive_prelude::ListenFailure {
                                        local_addr,
                                        send_back_addr,
                                        connection_id,
                                        error,
                                    }),
                                );
                            self.blocked_peers
                                .on_swarm_event(
                                    ::libp2p::swarm::derive_prelude::FromSwarm::ListenFailure(::libp2p::swarm::derive_prelude::ListenFailure {
                                        local_addr,
                                        send_back_addr,
                                        connection_id,
                                        error,
                                    }),
                                );
                        }
                        ::libp2p::swarm::derive_prelude::FromSwarm::NewListener(
                            ::libp2p::swarm::derive_prelude::NewListener { listener_id },
                        ) => {
                            self.gossipsub
                                .on_swarm_event(
                                    ::libp2p::swarm::derive_prelude::FromSwarm::NewListener(::libp2p::swarm::derive_prelude::NewListener {
                                        listener_id,
                                    }),
                                );
                            self.allowed_peers
                                .on_swarm_event(
                                    ::libp2p::swarm::derive_prelude::FromSwarm::NewListener(::libp2p::swarm::derive_prelude::NewListener {
                                        listener_id,
                                    }),
                                );
                            self.blocked_peers
                                .on_swarm_event(
                                    ::libp2p::swarm::derive_prelude::FromSwarm::NewListener(::libp2p::swarm::derive_prelude::NewListener {
                                        listener_id,
                                    }),
                                );
                        }
                        ::libp2p::swarm::derive_prelude::FromSwarm::NewListenAddr(
                            ::libp2p::swarm::derive_prelude::NewListenAddr {
                                listener_id,
                                addr,
                            },
                        ) => {
                            self.gossipsub
                                .on_swarm_event(
                                    ::libp2p::swarm::derive_prelude::FromSwarm::NewListenAddr(::libp2p::swarm::derive_prelude::NewListenAddr {
                                        listener_id,
                                        addr,
                                    }),
                                );
                            self.allowed_peers
                                .on_swarm_event(
                                    ::libp2p::swarm::derive_prelude::FromSwarm::NewListenAddr(::libp2p::swarm::derive_prelude::NewListenAddr {
                                        listener_id,
                                        addr,
                                    }),
                                );
                            self.blocked_peers
                                .on_swarm_event(
                                    ::libp2p::swarm::derive_prelude::FromSwarm::NewListenAddr(::libp2p::swarm::derive_prelude::NewListenAddr {
                                        listener_id,
                                        addr,
                                    }),
                                );
                        }
                        ::libp2p::swarm::derive_prelude::FromSwarm::ExpiredListenAddr(
                            ::libp2p::swarm::derive_prelude::ExpiredListenAddr {
                                listener_id,
                                addr,
                            },
                        ) => {
                            self.gossipsub
                                .on_swarm_event(
                                    ::libp2p::swarm::derive_prelude::FromSwarm::ExpiredListenAddr(::libp2p::swarm::derive_prelude::ExpiredListenAddr {
                                        listener_id,
                                        addr,
                                    }),
                                );
                            self.allowed_peers
                                .on_swarm_event(
                                    ::libp2p::swarm::derive_prelude::FromSwarm::ExpiredListenAddr(::libp2p::swarm::derive_prelude::ExpiredListenAddr {
                                        listener_id,
                                        addr,
                                    }),
                                );
                            self.blocked_peers
                                .on_swarm_event(
                                    ::libp2p::swarm::derive_prelude::FromSwarm::ExpiredListenAddr(::libp2p::swarm::derive_prelude::ExpiredListenAddr {
                                        listener_id,
                                        addr,
                                    }),
                                );
                        }
                        ::libp2p::swarm::derive_prelude::FromSwarm::NewExternalAddrCandidate(
                            ::libp2p::swarm::derive_prelude::NewExternalAddrCandidate {
                                addr,
                            },
                        ) => {
                            self.gossipsub
                                .on_swarm_event(
                                    ::libp2p::swarm::derive_prelude::FromSwarm::NewExternalAddrCandidate(::libp2p::swarm::derive_prelude::NewExternalAddrCandidate {
                                        addr,
                                    }),
                                );
                            self.allowed_peers
                                .on_swarm_event(
                                    ::libp2p::swarm::derive_prelude::FromSwarm::NewExternalAddrCandidate(::libp2p::swarm::derive_prelude::NewExternalAddrCandidate {
                                        addr,
                                    }),
                                );
                            self.blocked_peers
                                .on_swarm_event(
                                    ::libp2p::swarm::derive_prelude::FromSwarm::NewExternalAddrCandidate(::libp2p::swarm::derive_prelude::NewExternalAddrCandidate {
                                        addr,
                                    }),
                                );
                        }
                        ::libp2p::swarm::derive_prelude::FromSwarm::ExternalAddrExpired(
                            ::libp2p::swarm::derive_prelude::ExternalAddrExpired { addr },
                        ) => {
                            self.gossipsub
                                .on_swarm_event(
                                    ::libp2p::swarm::derive_prelude::FromSwarm::ExternalAddrExpired(::libp2p::swarm::derive_prelude::ExternalAddrExpired {
                                        addr,
                                    }),
                                );
                            self.allowed_peers
                                .on_swarm_event(
                                    ::libp2p::swarm::derive_prelude::FromSwarm::ExternalAddrExpired(::libp2p::swarm::derive_prelude::ExternalAddrExpired {
                                        addr,
                                    }),
                                );
                            self.blocked_peers
                                .on_swarm_event(
                                    ::libp2p::swarm::derive_prelude::FromSwarm::ExternalAddrExpired(::libp2p::swarm::derive_prelude::ExternalAddrExpired {
                                        addr,
                                    }),
                                );
                        }
                        ::libp2p::swarm::derive_prelude::FromSwarm::ExternalAddrConfirmed(
                            ::libp2p::swarm::derive_prelude::ExternalAddrConfirmed {
                                addr,
                            },
                        ) => {
                            self.gossipsub
                                .on_swarm_event(
                                    ::libp2p::swarm::derive_prelude::FromSwarm::ExternalAddrConfirmed(::libp2p::swarm::derive_prelude::ExternalAddrConfirmed {
                                        addr,
                                    }),
                                );
                            self.allowed_peers
                                .on_swarm_event(
                                    ::libp2p::swarm::derive_prelude::FromSwarm::ExternalAddrConfirmed(::libp2p::swarm::derive_prelude::ExternalAddrConfirmed {
                                        addr,
                                    }),
                                );
                            self.blocked_peers
                                .on_swarm_event(
                                    ::libp2p::swarm::derive_prelude::FromSwarm::ExternalAddrConfirmed(::libp2p::swarm::derive_prelude::ExternalAddrConfirmed {
                                        addr,
                                    }),
                                );
                        }
                        ::libp2p::swarm::derive_prelude::FromSwarm::ListenerError(
                            ::libp2p::swarm::derive_prelude::ListenerError {
                                listener_id,
                                err,
                            },
                        ) => {
                            self.gossipsub
                                .on_swarm_event(
                                    ::libp2p::swarm::derive_prelude::FromSwarm::ListenerError(::libp2p::swarm::derive_prelude::ListenerError {
                                        listener_id,
                                        err,
                                    }),
                                );
                            self.allowed_peers
                                .on_swarm_event(
                                    ::libp2p::swarm::derive_prelude::FromSwarm::ListenerError(::libp2p::swarm::derive_prelude::ListenerError {
                                        listener_id,
                                        err,
                                    }),
                                );
                            self.blocked_peers
                                .on_swarm_event(
                                    ::libp2p::swarm::derive_prelude::FromSwarm::ListenerError(::libp2p::swarm::derive_prelude::ListenerError {
                                        listener_id,
                                        err,
                                    }),
                                );
                        }
                        ::libp2p::swarm::derive_prelude::FromSwarm::ListenerClosed(
                            ::libp2p::swarm::derive_prelude::ListenerClosed {
                                listener_id,
                                reason,
                            },
                        ) => {
                            self.gossipsub
                                .on_swarm_event(
                                    ::libp2p::swarm::derive_prelude::FromSwarm::ListenerClosed(::libp2p::swarm::derive_prelude::ListenerClosed {
                                        listener_id,
                                        reason,
                                    }),
                                );
                            self.allowed_peers
                                .on_swarm_event(
                                    ::libp2p::swarm::derive_prelude::FromSwarm::ListenerClosed(::libp2p::swarm::derive_prelude::ListenerClosed {
                                        listener_id,
                                        reason,
                                    }),
                                );
                            self.blocked_peers
                                .on_swarm_event(
                                    ::libp2p::swarm::derive_prelude::FromSwarm::ListenerClosed(::libp2p::swarm::derive_prelude::ListenerClosed {
                                        listener_id,
                                        reason,
                                    }),
                                );
                        }
                        _ => {}
                    }
                }
            }
        }
        mod gossip_node {
            use std::str::FromStr;
            use libp2p::{
                core::upgrade, gossipsub::Message as GossipSubMessage,
                gossipsub::{self, Topic},
                gossipsub::{MessageAuthenticity, MessageId},
                identity, noise, swarm::{SwarmBuilder, SwarmEvent},
                tcp, Multiaddr, PeerId, Swarm, Transport,
            };
            use prost::Message;
            use tokio::{runtime::Runtime, select};
            use crate::{
                core::{
                    errors::{BadRequestType, HubError, UnavailableType},
                    protobufs::generated::{
                        gossip_message, FarcasterNetwork, GossipMessage, GossipVersion,
                    },
                },
                teleport::AddrInfo,
            };
            use super::{gossip_behaviour::GossipBehaviour, utils::check_node_addrs};
            const MULTI_ADDR_LOCAL_HOST: &str = "/ip4/127.0.0.1";
            pub const MAX_MESSAGE_QUEUE_SIZE: usize = 100_000;
            pub struct NodeOptions {
                keypair: Option<identity::Keypair>,
                ip_multi_addr: Option<String>,
                gossip_port: Option<u16>,
                pub allowed_peer_ids: Option<Vec<PeerId>>,
                pub denied_peer_ids: Option<Vec<PeerId>>,
                pub direct_peers: Option<Vec<AddrInfo>>,
            }
            pub(crate) struct GossipNode {
                network: FarcasterNetwork,
                pub(crate) swarm: Swarm<GossipBehaviour>,
            }
            impl GossipNode {
                async fn pubsub_peer_discovery(&mut self) -> Result<(), HubError> {
                    let peer_discovery_topic_str = {
                        let res = ::alloc::fmt::format(
                            format_args!(
                                "_farcaster.{0}.peer_discovery",
                                self.network.as_str_name(),
                            ),
                        );
                        res
                    };
                    let peer_discovery_topic = gossipsub::IdentTopic::new(
                        peer_discovery_topic_str,
                    );
                    self.swarm
                        .behaviour_mut()
                        .gossipsub
                        .subscribe(&peer_discovery_topic)
                        .unwrap();
                    Ok(())
                }
                async fn create_node(
                    &mut self,
                    options: NodeOptions,
                ) -> Result<(), HubError> {
                    let local_key = options
                        .keypair
                        .unwrap_or(identity::Keypair::generate_ed25519());
                    let local_peer_id = PeerId::from(local_key.public());
                    let listen_ip_multi_addr = options
                        .ip_multi_addr
                        .unwrap_or(MULTI_ADDR_LOCAL_HOST.to_string());
                    let listen_port = options.gossip_port.unwrap_or(0);
                    let listen_multi_addr_str = {
                        let res = ::alloc::fmt::format(
                            format_args!(
                                "{0}/tcp/{1}",
                                listen_ip_multi_addr,
                                listen_port,
                            ),
                        );
                        res
                    };
                    let listen_multi_addr = Multiaddr::from_str(&listen_multi_addr_str)
                        .expect("invalid multiaddr");
                    let check_result = check_node_addrs(
                        listen_ip_multi_addr,
                        listen_multi_addr_str,
                    );
                    if check_result.is_err() {
                        return Err(
                            HubError::Unavailable(
                                UnavailableType::Generic,
                                check_result.unwrap_err().to_string(),
                            ),
                        );
                    }
                    let primary_topic = self.primary_topic();
                    let message_authenticity = MessageAuthenticity::Signed(
                        local_key.clone(),
                    );
                    let gossipsub_config = libp2p::gossipsub::ConfigBuilder::default()
                        .validation_mode(libp2p::gossipsub::ValidationMode::Strict)
                        .message_id_fn(move |message: &GossipSubMessage| {
                            get_message_id(&primary_topic, message)
                        })
                        .build()
                        .expect("Valid config");
                    let mut gossipsub: gossipsub::Behaviour = gossipsub::Behaviour::new(
                            message_authenticity,
                            gossipsub_config,
                        )
                        .expect("Valid config");
                    let mut allowed_peers: libp2p::allow_block_list::Behaviour<
                        libp2p::allow_block_list::AllowedPeers,
                    > = libp2p::allow_block_list::Behaviour::default();
                    let mut blocked_peers: libp2p::allow_block_list::Behaviour<
                        libp2p::allow_block_list::BlockedPeers,
                    > = libp2p::allow_block_list::Behaviour::default();
                    if options.direct_peers.is_some() {
                        for peer in options.direct_peers.unwrap() {
                            gossipsub.add_explicit_peer(&peer.id);
                        }
                    }
                    if let Some(allowed_peer_ids) = options.allowed_peer_ids {
                        for peer_id in allowed_peer_ids {
                            allowed_peers.allow_peer(peer_id)
                        }
                    }
                    if let Some(denied_peer_ids) = options.denied_peer_ids {
                        for peer_id in denied_peer_ids {
                            blocked_peers.block_peer(peer_id)
                        }
                    }
                    let behaviour = GossipBehaviour {
                        gossipsub,
                        allowed_peers,
                        blocked_peers,
                    };
                    let tcp_transport = libp2p::tcp::tokio::Transport::default()
                        .upgrade(upgrade::Version::V1Lazy)
                        .authenticate(
                            noise::Config::new(&local_key)
                                .expect("signing libp2p-noise static keypair"),
                        )
                        .multiplex(libp2p_mplex::MplexConfig::new())
                        .boxed();
                    let mut swarm = SwarmBuilder::with_tokio_executor(
                            tcp_transport,
                            behaviour,
                            local_peer_id,
                        )
                        .build();
                    swarm.listen_on(listen_multi_addr).unwrap();
                    self.swarm = swarm;
                    Ok(())
                }
                fn primary_topic(&self) -> String {
                    {
                        let res = ::alloc::fmt::format(
                            format_args!(
                                "f_network_{0}_primary",
                                self.network.as_str_name(),
                            ),
                        );
                        res
                    }
                }
            }
            pub fn decode_message(message: &[u8]) -> Result<GossipMessage, HubError> {
                let gossip_message = GossipMessage::decode(message)
                    .map_err(|_| {
                        HubError::BadRequest(
                            BadRequestType::ParseFailure,
                            "Invalid failure".to_owned(),
                        )
                    })
                    .unwrap();
                let supported_versions = <[_]>::into_vec(
                    #[rustc_box]
                    ::alloc::boxed::Box::new([GossipVersion::V1, GossipVersion::V11]),
                );
                if gossip_message.topics.len() == 0
                    || !supported_versions.contains(&gossip_message.version())
                {
                    return Err(
                        HubError::BadRequest(
                            BadRequestType::ParseFailure,
                            "Invalid failure".to_owned(),
                        ),
                    );
                }
                PeerId::from_bytes(&gossip_message.peer_id)
                    .map_err(|_| {
                        HubError::BadRequest(
                            BadRequestType::ParseFailure,
                            "Invalid failure".to_owned(),
                        )
                    })?;
                Ok(gossip_message)
            }
            pub fn get_message_id(
                primary_topic: &str,
                message: &GossipSubMessage,
            ) -> MessageId {
                let message_topic = message.topic.as_str();
                if message_topic.contains(primary_topic) {
                    let protocol_message = decode_message(&message.data);
                    if let Ok(message) = protocol_message {
                        if message.version() == GossipVersion::V11 {
                            if let Some(content) = message.content {
                                match content {
                                    gossip_message::Content::Message(message_content) => {
                                        return MessageId::from(message_content.hash);
                                    }
                                    gossip_message::Content::IdRegistryEvent(event_content) => {
                                        return MessageId::from(event_content.transaction_hash);
                                    }
                                    _ => {}
                                }
                            }
                        }
                    }
                }
                default_message_id_fn(message)
            }
            pub fn default_message_id_fn(message: &GossipSubMessage) -> MessageId {
                let mut source_string = if let Some(peer_id) = message.source.as_ref() {
                    peer_id.to_base58()
                } else {
                    PeerId::from_bytes(&[0, 1, 0]).expect("Valid peer id").to_base58()
                };
                source_string
                    .push_str(&message.sequence_number.unwrap_or_default().to_string());
                MessageId::from(source_string)
            }
        }
        mod handle_swarm_event {
            use std::io;
            use libp2p::swarm::SwarmEvent;
            use super::gossip_behaviour::GossipBehaviour;
            pub trait SwarmEventHandler {
                fn handle(&self, event: SwarmEvent<GossipBehaviour, io::Error>);
            }
        }
        mod pubsub_peer_discovery {
            use std::{sync::Arc, time::Duration};
            use libp2p::swarm::SwarmEvent;
            use libp2p::{gossipsub::IdentTopic, Swarm};
            use tokio::sync::Mutex;
            use tokio::time;
            use crate::core::errors::HubError;
            use super::gossip_behaviour::{GossipBehaviour, GossipBehaviourEvent};
            use super::handle_swarm_event::SwarmEventHandler;
            pub struct PubSubPeerDiscovery {
                interval: Duration,
                listen_only: bool,
                is_started: bool,
                topic: IdentTopic,
                swarm: Arc<Mutex<Swarm<GossipBehaviour>>>,
                stop_signal: Arc<Mutex<bool>>,
            }
            impl PubSubPeerDiscovery {
                pub fn new(
                    interval: Duration,
                    listen_only: bool,
                    swarm: Arc<Mutex<Swarm<GossipBehaviour>>>,
                    topic: IdentTopic,
                ) -> Self {
                    Self {
                        interval,
                        listen_only,
                        is_started: false,
                        topic,
                        swarm,
                        stop_signal: Arc::new(Mutex::new(false)),
                    }
                }
                pub fn is_started(&self) -> bool {
                    self.is_started
                }
                pub async fn start(&mut self) -> Result<(), HubError> {
                    if self.is_started {
                        return Ok(());
                    }
                    self.swarm
                        .lock()
                        .await
                        .behaviour_mut()
                        .gossipsub
                        .subscribe(&self.topic)
                        .unwrap();
                    self.is_started = true;
                    if self.listen_only {
                        return Ok(());
                    }
                    broadcast(self.swarm.clone(), &self.topic).await;
                    let stop_signal = self.stop_signal.clone();
                    let swarm = self.swarm.clone();
                    let topic = self.topic.clone();
                    let interval = self.interval;
                    tokio::spawn(async move {
                        let mut interval = time::interval(interval);
                        loop {
                            {
                                #[doc(hidden)]
                                mod __tokio_select_util {
                                    pub(super) enum Out<_0, _1> {
                                        _0(_0),
                                        _1(_1),
                                        Disabled,
                                    }
                                    pub(super) type Mask = u8;
                                }
                                use ::tokio::macros::support::Future;
                                use ::tokio::macros::support::Pin;
                                use ::tokio::macros::support::Poll::{Ready, Pending};
                                const BRANCHES: u32 = 2;
                                let mut disabled: __tokio_select_util::Mask = Default::default();
                                if !true {
                                    let mask: __tokio_select_util::Mask = 1 << 0;
                                    disabled |= mask;
                                }
                                if !true {
                                    let mask: __tokio_select_util::Mask = 1 << 1;
                                    disabled |= mask;
                                }
                                let mut output = {
                                    let mut futures = (
                                        interval.tick(),
                                        tokio::signal::ctrl_c(),
                                    );
                                    let mut futures = &mut futures;
                                    ::tokio::macros::support::poll_fn(|cx| {
                                            let mut is_pending = false;
                                            let start = {
                                                ::tokio::macros::support::thread_rng_n(BRANCHES)
                                            };
                                            for i in 0..BRANCHES {
                                                let branch;
                                                #[allow(clippy::modulo_one)]
                                                {
                                                    branch = (start + i) % BRANCHES;
                                                }
                                                match branch {
                                                    #[allow(unreachable_code)]
                                                    0 => {
                                                        let mask = 1 << branch;
                                                        if disabled & mask == mask {
                                                            continue;
                                                        }
                                                        let (fut, ..) = &mut *futures;
                                                        let mut fut = unsafe { Pin::new_unchecked(fut) };
                                                        let out = match Future::poll(fut, cx) {
                                                            Ready(out) => out,
                                                            Pending => {
                                                                is_pending = true;
                                                                continue;
                                                            }
                                                        };
                                                        disabled |= mask;
                                                        #[allow(unused_variables)] #[allow(unused_mut)]
                                                        match &out {
                                                            _ => {}
                                                            _ => continue,
                                                        }
                                                        return Ready(__tokio_select_util::Out::_0(out));
                                                    }
                                                    #[allow(unreachable_code)]
                                                    1 => {
                                                        let mask = 1 << branch;
                                                        if disabled & mask == mask {
                                                            continue;
                                                        }
                                                        let (_, fut, ..) = &mut *futures;
                                                        let mut fut = unsafe { Pin::new_unchecked(fut) };
                                                        let out = match Future::poll(fut, cx) {
                                                            Ready(out) => out,
                                                            Pending => {
                                                                is_pending = true;
                                                                continue;
                                                            }
                                                        };
                                                        disabled |= mask;
                                                        #[allow(unused_variables)] #[allow(unused_mut)]
                                                        match &out {
                                                            _ => {}
                                                            _ => continue,
                                                        }
                                                        return Ready(__tokio_select_util::Out::_1(out));
                                                    }
                                                    _ => {
                                                        ::core::panicking::panic_fmt(
                                                            format_args!(
                                                                "internal error: entered unreachable code: {0}",
                                                                format_args!(
                                                                    "reaching this means there probably is an off by one bug",
                                                                ),
                                                            ),
                                                        );
                                                    }
                                                }
                                            }
                                            if is_pending {
                                                Pending
                                            } else {
                                                Ready(__tokio_select_util::Out::Disabled)
                                            }
                                        })
                                        .await
                                };
                                match output {
                                    __tokio_select_util::Out::_0(_) => {
                                        if *stop_signal.lock().await {
                                            break;
                                        }
                                        broadcast(swarm.clone(), &topic).await;
                                    }
                                    __tokio_select_util::Out::_1(_) => {
                                        *stop_signal.lock().await = true;
                                        break;
                                    }
                                    __tokio_select_util::Out::Disabled => {
                                        ::core::panicking::panic_fmt(
                                            format_args!(
                                                "all branches are disabled and there is no else branch",
                                            ),
                                        );
                                    }
                                    _ => {
                                        ::core::panicking::panic_fmt(
                                            format_args!(
                                                "internal error: entered unreachable code: {0}",
                                                format_args!("failed to match bind"),
                                            ),
                                        );
                                    }
                                }
                            }
                        }
                    });
                    Ok(())
                }
                pub async fn stop(&mut self) -> Result<(), HubError> {
                    if !self.is_started {
                        return Ok(());
                    }
                    self.swarm
                        .lock()
                        .await
                        .behaviour_mut()
                        .gossipsub
                        .unsubscribe(&self.topic)
                        .unwrap();
                    self.is_started = false;
                    Ok(())
                }
            }
            impl SwarmEventHandler for PubSubPeerDiscovery {
                fn handle(
                    &self,
                    event: libp2p::swarm::SwarmEvent<GossipBehaviour, std::io::Error>,
                ) {
                    if !self.is_started {
                        return;
                    }
                    if let SwarmEvent::Behaviour(e) = event {
                        match e {
                            GossipBehaviourEvent::Gossipsub(e) => {
                                if let GossipsubEvent::Message(peer_id, message_id, message)
                                    = event {
                                    if !self.topics.contains(&message.topic) {
                                        return;
                                    }
                                    let peer = match PeerId::from_public_key(message.data) {
                                        Ok(peer) => peer,
                                        Err(err) => {
                                            ();
                                            return;
                                        }
                                    };
                                    if peer == self.components.peer_id {
                                        return;
                                    }
                                    ();
                                    let multiaddrs: Vec<Multiaddr> = message
                                        .addrs
                                        .iter()
                                        .map(|b| Multiaddr::try_from(b))
                                        .collect();
                                    self.dispatch_event(PeerInfo {
                                        id: peer,
                                        multiaddrs,
                                        protocols: ::alloc::vec::Vec::new(),
                                    });
                                }
                            }
                            _ => {}
                        }
                    }
                }
            }
            pub async fn broadcast(
                swarm: Arc<Mutex<Swarm<GossipBehaviour>>>,
                topic: &IdentTopic,
            ) {
                let encoded_peer_id = swarm.lock().await.local_peer_id().to_bytes();
                let _ = swarm
                    .lock()
                    .await
                    .behaviour_mut()
                    .gossipsub
                    .publish(topic.clone(), encoded_peer_id);
            }
        }
        mod utils {
            use std::{net::IpAddr, option};
            use libp2p::{multiaddr::Protocol, Multiaddr};
            use crate::core::errors::{BadRequestType, HubError};
            pub enum IpVersion {
                Invalid,
                IPv4,
                IPv6,
            }
            #[automatically_derived]
            impl ::core::fmt::Debug for IpVersion {
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    ::core::fmt::Formatter::write_str(
                        f,
                        match self {
                            IpVersion::Invalid => "Invalid",
                            IpVersion::IPv4 => "IPv4",
                            IpVersion::IPv6 => "IPv6",
                        },
                    )
                }
            }
            pub fn parse_address(multiaddr_str: &str) -> Result<Multiaddr, HubError> {
                if multiaddr_str.is_empty() {
                    return Err(
                        HubError::BadRequest(
                            BadRequestType::Generic,
                            "multiaddr must not be empty".to_owned(),
                        ),
                    );
                }
                let multiaddr = libp2p::multiaddr::from_url(multiaddr_str);
                match multiaddr {
                    Err(_) => {
                        Err(
                            HubError::BadRequest(
                                BadRequestType::ParseFailure,
                                {
                                    let res = ::alloc::fmt::format(
                                        format_args!("\'{0}\': invalid multiaddr", multiaddr_str),
                                    );
                                    res
                                },
                            ),
                        )
                    }
                    Ok(multiaddr) => Ok(multiaddr),
                }
            }
            pub fn get_ip_version(input: &str) -> IpVersion {
                match input.parse::<IpAddr>() {
                    Ok(ip_addr) => {
                        if ip_addr.is_ipv4() { IpVersion::IPv4 } else { IpVersion::IPv6 }
                    }
                    Err(_) => IpVersion::Invalid,
                }
            }
            pub fn check_node_addrs(
                listen_ip_addr: String,
                listen_combined_addr: String,
            ) -> Result<(), HubError> {
                let result_ip = check_ip_addr(&listen_ip_addr);
                let result_combined = check_combined_addr(&listen_combined_addr);
                result_ip.and_then(|_| result_combined)
            }
            fn check_ip_addr(ip_addr: &str) -> Result<(), HubError> {
                let parsed_addr = parse_address(ip_addr);
                if parsed_addr.is_err() {
                    return Err(parsed_addr.unwrap_err());
                }
                let binding = parsed_addr.unwrap();
                let options = binding.iter().collect::<Vec<_>>();
                if options.len() > 1 {
                    return Err(
                        HubError::BadRequest(
                            BadRequestType::Generic,
                            "unexpected multiaddr transport/port information".to_owned(),
                        ),
                    );
                }
                Ok(())
            }
            fn check_combined_addr(combined_addr: &str) -> Result<(), HubError> {
                let parsed_addr = parse_address(combined_addr);
                if parsed_addr.is_err() {
                    return Err(parsed_addr.unwrap_err());
                }
                let multi_addr = parsed_addr.unwrap();
                let components = multi_addr.iter().collect::<Vec<_>>();
                let protocol_option = components.get(1);
                if let Some(Protocol::Tcp(_)) = protocol_option {
                    {
                        ::std::io::_print(format_args!("Second option is Tcp\n"));
                    };
                } else {
                    return Err(
                        HubError::BadRequest(
                            BadRequestType::Generic,
                            "multiaddr transport must be tcp".to_owned(),
                        ),
                    );
                }
                Ok(())
            }
        }
    }
}
mod rpc {
    pub mod hub_service_client {}
}
mod teleport {
    use libp2p::{Multiaddr, PeerId};
    use tonic::transport::Channel;
    use crate::core::{
        errors::HubError, protobufs::generated::{hub_service_client::HubServiceClient, *},
    };
    enum HubSubmitSource {
        Gossip,
        RPC,
        EthProvider,
        L2Provider,
        Sync,
        FNameRegistry,
    }
    trait HubInterface {
        fn submit_message(
            &self,
            message: Message,
            source: Option<HubSubmitSource>,
        ) -> Result<u128, HubError>;
        fn submit_id_registry_event(
            &self,
            event: IdRegistryEvent,
            source: Option<HubSubmitSource>,
        ) -> Result<u128, HubError>;
        fn submit_name_registry_event(
            &self,
            event: NameRegistryEvent,
            source: Option<HubSubmitSource>,
        ) -> Result<u128, HubError>;
        fn submit_username_proof(
            &self,
            proof: UserNameProof,
            source: Option<HubSubmitSource>,
        ) -> Result<u128, HubError>;
        fn submit_onchain_event(
            &self,
            event: OnChainEvent,
            source: Option<HubSubmitSource>,
        ) -> Result<u128, HubError>;
        fn get_hub_state(&self) -> Result<HubState, HubError>;
        fn put_hub_state(&self, state: HubState) -> Result<(), HubError>;
        fn gossip_contact_info(&self) -> Result<(), HubError>;
        fn get_rpc_client_for_peer(
            &self,
            peer_id: PeerId,
            peer: ContactInfoContent,
        ) -> Result<HubServiceClient<Channel>, HubError>;
    }
    struct TestUser {
        fid: u64,
        mnemonic: String,
    }
    pub struct AddrInfo {
        pub id: PeerId,
        pub addrs: Vec<Multiaddr>,
    }
    struct HubOptions {
        network: FarcasterNetwork,
        peer_id: Option<PeerId>,
        bootstrap_addrs: Option<Vec<Multiaddr>>,
        allowed_peers: Option<Vec<String>>,
        denied_peers: Option<Vec<String>>,
        ip_multi_addr: Option<String>,
        rpc_server_host: Option<String>,
        anounce_ip: Option<String>,
        announce_server_name: Option<String>,
        gossip_port: Option<u16>,
        rpc_port: Option<u16>,
        rpc_auth: Option<String>,
        rpc_rate_limit: Option<u128>,
        rank_rpcs: Option<bool>,
        eth_rpc_url: Option<String>,
        eth_mainnet_rpc_url: Option<String>,
        fname_server_url: Option<String>,
        l2_rpc_url: Option<String>,
        id_registry_address: Option<String>,
        name_registry_address: Option<String>,
        l2_id_registry_address: Option<String>,
        l2_key_registry_address: Option<String>,
        l2_storage_registry_address: Option<String>,
        first_block: Option<u64>,
        chunk_size: Option<u64>,
        l2_first_block: Option<u64>,
        l2_chunk_size: Option<u64>,
        l2_chain_id: Option<u64>,
        l2_rent_expiry_override: Option<u64>,
        l2_resync_events: Option<bool>,
        eth_resync_events: Option<bool>,
        resync_name_events: Option<bool>,
        db_name: Option<String>,
        reset_db: Option<bool>,
        profile_sync: Option<bool>,
        rebuild_sync_trie: Option<bool>,
        commit_lock_timeout: u64,
        commit_lock_max_pending: u64,
        admin_server_enabled: Option<bool>,
        admin_server_host: Option<String>,
        test_users: Option<Vec<TestUser>>,
        local_ip_addrs_only: Option<bool>,
        prune_messages_job_cron: Option<String>,
        prune_events_job_cron: Option<String>,
        gossip_metrics_enabled: Option<bool>,
        direct_peers: Option<Vec<AddrInfo>>,
    }
    struct Hub {
        options: HubOptions,
    }
}
fn main() {
    let body = async {
        {
            ::std::io::_print(format_args!("Hello, world!\n"));
        };
    };
    #[allow(clippy::expect_used, clippy::diverging_sub_expression)]
    {
        return tokio::runtime::Builder::new_multi_thread()
            .enable_all()
            .build()
            .expect("Failed building the Runtime")
            .block_on(body);
    }
}
